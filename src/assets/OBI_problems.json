[
  {
    "name": "Número de Envelopes",
    "description": "Aldo é um garoto muito esperto que adora promoções e sorteios. Como já participou de muitas promoções da forma “para participar, envie n rótulos de produtos ...”, Aldo tem o costume de guardar o rótulo de todos os produtos que compra. Dessa forma, sempre que uma empresa faz uma promoção ele já tem um monte de rótulos para mandar.\nA SBC (Super Balas e Caramelos) está fazendo uma nova promoção, e, como era de se esperar, Aldo quer participar. Para participar da promoção é preciso enviar um envelope contendo um rótulo de cada tipo de bala que a SBC produz. Por exemplo, se a SBC produz 3 tipos de balas, A, B, C, e uma pessoa tem 3 rótulos de A, 3 de B e 2 de C, ela pode enviar no máximo 2 envelopes, já que falta um rótulo de C para compor o terceiro envelope. Não há limite para o número de envelopes que uma pessoa pode enviar.\nBalas são a segunda coisa de que Aldo mais gosta (a primeira como você sabe são promoções). Por causa disso a quantidade de rótulos de balas que ele tem é muito grande, e ele não está conseguindo determinar a quantidade máxima de envelopes que ele pode enviar.\nComo você é o melhor amigo de Aldo ele pediu sua ajuda para fazer o cálculo, de modo que ele compre o número exato de envelopes.\nTarefa Você deve escrever um programa que, a partir da lista de rótulos de Aldo, calcula o número máximo de envelopes válidos que ele pode enviar.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado). A primeira linha da entrada contém um número inteiro N (1 ≤ N ≤ 1000) representando o número de tipos diferentes de balas que a SBC produz. A segunda linha da entrada contém N números inteiros, cada um representando uma quantidade de rótulos de balas que Aldo tem. O primeiro número nessa linha representa a quantidade de rótulos do tipo 1 que Aldo possui, o segundo número representa a quantidade de rótulos do tipo 2, e assim por diante, até o último número, que representa a quantidade de rótulos de tipo N que Aldo possui.\nSaída\nSeu programa deve imprimir, na saída padrão, o número máximo de envelopes válidos que Aldo pode enviar.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 10.\n• Em um conjunto de casos de teste que totaliza 80 pontos, N ≤ 100.\nExemplos",
    "examples": [
      [
        "4\n5 3 6 2",
        "2"
      ],
      [
        "6\n10 5 21 3 0 11",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "envelopes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Overflow",
    "description": "Os computadores foram inventados para realizar cálculos muito rapidamente, e atendem a esse requisito de maneira extraordinária. Porém, nem toda conta pode ser feita num computador, pois ele não consegue representar todos os números dentro de sua memória. Em um computador pessoal atual, por exemplo, o maior inteiro que é possível representar em sua memória é 4.294.967.295. Caso alguma conta executada pelo computador dê um resultado acima desse número, ocorrerá o que chamamos de overflow, que é quando o computador faz uma conta e o resultado não pode ser representado, por ser maior do que o valor máximo permitido (em inglês overflow significa trasbordar).\nPor exemplo, se um computador só pode representar números menores do que 1023 e mandamos ele executar a conta 1022 + 5, vai ocorrer overflow.\nTarefa Dados o maior número que um computador consegue representar e uma expressão de soma ou multiplicação entre dois inteiros, determine se ocorrerá overflow.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 500.000) representando o maior número que o computador consegue representar. A segunda linha contém um inteiro P (0 ≤ P ≤ 1000), seguido de um espaço em branco, seguido de um caractere C (que pode ser ‘+’ ou ‘*’, representando os operadores de adição e multiplicação, respectivamente), seguido de um espaço em branco, seguido de um outro inteiro Q (0 ≤ Q ≤ 1000). Essa linha representa a expressão P + Q, se o caractere C for ‘+’, ou P × Q, se o caractere C for ‘*’.\nSaída\nSeu programa deve imprimir, na saída padrão, a palavra ‘OVERFLOW’ se o resultado da expressão causar um overflow, ou a palavra ‘OK’ caso contrário. Ambas as palavras devem ser escritas com letras maiúsculas.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 10, P ≤ 10 e Q ≤ 10.\n• Em um conjunto de casos de teste que totaliza 80 pontos, N ≤ 100, P ≤ 100 e Q ≤ 100.\nExemplos",
    "examples": [
      [
        "10\n5 + 5",
        "OK"
      ],
      [
        "44\n23 * 2",
        "OVERFLOW"
      ],
      [
        "323500\n42 * 35",
        "OK"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "overflow"
    },
    "imagesQuant": 0
  },
  {
    "name": "Aviões de papel",
    "description": "Para descontrair os alunos após as provas da OBI, a Diretora da escola organizou um campeonato de aviões de papel. Cada aluno participante receberá uma certa quantidade de folhas de um papel especial para fazer os seus modelos de aviões. A quantidade de folhas que cada aluno deverá receber ainda não foi determinada: ela será decidida pelos juízes do campeonato.\nA diretora convidou, para atuarem como juízes, engenheiros da Embraer, uma das mais bem sucedidas empresas brasileiras, que vende aviões com tecnologia brasileira no mundo todo. O campeonato está programado para começar logo após a prova da OBI, mas os juízes ainda não chegaram à escola. A diretora está aflita, pois comprou uma boa quantidade de folhas de papel especial, mas não sabe se a quantidade comprada vai ser suficiente.\nConsidere, por exemplo, que a Diretora comprou 100 folhas de papel especial, e que há 33 competidores. Se os juízes decidirem que cada competidor tem direito a três folhas de papel, a quantidade comprada pela diretora é suficiente. Mas se os juízes decidirem que cada competidor tem direito a quatro folhas, a quantidade comprada pela diretora não seria suficiente.\nTarefa Você deve escrever um programa que, dados o número de competidores, o número de folhas de papel especial compradas pela Diretora e o número de folhas que cada competidor deve receber, determine se o número de folhas comprado pela Diretora é suficiente.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado). O arquivo de entrada contém três números inteiros C (1 ≤ C ≤ 1000), P (1 ≤ P ≤ 1000) e F (1 ≤ F ≤ 1000) representando respectivamente o número de competidores, a quantidade de folhas de papel especial compradas pela Diretora e a quantidade de folhas de papel especial que cada competidor deve receber.\nSaída\nSeu programa deve imprimir, na saída padrão, o caractere ‘S’ se a quantidade de folhas compradas pela Diretora é suficiente, ou o caractere ‘N’ caso contrário. Note que os caracteres devem ser letras maiúsculas.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, C ≤ 10, P ≤ 10 e F ≤ 10.\n• Em um conjunto de casos de teste que totaliza 80 pontos, C ≤ 100, P ≤ 100 e F ≤ 100.\nExemplos",
    "examples": [
      [
        "10 100 10",
        "S"
      ],
      [
        "10 90 10",
        "N"
      ],
      [
        "5 40 2",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "papel"
    },
    "imagesQuant": 0
  },
  {
    "name": "Feira de Bactérias",
    "description": "Bruno é um bíologo apaixonado por sua profissão. Sua especialidade é estudar o comportamento de bactérias.\nPor isso, ele possui em seu laboratório centenas de colônias de diferentes tipos desses microorganismos.\nNesta semana ele viu o anúncio de um evento inusitado: uma feira de bactérias. Nessa feira, vários fornecedores estarão vendendo diferentes tipos de bactérias. Cada tipo de bactéria é vendido em uma placa de vidro, já preparada para a formação de uma colônia de bactérias. Cada placa de vidro é vendida com apenas uma bactéria inicialmente.\nBruno deu uma olhada no catálogo com os tipos de bactérias que estarão à venda na feira, e notou algumas coisas interessantes: • Todos os tipos de bactérias à venda terão o mesmo preço.\n• Todas as bactérias (de todos os tipos) se subdividem todas as noites para gerar outras bactérias. Por exemplo, a bactéria da colônia de tipo X se subdivide em 2 outras bactérias todas as noites. Assim, no primeiro dia teremos só uma bactéria na colônia. No dia seguinte, teremos 2, e no próximo, 4. A quantidade de divisões de uma bactéria depende do seu tipo.\n• O crescimento da colônia cessa após um determinado número de dias, por causa da escassez de alimento.\nA quantidade de dias em que uma colônia cresce depende do tipo de bactéria.\nÉ final de mês e Bruno já gastou quase todo o seu dinheiro. Assim, resolveu que irá comprar apenas uma colônia de bactérias. No entanto, ele pretende comprar a colônia que forneça a maior quantidade de bactérias ao final do período de crescimento da mesma.\nEle tem um catálogo mostrando os tipos de bactérias à venda. Para cada tipo de bactéria, o catálogo informa a quantidade de bactérias geradas por uma bactéria desse tipo a cada divisão e por quantos dias a população da colônia crescerá. Porém, a calculadora que ele tem em casa não é suficiente para que ele faça os cálculos necessários para decidir qual é a melhor colônia a comprar.\nTarefa Bruno pediu sua ajuda para decidir qual é o melhor tipo de bactéria para a compra. Lembre que para Bruno o melhor tipo de bactéria é aquele cuja colônia, ao final do período de crescimento, terá a maior quantidade de bactérias.\nVocê deve supor que não haverá duas colônias com a mesma população final de bactérias.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 50.000) representando a quantidade tipos de bactérias no catálogo. Cada uma das N linhas seguintes contém informações sobre um tipo de bactéria: a primeira dessas linhas contém a informação da bactéria de tipo 0, a segunda dessas linhas contém a informação sobre a bactéria de tipo 1, e assim por diante. A última dessas linhas contém a informação da bactéria de tipo N − 1.\nA informação para cada tipo de bactéria é composta por dois números inteiros D e C (1 ≤ D ≤ 2.000 e 1 ≤ C ≤ 5.000), onde D é quantidade de bactérias que cada bactéria deste tipo gera ao se dividir numa noite, e C é a quantidade de dias que a população de bactérias crescerá.\nSaída\nSeu programa deve imprimir, na saída padrão, um número inteiro entre 0 e N − 1 representando o tipo da bactéria que Bruno deverá comprar.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 20 pontos, N ≤ 1.000, DC ≤ 1.000.000.\n• Em um conjunto de casos de teste que totaliza 80 pontos, N ≤ 2.000, D ≤ 2.000, C ≤ 5.000.\nExemplos",
    "examples": [
      [
        "2\n2 5\n3 4",
        "1"
      ],
      [
        "5\n2 1\n4 5\n30 4\n20 6\n2 154",
        "4"
      ],
      [
        "4\n145 15\n2 4999\n3 3211\n135 20",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bacterias"
    },
    "imagesQuant": 0
  },
  {
    "name": "O Fugitivo",
    "description": "Demasi é um terrorista e mafioso italiano que tentou escapar vindo para o Brasil. Mas Demasi não contava com a astúcia de nossa polícia, e acabou sendo preso aqui também.\nPor ser mafioso, Demasi conseguiu contratar advogados muito bons, que através de muitos recursos na justiça, acabaram conseguindo uma liberdade condicional para ele.\nNessa liberdade condicional, Demasi deve permanecer a uma certa distância da delegacia de polícia responsável por ele. Para monitorá-lo melhor, eles instalaram nele uma coleira eletrônica inquebrável que, minuto a minuto, envia para uma central as movimentações de Demasi naquele momento.\nA informação da coleira é enviada indicando uma direção e uma distância. Por exemplo, em quatro minutos chegam as quatro linhas de informação abaixo: N 30 O 44 S 22 L 10 Isso significa que no primeiro minuto Demasi se deslocou 30 metros para o norte (letra N), no minuto seguinte andou 44 metros para o oeste (letra O), no outro minuto andou 22 metros para o sul (letra S) e no quarto minuto se deslocou 10 metros para o leste (letra L). Para poder dar um castigo ao terrorista, o juiz decidiu que Demasi só poderia andar nas quatro direções citadas acima. Ou seja, Demasi nunca se movimenta na direção noroeste, por exemplo. Neste problema, você pode supor que todos os movimentos de Demasi ocorrem sobre um plano cartesiano.\nA polícia precisa estar sempre atenta à movimentação dele, e pede a sua ajuda para verificar se em algum momento o italiano se desloca a uma distância da delegacia maior do que a permitida. A distância considerada para esta medida é a distância euclidiana.\nTarefa Sua missão é criar um programa que receba as informações da coleira de Demasi e diga se em algum momento Demasi esteve a uma distância maior do que a permitida.\nVocê deve assumir que no instante 0 (zero) Demasi está dentro da delegacia (ou seja, a uma distância zero).\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois inteiros N e M (2 ≤ N ≤ 500.000, 1 ≤ M ≤ 1.000.000) representando o número de registros enviados pela coleira de Demasi e a distância máxima que ele pode ficar da delegacia, respectivamente. As N linhas seguintes contêm os registros da coleira, em ordem de envio. Cada linha contém um caractere C (’N’, ’S’, ’L’ ou ’O’, como especificados acima) e um inteiro D (1 ≤ D ≤ 1.000) representando a distância percorrida no minuto.\nSaída\nSeu programa deve imprimir, na saída padrão, o valor 1 se em algum momento Demasi se afastou da delegacia além da distância permitida, ou o valor 0 caso contrário.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 1.000, M ≤ 10.000 e D ≤ 30.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 200.000 e M ≤ 400.000.\nExemplos",
    "examples": [
      [
        "5 10\nN 2\nL 3\nS 4\nO 4\nO 3",
        "0"
      ],
      [
        "5 10\nN 6\nL 8\nS 15\nO 5\nO 4",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fugitivo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caçadores de Mitos",
    "description": "Jorge é um apresentador de televisão que comanda a versão brasileira do grande sucesso Caçadores de Mitos, onde se estuda um mito para descobrir se é fato ou apenas um boato.\nNo próximo episódio, Jorge deverá apresentar o mito que diz que ”os raios não caem duas vezes no mesmo lugar”, referindo-se aos raios das tempestades de chuva.\nPara isso, foi até a cidade de Eletrolândia, que é a cidade com maior ocorrência de raios no mundo. O prefeito tem tanto orgulho desse título que mandou criar um sistema para registrar os raios. Jorge conseguiu um relatório com as ocorrências de cada raio que caiu na cidade nos últimos anos.\nO mapa de Eletrolândia é um retângulo. Para o sistema de registro a cidade é subdividida em quadrados de um metro de lado, denominados quadrantes. Assim, se a cidade tem 300 metros de largura e 1000 de comprimento, ela será subdividida em 300.000 quadrantes. O sistema de registro armazena o quadrante em que o raio caiu.\nCada quadrante é identificado pelas suas coordenadas X e Y, conforme ilustra a figura abaixo, que exemplifica um mapa de uma cidade com oito metros de comprimento por cinco metros de largura (quarenta quadrantes).\n0 1 2 3 4 0 1 2 3 4 5 6 7 Como os quadrantes são relativamente pequenos, Jorge decidiu que se dois raios caíram no mesmo quadrante, pode-se considerar que caíram no mesmo lugar.\nTarefa Sua missão é escrever um programa que receba as coordenadas dos raios que caíram em Eletrolândia nos últimos anos e determine se o mito estudado é realmente apenas um mito ou pode ser considerado verdade.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém um número inteiro N (2 ≤ N ≤ 500.000) representando o número de registros de raios no relatório. Cada uma das N linhas seguintes contém 2 números inteiros X, Y (0 ≤ X,Y ≤ 500), representando o registro de um raio que caiu no quadrante cujas coordenadas são (X,Y ).\nSaída\nSeu programa deve imprimir, na saída padrão, o número 0 se nenhum raio caiu no mesmo lugar, ou o número 1 caso contrário. Note que você deve imprimir o número 1 mesmo que haja mais do que 1 par de raios que caíram no mesmo lugar.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 1.000.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 100.000.\nExemplos",
    "examples": [
      [
        "5\n1 1\n2 3\n3 3\n4 2\n4 4",
        "0"
      ],
      [
        "8\n1 1\n2 2\n2 3\n4 4\n2 3\n6 5\n9 11\n10 10",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mito"
    },
    "imagesQuant": 0
  },
  {
    "name": "Notas da Prova",
    "description": "Rosy é uma talentosa professora do Ensino Médio que já ganhou muitos prêmios pela qualidade de sua aula.\nSeu reconhecimento foi tamanho que foi convidada a dar aulas em uma escola da Inglaterra. Mesmo falando bem inglês, Rosy ficou um pouco apreensiva com a responsabilidade, mas resolveu aceitar a proposta e encará-la como um bom desafio.\nTudo ocorreu bem para Rosy até o dia da prova. Acostumada a dar notas de 0 (zero) a 100 (cem), ela fez o mesmo na primeira prova dos alunos da Inglaterra. No entanto, os alunos acharam estranho, pois na Inglaterra o sistema de notas é diferente: as notas devem ser dadas como conceitos de A a E. O conceito A é o mais alto, enquanto o conceito E é o mais baixo.\nConversando com outros professores, ela recebeu a sugestão de utilizar a seguinte tabela, relacionando as notas numéricas com as notas de conceitos:   O problema é que Rosy já deu as notas no sistema numérico, e terá que converter as notas para o sistema de letras. Porém, Rosy precisa preparar as próximas aulas (para manter a qualidade que a tornou reconhecida), e não tem tempo suficiente para fazer a conversão das notas manualmente.\nTarefa Você deve escrever um programa que recebe uma nota no sistema numérico e determina o conceito correspondente.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado). A entrada contém uma única linha com um número inteiro N (0 ≤ N ≤ 100), representando uma nota de prova no sistema numérico.\nSaída\nSeu programa deve imprimir, na saída padrão, uma letra (A, B, C, D, ou E em maiúsculas) representando o conceito correspondente à nota dada na entrada.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 35 pontos, N ≤ 10.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 50.\nExemplos",
    "examples": [
      [
        "12",
        "D"
      ],
      [
        "87",
        "A"
      ],
      [
        "0",
        "E"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "nota"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caminho das Pontes",
    "description": "Pedrinho é um rapaz muito aventureiro, que nas férias viaja pelo mundo em busca de lugares afastados e com bonitas vistas.\nNa sua viagem atual, Pedrinho está andando por uma escura floresta quando se depara com um perigoso desfiladeiro. Do outro lado do desfiladeiro ele sabe que existe um acampamento onde poderá descansar durante a noite para continuar suas aventuras no dia seguinte.\nPara chegar até o acampamento, ele terá que utilizar pontes que estão suspensas sobre o desfiladeiro. As pontes foram construídas interligando altos pilares cravados no fundo do desfiladeiro.\nAcampamento Pedrinho O piso das pontes é feita de tábuas de tamanhos iguais. Mas as pontes são velhas, e algumas tábuas caíram.\nFelizmente, todas as tábuas que sobraram estão em perfeitas condições, ou seja, não existe o perigo de Pedrinho pisar em uma delas e a tábua cair. Além disso, em nenhuma das pontes duas tábuas consecutivas caíram, de forma que os buracos deixados pelas tábuas que caíram podem ser pulados com segurança.\nNo local onde Pedrinho se encontra existe uma placa mostrando as ligações entre as pontes e também quantas tábuas estão faltando em cada uma das pontes. Pedrinho está cansado e não há muita visibilidade durante a noite. Ele precisa, portanto, tomar muito cuidado para não cair em algum dos buracos.\nPedrinho possui um laptop na mochila, mas só o usa para comunicar-se com os amigos. Ele liga sua internet via satélite, encontra você on-line, e pede sua ajuda.\nTarefa Sua tarefáe escrever um programa que receba as informações sobre as pontes (as ligações entre elas e a quantidade de tábuas faltando em cada uma) e calcule qual é o menor número de buracos que Pedrinho precisa pular para chegar ao outro lado do desfiladeiro.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois número inteiros N e M (1 ≤ N ≤ 1.000, 2 ≤ M ≤ 10.000) representando o número de pilares no desfiladeiro e o número de pontes, respectivamente. Cada uma das M linhas seguintes contém 3 inteiros S, T, B (0 ≤ S ≤ N + 1,0 ≤ T ≤ N + 1 e 0 ≤ B ≤ 1.000), indicando que existe uma ponte ligando os pilares S e T, e que possui B buracos. Não existe linha representando ponte com S = T. O valor de pilar 0 representa a borda do desfiladeiro onde Pedrinho está, e o valor de pilar N + 1 representa a borda do desfiladeiro onde está o acampamento. Não existem duas pontes distintas ligando o mesmo par de locais (pilares ou bordas do desfiladeiro).\nVocê pode supor que sempre existirá um caminho de pontes entre o lado do desfiladeiro em que Pedrinho se encontra até o lado do desfiladeiro onde está o acampamento.\nSaída\nSeu programa deve imprimir, na saída padrão, um número inteiro representando a menor quantidade de buracos que Pedrinho terá que pular para conseguir chegar ao acampamento.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 100 e M ≤ 100.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 500 e M ≤ 5.000.\nExemplos",
    "examples": [
      [
        "2 5\n0 1 1\n0 2 3\n0 3 9\n1 3 2\n2 3 2",
        "3"
      ],
      [
        "4 9\n0 1 1\n0 3 4\n0 4 2\n1 2 5\n1 5 3\n2 5 5\n3 4 2\n3 5 5\n4 5 8",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pontes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Banda",
    "description": "Jimmy é um garoto muito esperto que adora música. No último mês ele ganhou um campeonato de um jogo cujo objetivo é tocar guitarra. Empolgado, Jimmy decidiu montar uma banda. Para Jimmy a banda perfeita tem quatro integrantes, ele e mais três: um baterista, um baixista e um cantor.\nAgora Jimmy precisa encontrar os outros integrantes da banda. Para isto ele reuniu todos os álbums que encontrou na internet e, após escutá-los diversas vezes, compilou o que ele chama de lista de entrosamento entre músicos. Nessa lista ele atribui, para cada par de músicos que já tocaram juntos, uma nota inteira de 1 a 100, que é uma medida de quão bem os músicos tocam juntos (o nível de entrosamento entre eles). Se dois músicos nunca tocaram juntos o nível de entrosamento é zero. Jimmy nunca tocou com nenhum músico da lista.\nJimmy pretende formar a sua banda a partir da lista de entrosamento entre músicos, da seguinte maneira: ele quer escolher os outros três músicos de tal forma que a soma dos níveis de entrosamento dos integrantes da banda seja a maior possível (ou seja, a soma dos níveis de entrosamento dos três pares possíveis de serem formados entre os três novos integrantes seja a maior possível).\nMas a lista de entrosamento entre músicos ficou muito grande e Jimmy não está conseguindo escolher os integrantes. Por isso, Jimmy está pedindo sua ajuda.\nTarefa Você deve ajudar Jimmy a montar a melhor banda possível fazendo um programa que receba uma lista contendo o nível de entrosamento para cada par de músicos que já tocaram junto, e determine os músicos que formariam a melhor banda.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada é formada por dois inteiros N e M, informando respectivamente o número de músicos (3 ≤ N ≤ 100) e o número de pares de músicos que já tocaram juntos (0 ≤ M ≤ 104). Os músicos são identificados por números inteiros de 1 a N. Cada uma das M linhas seguintes contém três inteiros X, Y e Z, em que X e Y representa um par de músicos (1 ≤ X ≤ N, 1 ≤ Y ≤ N e X 6= Y ) e Z representa o seu nível de entrosamento (1 ≤ Z ≤ 100). Cada par de músicos que já tocou junto aparece uma única vez na entrada.\nSaída\nSeu programa deve imprimir, na saída padrão, uma única linha, contendo três números inteiros separados por espaço em branco, identificando os três outros músicos que devem compor a banda (em qualquer ordem). Se existir mais de uma melhor banda, Jimmy contenta-se com qualquer uma.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 10 e M ≤ 100.\n• Em um conjunto de casos de teste que totaliza 80 pontos, N ≤ 50 e M ≤ 2450.\nExemplos",
    "examples": [
      [
        "3 3\n1 2 50\n2 3 27\n3 1 1",
        "1 2 3"
      ],
      [
        "5 8\n1 2 50\n1 3 50\n1 4 50\n2 3 50\n2 5 10\n3 4 50\n3 5 25\n4 5 20",
        "1 3 4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "banda"
    },
    "imagesQuant": 0
  },
  {
    "name": "Competição de chocolate",
    "description": "Carlos e Paula acabaram de ganhar um saco com bolinhas de chocolate. Como sabem que vão comer tudo muito rápido inventaram uma brincadeira: • Eles vão comer de forma alternada, um depois o outro, sendo que sempre a Paula começa.\n• Quem comer a última bolinha ganha a bricadeira.\n• A cada vez, só se pode comer de 1 a M bolinhas, sendo o M decidido pela mãe de Paula, de forma que não engasguem com o chocolate.\nUm exemplo de partida para M = 5, onde Paula ganhou: Quem joga Quantas comeu Número de bolinhas restantes - 17 Paula 5 12 Carlos 4 8 Paula 2 6 Carlos 5 1 Paula 1 0 Ambos são muito espertos e jogam de maneira ótima, de forma que se existe para um deles uma sequência de jogadas que garante a vitória independente da jogada do outro, essa pessoa jogará dessa forma.\nTarefa Sua tarefa é determinar quem vai ganhar a brincadeira, se ambos jogam de forma ótima.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA entrada consiste de uma linha contendo dois inteiros N (1 ≤ N ≤ 106) e M (1 ≤ M ≤ 103), sendo N o número de bolinhas de chocolate e M o número de bolinhas permitidas por vez.\nSaída\nSeu programa deve imprimir, na saída padrão, uma linha, contendo o nome do vencedor, como exemplificado abaixo.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 50 e M ≤ 5.\n• Em um conjunto de casos de teste que totaliza 60 pontos, N ≤ 104 e M ≤ 100.\nExemplos",
    "examples": [
      [
        "5 3",
        "Paula"
      ],
      [
        "31 5",
        "Carlos"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "choco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Maratona",
    "description": "A maratona é talvez a prova mais desgastante entre as modalidades olímpicas: são quarenta e dois mil, cento e noventa e cinco metros de percurso. Por isso, os organizadores sempre posicionam vários postos de água ao longo do trajeto da prova, onde copos de água são distribuídos aos competidores.\nJoão Saci é um jovem atleta que tem boas chances de se tornar um maratonista de primeira linha. No entanto, João Saci descobriu que somente consegue terminar uma maratona se ingerir alguns copos de água durante o percurso. O Laboratório de Biomecânica da universidade local, através de experimentos, determinou que João Saci consegue percorrer exatamente mais dois mil metros após o instante em que ingere um copo de água. A distância que João Saci consegue percorrer após ingerir um copo de água é denominada de distância intermediária máxima. Assim, se a distância entre dois postos de água consecutivos no percurso da maratona for sempre menor ou igual do que a distância intermediária máxima de João Saci, ele consegue terminar a prova.\nCaso contrário ele não consegue terminar a prova.\nO Laboratório de Biomecânica quer agora realizar estudos similares com outros maratonistas, que têm valor de distâncias intermediárias máximas distintas, e precisa de sua ajuda.\nTarefa Sua tarefa é escrever um programa que, dada a posição dos postos de água ao longo do percurso, e a distância intermediária máxima de um atleta, determine se o atleta consegue ou não completar a prova.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois números inteiros N e M, separados por um espaço em branco, indicando respectivamente o número de postos de água (2 ≤ N ≤ 10000) e a distância intermediária máxima de um atleta, em metros (1 ≤ M ≤ 42195). A segunda linha contém N números inteiros Pi, separados por um espaço em branco, representando a posição dos postos de água ao longo do trajeto da maratona. A posição de um posto de água é dada pela distância, em metros, do início do percurso até o posto de água (0 ≤ Pi ≤ 42195 para 1 ≤ i ≤ N). O primeiro posto de água está sempre localizado no ponto de partida (ou seja, P1 = 0) e todos os postos estão em posições distintas. Além disso, os postos de água são dados na ordem crescente de sua distância ao início do percurso.\nNote que a distância total da prova é a oficial para a maratona, ou seja, 42195 metros.\nSaída\nSeu programa deve imprimir, na saída padrão, uma única linha contendo o caractere ‘S’ se o atleta consegue terminar a prova, ou o caractere ‘N’ caso contrário.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 100.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 2000.\nExemplos",
    "examples": [
      [
        "3 20000\n0 20000 33333",
        "S"
      ],
      [
        "8 6000\n0 6000 12000 18000 24000 32000 37000 40000",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "maratona"
    },
    "imagesQuant": 0
  },
  {
    "name": "Olimpíadas",
    "description": "O Comitê Olímpico Internacional (COI) está visitando as cidades candidatas a sediar as Olimpíadas de 2016.\nO Rio de Janeiro é uma das cidades concorrentes, mas a competição é muito acirrada.\nO COI tem um conjunto de exigências que devem ser obedecidas pelas cidades candidatas, como boas arenas para os jogos (ginásios, campos de futebol, pistas de atletismo, parque aquático,...), bons alojamentos, um plano para o tráfego de veículos durante os jogos, etc. Durante sua visita ao Rio de Janeiro, o COI colocou ainda mais uma exigência: a demonstração da qualidade dos sistemas de informática. Especificamente, o COI quer que a organização local demonstre a sua capacidade em informática produzindo um programa que gere a classificação final dos países, considerando o número total de medalhas recebidas pelos atletas de cada país.\nTarefa Sua tarefa é escrever um programa que, dada a informação dos países que receberam medalhas de ouro, prata e bronze em cada modalidade, gere a lista de classificação dos países na competição. Nesta tarefa, os países serão identificados por números inteiros. O melhor colocado deve ser o país que conseguiu o maior número de medalhas, independentemente do tipo da medalha (ouro, prata ou bronze). Se houver empate entre dois países no número total de medalhas, o melhor classificado é o país que tem o menor número de identificação.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois números inteiros N e M, separados por um espaço em branco, indicando respectivamente o número de países (1 ≤ N ≤ 100) e número de modalidades esportivas envolvidas na competição (1 ≤ M ≤ 100). Os países são identificados por números inteiros de 1 a N.\nCada uma das M linhas seguintes contém três números inteiros O, P e B, separados por um espaço em branco, representando os países cujos atletas receberam respectivamente medalhas de ouro (1 ≤ O ≤ N), prata (1 ≤ P ≤ N) e bronze (1 ≤ B ≤ N). Assim, se uma das M linhas contém os números 3 2 1, significa que nessa modalidade a medalha de outro foi ganha pelo país 3, a de prata pelo país 2 e a de bronze pelo país 1.\nSaída\nSeu programa deve imprimir, na saída padrão, uma linha contendo N números, separados por um espaço em branco, representando os países na ordem decrescente de classificação (o primeiro número representa o país que é o primeiro colocado, o segundo número representa o país que é o segundo colocado, e assim por diante).\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 10 e M ≤ 10.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 50 e M ≤ 50.\nExemplos",
    "examples": [
      [
        "2 2\n2 1 2\n1 2 2",
        "2 1"
      ],
      [
        "4 3\n3 2 1\n4 3 1\n4 3 1",
        "1 3 4 2"
      ],
      [
        "3 3\n3 1 2\n2 3 1\n1 2 3",
        "1 2 3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "olimpiada"
    },
    "imagesQuant": 0
  },
  {
    "name": "Competição de chocolate",
    "description": "Carlos e Paula acabaram de ganhar um saco com bolinhas de chocolate. Como sabem que vão comer tudo muito rápido inventaram uma brincadeira: • Eles vão comer de forma alternada, um depois o outro, sendo que sempre a Paula começa.\n• A cada vez, só se pode comer de 1 a M bolinhas, sendo o M decidido pela mãe de Paula, de forma que não engasguem com o chocolate.\n• Se um comeu K bolinhas em sua vez, o próximo não pode comer o mesmo tanto, tendo que comer um número de bolinhas distinto.\n• Quem não puder mais jogar de maneira válida perde.\nUm exemplo de partida para M = 5 e 20 bolinhas, onde Carlos ganhou: Quem joga Quantas comeu Número de bolinhas restantes - - 20 Paula 5 15 Carlos 4 11 Paula 3 8 Carlos 4 4 Paula 2 2 Carlos 1 1 Observe que no final Carlos não poderia comer 2 bolinhas para ganhar, pois seria o mesmo que Paula comeu na vez anterior. Mas Paula também não pôde comer a última bolinha, pois Carlos havia comido apenas uma na rodada anterior, assim Paula ficou sem opção de jogada e perdeu.\nAmbos são muito espertos e jogam de maneira ótima, de forma que se existe para um deles uma sequência de jogadas que garante a vitória independente da jogada do outro, essa pessoa jogará dessa forma.\nTarefa Sua tarefa é determinar quem vai ganhar a brincadeira, se ambos jogam de forma ótima.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA entrada consiste de uma linha contendo dois inteiros N (2 ≤ N ≤ 106) e M (2 ≤ M ≤ 103), sendo N o número de bolinhas de chocolate e M o número de bolinhas permitidas por vez.\nSaída\nSeu programa deve imprimir, na saída padrão, uma linha, contendo o nome do vencedor, como exemplificado abaixo.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 50 pontos, N ≤ 50 e M ≤ 5.\n• Em um conjunto de casos de teste que totaliza 80 pontos, N ≤ 104 e M ≤ 100.\nExemplos",
    "examples": [
      [
        "5 3",
        "Paula"
      ],
      [
        "20 5",
        "Carlos"
      ],
      [
        "5 6",
        "Paula"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chocolate"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cadeiras do auditório",
    "description": "As cadeiras do auditório da escola são organizadas em um quadriculado com L linhas e C colunas. As linhas são numeradas de 1 a L, as colunas são numeradas de 1 a C, e as cadeiras são numeradas de 1 a L × C, de tal modo que uma cadeira na linha i coluna j tem o número (i − 1) × C + j.\nDurante a aula de teatro, a professora fez com que os alunos executassem uma sequência de mudanças na configuração da sala. Cada uma dessas mudanças intercambiou ou duas colunas ou duas linhas. A figura abaixo ilustra uma configuração original com três linhas e quatro colunas, a posição das cadeiras após uma mudança (intercâmbio das colunas 1 e 4), e a posição das cadeiras após mais uma mudança (intercâmbio das linhas 2 e 3).\n1 2 3 4 4 2 3 1 4 2 3 1 5 6 7 8 8 6 7 5 12 10 11 9 9 10 11 12 12 10 11 9 8 6 7 5 Configuração inicial Após intercâmbio das Após intercâmbio das das cadeiras colunas 1 e 4 linhas 2 e 3 Ao final da aula, como era de se esperar, a numeração das cadeiras ficou bem bagunçada. O problema é que a próxima aula é de Matemática, e o professor é muito exigente, e quer começar a aula com as cadeiras perfeitamente posicionadas da maneira original.\nTarefa Sua tarefa é escrever um programa que, dada a posição de cada cadeira ao final da aula de teatro, determine qual é a menor sequência de mudanças que devem ser executadas para retornar as cadeiras aos seus devidos lugares, considerando que cada mudança faça o intercâmbio ou de duas linhas ou de duas colunas de cadeiras.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois números inteiros L e C, representando respectivamente o número de linhas e o número de colunas de cadeiras do auditório (1 ≤ L ≤ 200 e 1 ≤ C ≤ 200). Cada uma das L linhas seguintes contém C números inteiros entre 1 e L×C, separados por um espaço em branco, indicando a posição das cadeiras ao final da aula de teatro. O j-ésimo número dado na linha i é o número da cadeira que se encontra na linha i e coluna j.\nSaída\nSeu programa deve imprimir, na saída padrão, na primeira linha um inteiro K representando o número de mudanças necessárias para retornar as cadeiras para sua posição original. Cada uma das K linhas seguintes contém a descrição de uma mudança, na forma de um caractere M (que pode ser ‘L’ ou ‘C’), seguido de um espaço em branco, seguido de um inteiro X, seguido de um espaço em branco, seguido de um inteiro Y . Se o caractere descrevendo a mudança é ‘L’, X e Y representam linhas que devem ser intercambiadas; se o caractere descrevendo a mudança é ‘C’, X e Y representam colunas que devem ser intercambiadas.\nPara todos os casos testes existe solução com K ≤ 1000. Se mais de uma solução existe com o mesmo número de mudanças, imprima qualquer uma delas.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, L ≤ 10 e C ≤ 10.\n• Em um conjunto de casos de teste que totaliza 70 pontos, L ≤ 100 e C ≤ 100.\nExemplos",
    "examples": [
      [
        "2 2\n4 3\n2 1",
        "2\nL 1 2\nC 1 2"
      ],
      [
        "3 4\n1 2 3 4\n5 6 7 8\n9 10 11 12",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cadeiras"
    },
    "imagesQuant": 0
  },
  {
    "name": "Simulador",
    "description": "Um novo processador, denominado Faíska, está sendo desenvolvido para a empresa SBC. Este novo processador tem apenas duas instruções: inversão e soma, descritas a seguir.\n• Inversão: dados dois endereços de memória X e Y , a operação inverte(X,Y) inverte a posição de palavras da memória de forma que – a palavra no endereço X troca de posição com a palavra de memória da posição Y ; – a palavra no endereço X + 1 troca de posição com a palavra de memória da posição Y − 1; – a palavra no endereço X + 2 troca de posição com a palavra de memória da posição Y − 2; – e assim por diante, até que X ≥ Y .\n• Soma: dados dois endereços de memória X e Y , a operação soma(X,Y) imprime a soma das palavras de memória entre os endereços X e Y (inclusive).\nPor exemplo, se a memória contém inicialmente, a partir da primeira posição de memória (endereço igual a 1) os valores [1,2,3,4,5,6,7,8], a operação inverte(3,7) deixa a memória igual a [1,2,7,6,5,4,3,8]. Então, nesse estado, a execução de soma(1,3) produz a saída 10.\nTarefa Sua tarefa é escever um programa que, dada uma sequência de instruções do Faíska, simule a execução e produza o mesmo resultado que o Faíska produziria.\nEntrada\nA entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado).\nA primeira linha da entrada contém dois números inteiros N e M, representando respectivamente o número palavras na memória (1 ≤ N ≤ 109) e o número de instruções do programa (1 ≤ M ≤ 3000). Cada uma das M linhas seguintes contém uma instrução do Faíska. Cada instrução é composta de um caratere descrevendo a instrução (‘I’ para inversão e ‘S’ para soma), seguido de um espaço, seguido de dois inteiros indicando os argumentos da instrução.\nInicialmente a configuração da memória é tal que cada palavra tem como conteúdo o seu próprio endereço. Em outras palavras, o conteúdo inicial da memória é [1,2,3,...,N]. Há pelo menos uma instrução soma em cada caso de teste.\nSaída\nSeu programa deve imprimir, na saída padrão, uma sequência de números inteiros, um em cada linha, indicando a saída gerada pelo Faíska.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 100 e M ≤ 100.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 104 e M ≤ 103.\nExemplos",
    "examples": [
      [
        "10 2\nI 1 5\nS 3 7",
        "19"
      ],
      [
        "15 4\nS 2 11\nI 10 15\nI 1 10\nS 5 10",
        "65\n21"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2009,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "simulador"
    },
    "imagesQuant": 0
  },
  {
    "name": "Garçom",
    "description": "Parte do treinamento de um novo garçom é carregar uma grande bandeja com várias latas de bebidas e copos e entregá-las todas numa mesa do restaurante. Durante o treinamento é comum que os garçons deixem cair as bandejas, quebrando todos os copos.\nA SBC — Sociedade Brasileira de Copos — analisou estatísticas do treinamento de diversos garçons e descobriu que os garçons em treinamento deixam cair apenas bandejas que têm mais latas de bebidas que copos.\nPor exemplo, se uma bandeja tiver 10 latas e 4 copos, certamente o garçom em treinamento a deixará cair, quebrando os 4 copos. Já se a bandeja tiver 5 latas e 6 copos, ele conseguirá entregá-la sem deixar cair.\nTarefa Escreva um programa que, dado o número de latas e copos em cada bandeja que o garçom tentou entregar, imprime o total de copos que ele quebrou.\nEntrada\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 100) representando o número de bandejas que o garçom tentou entregar. As N linhas seguintes representam as N bandejas. Cada linha contém dois inteiros L e C, indicando o número de latas e o número de copos naquela bandeja, respectivamente (0 ≤ L,C ≤ 100).\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, indicando o número total de copos que o garçom quebrou.\nExemplos",
    "examples": [
      [
        "3\n10 5\n6 8\n3 3",
        "5"
      ],
      [
        "4\n10 6\n8 8\n5 1\n100 100",
        "7"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "garcom"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pneu",
    "description": "Calibrar os pneus do carro deve ser uma tarefa cotidiana de todos os motoristas. Para isto, os postos de gasolina possuem uma bomba de ar. A maioria das bombas atuais são eletrônicas, permitindo que o motorista indique a pressão desejada num teclado. Ao ser ligada ao pneu, a bomba primeiro lê a pressão atual e calcula a diferença de pressão entre a desejada e a lida. Com esta diferença ela esvazia ou enche o pneu para chegar na pressão correta.\nSua ajuda foi requisitada para desenvolver o programa da próxima bomba da SBC – Sistemas de Bombas Computadorizadas.\nTarefa Escreva um programa que, dada a pressão desejada digitada pelo motorista e a pressão do pneu lida pela bomba, indica a diferença entre a pressão desejada e a pressão lida.\nEntrada\nA primeira linha da entrada contém um inteiro N que indica a pressão desejada pelo motorista (1 ≤ N ≤ 40).\nA segunda linha contém um inteiro M que indica a pressão lida pela bomba (1 ≤ M ≤ 40).\nSaída\nSeu programa deve imprimir uma única linha, contendo a diferença entre a pressão desejada e a pressão lida.\nExemplos",
    "examples": [
      [
        "30\n18",
        "12"
      ],
      [
        "27\n27",
        "0"
      ],
      [
        "27\n30",
        "-3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pneu"
    },
    "imagesQuant": 0
  },
  {
    "name": "SEDEX",
    "description": "A Copa do Mundo de 2010 será realizada na África do Sul. Bolas de futebol são muito fáceis de transportar, já que elas saem das fábricas vazias e só são enchidas somente pelas lojas ou pelos consumidores finais.\nInfelizmente o mesmo não pode ser dito das bolas de boliche. Como elas são completamente sólidas, elas só podem ser transportadas embaladas uma a uma, em caixas separadas.\nA SBC — Só Boliche Cascavel — é uma fábrica de bolas de boliche que trabalha somente através de encomendas e envia todas as bolas por SEDEX. Como as bolas têm tamanhos diferentes, a SBC tem vários tamanhos de caixas diferentes para transportá-las.\nTarefa Escreva um programa que, dado o diâmetro de uma bola e as 3 dimensões de uma caixa (altura, largura e profundidade), diz se a bola de boliche cabe dentro da caixa ou não.\nEntrada\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 10.000) que indica o diâmetro da bola de boliche. A segunda linha da entrada contém 3 números inteiros separados por um espaço cada: a altura A (1 ≤ A ≤ 10.000), seguida da largura L (1 ≤ L ≤ 10.000) e da profundidade P (1 ≤ P ≤ 10.000).\nSaída\nSeu programa deve imprimir uma única linha, contendo a letra ‘S’ caso a bola de boliche caiba dentro da caixa ou ‘N’ caso contrário.\nExemplos",
    "examples": [
      [
        "3\n2 3 5",
        "N"
      ],
      [
        "5\n5 5 5",
        "S"
      ],
      [
        "9\n15 9 10",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sedex"
    },
    "imagesQuant": 0
  },
  {
    "name": "Conta de água",
    "description": "A empresa local de abastecimento de água, a Saneamento Básico da Cidade (SBC), está promovendo uma campanha de conservação de água, distribuindo cartilhas e promovendo ações demonstrando a importância da água para a vida e para o meio ambiente.\nPara incentivar mais ainda a economia de água, a SBC alterou os preços de seu fornecimento de forma que, proporcionalmente, aqueles clientes que consumirem menos água paguem menos pelo metro cúbico. Todo cliente paga mensalmente uma assinatura de R$ 7, que inclui uma franquia de 10 m3 de água. Isto é, para qualquer consumo entre 0 e 10 m3, o consumidor paga a mesma quantia de R$ 7 reais (note que o valor da assinatura deve ser pago mesmo que o consumidor não tenha consumido água). Acima de 10 m3, cada metro cúbico subsequente tem um valor diferente, dependendo da faixa de consumo. A SBC cobra apenas por quantidades inteiras de metros cúbicos consumidos. A tabela abaixo especifica o preço por metro cúbico para cada faixa de consumo: Faixa de consumo (m3) Preço (por m3) até 10 incluído na franquia 11 a 30 R$ 1 31 a 100 R$ 2 101 em diante R$ 5 Assim, por exemplo, se o consumo foi de 120 m3, o valor da conta é: • 7 reais da assinatura básica; • 20 reais pelo consumo no intervalo 11 – 30 m3; • 140 reais pelo consumo no intervalo 31 – 100 m3; • 100 reais pelo consumo no intervalo 101 – 120 m3.\nLogo o valor total da conta de água é R$ 267.\nTarefa Escreva um programa que, dado o consumo de uma residência em m3, calcula o valor da conta de água daquela residência.\nEntrada\nA única linha da entrada contém um único inteiro N, indicando o consumo de água da residência, em m3 (0 ≤ N ≤ 103).\nSaída\nSeu programa deve imprimir uma única linha, contendo o valor da conta de água daquela residência.\nExemplos",
    "examples": [
      [
        "8",
        "7"
      ],
      [
        "14",
        "11"
      ],
      [
        "42",
        "51"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "conta"
    },
    "imagesQuant": 0
  },
  {
    "name": "Copa do Mundo",
    "description": "Este ano tem Copa do Mundo! O país inteiro se prepara para torcer para a equipe canarinho conquistar mais um título, tornando-se hexacampeã.\nNa Copa do Mundo, depois de uma fase de grupos, dezesseis equipes disputam a Fase Final, composta de quinze jogos eliminatórios. A figura abaixo mostra a tabela de jogos da Fase Final: A B C D E F G H I J K L M N O P Oitavas-de-final 1 2 3 4 5 6 7 8 Quartas-de-final 9 10 11 12 Semifinais 13 14 Final 15 Campeão Na tabela de jogos, as dezesseis equipes finalistas são representadas por letras maiúsculas (de A a P), e os jogos são numerados de 1 a 15. Por exemplo, o jogo 3 é entre as equipes identificadas por E e F; o vencedor desse jogo enfrentará o vencedor do jogo 4, e o perdedor será eliminado. A equipe que vencer os quatro jogos da Fase Final será a campeã (por exemplo, para a equipe K ser campeã ela deve vencer os jogos 6, 11, 14 e 15.\nTarefa Dados os resultados dos quinze jogos da Fase Final, escreva um programa que determine a equipe campeã.\nEntrada\nA entrada é composta de quinze linhas, cada uma contendo o resultado de um jogo. A primeira linha contém o resultado do jogo de número 1, a segunda linha o resultado do jogo de número 2, e assim por diante. O resultado de um jogo é representado por dois números inteiros M e N separados por um espaço em branco, indicando respectivamente o número de gols da equipe representada à esquerda e à direita na tabela de jogos (0 ≤ M ≤ 20, 0 ≤ N ≤ 20 e M 6= N).\nSaída\nSeu programa deve imprimir uma única linha, contendo a letra identificadora da equipe campeã.\nExemplos",
    "examples": [
      [
        "4 1\n1 0\n0 4\n3 1\n2 3\n1 2\n2 0\n0 2\n1 2\n4 3\n0 1\n3 2\n3 4\n1 4\n1 0",
        "F"
      ],
      [
        "2 0\n1 0\n2 1\n1 0\n1 0\n1 2\n1 2\n1 0\n2 1\n1 0\n0 1\n0 2\n2 1\n1 0\n2 1",
        "A"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "copa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pedágio",
    "description": "A invenção do carro tornou muito mais rápido e mais barato realizar viagens de longa distância. Realizar uma viagem rodoviária tem dois tipos de custos: cada quilômetro percorrido na rodovia tem um custo associado (não só devido ao consumo de combustível mas também devido ao desgaste das peças do carro, pneus, etc.), mas também é necessário passar por vários pedágios localizados ao longo da rodovia.\nOs pedágios são igualmente espaçados ao logo da rodovia; o começo da estrada não possui um pedágio, mas o seu final pode estar logo após um pedágio (por exemplo, se a distância entre dois pedágios consecutivos for de 37 km e a estrada tiver 111 km, o motorista deve pagar um pedágio aos 37 km, aos 74 km e aos 111 km, logo antes de terminar a sua viagem).\nTarefa Dadas as características da rodovia e os custos com gasolina e com pedágios, calcule o custo total da viagem.\nEntrada\nA entrada consiste de duas linhas. A primeira linha da entrada contém dois inteiros L e D (1 ≤ L,D ≤ 104), indicando o comprimento da estrada e a distância entre pedágios, respectivamente. A segunda linha contém dois inteiros K e P (1 ≤ K,P ≤ 104), indicando o custo por quilômetro percorrido e o valor de cada pedágio.\nO primeiro pedágio está localizado no quilômetro D da estrada (ou seja, a distância do início da estrada para o primeiro pedágio é D quilômetros).\nSaída\nSeu programa deve imprimir uma única linha contendo um único inteiro, indicando o custo total da viagem.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, L,D,K,P ≤ 100.\nExemplos",
    "examples": [
      [
        "111 37\n1 10",
        "141"
      ],
      [
        "100 30\n3 14",
        "342"
      ],
      [
        "20 70\n9 17",
        "180"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pedagio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Times",
    "description": "As aulas de educação física, em muitas escolas, acontecem da seguinte maneira: O professor entrega uma bola ao alunos (geralmente de futebol) e estes se dividem em times, onde jogam partidas alternadamente.\nA maneira como os times são escolhidos também é semelhante em todas as escolas: decide-se quantos times serão formados, e uma pessoa para montar cada um dos times. Cada pessoa vai escolher, alternadamente, um dos alunos restantes para fazer parte de sua equipe. Como todos querem ter uma boa equipe, a pessoa que vai escolher o próximo membro do time escolhe aquele, dentre os ainda disponíveis, que possui o melhor nível de habilidade. Assim, os times acabam ficando relativamente equilibrados na soma do nível de habilidade dos jogadores.\nTarefa Dada uma lista de alunos que serão escolhidos e seus respectivos níveis de habilidade para os times e a quantidade de times que serão formados, mostre como ficarão os times ao final do processo de montagem dos mesmos.\nEntrada\nA primeira linha da entrada contém dois inteiros N (2 ≤ N ≤ 10.000) e T (2 ≤ T ≤ 1000), representando respectivamente a quantidade de alunos e o número de times a serem formados, sendo T ≤ N. As N linhas seguintes descrevem, cada uma, um aluno disponível para escolha de times. Cada uma dessas linhas possui o nome do aluno (composto apenas por letras minúsculas) e um inteiro H (0 ≤ H ≤ 1.000.000) descrevendo seu nível de habilidade).\nNão existem dois alunos com o mesmo nível de habilidade, e todos eles possuem nomes diferentes. É possível que alguns times acabem ficando com menos jogadores do que os outros.\nSaída\nSeu programa deve imprimir a lista de times que será formada ao final do processo de seleção. Para cada time, você deverá mostrar o termo “Time N”, onde N é o número do time (1 para o primero, 2 para o segundo, e assim por diante) seguido de K linhas, onde K é a quantidade de jogadores do time, mostrando o nome de cada um dos jogadores do time, em ordem alfabética. Imprima uma linha em branco após cada descrição de time (inclusive do último).\nOs times serão escolhidos pelo computador, então não é necessário considerar o aluno que irá fazer a escolha dos times.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, 2 ≤ N ≤ 10, 2 ≤ T ≤ 5.\nExemplos",
    "examples": [
      [
        "14 3\nfelipe 4\nalvaro 8\nthiago 1\nrodrigo 3\nrobson 2\nfabio 9\nricardo 11\nrodolfo 0\nandre 14\narthur 12\nronaldo 55\nrogerio 30\nlucas 7\nrafael 17",
        "Time 1\nandre\nfabio\nfelipe\nronaldo\nthiago\nTime 2\nalvaro\narthur\nrodolfo\nrodrigo\nrogerio\nTime 3\nlucas\nrafael\nricardo\nrobson"
      ],
      [
        "4 3\njohn 3\nrichard 0\ngreg 100\nrupert 20",
        "Time 1\ngreg\nrichard\nTime 2\nrupert\nTime 3\njohn"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "times"
    },
    "imagesQuant": 0
  },
  {
    "name": "Batalha Naval",
    "description": "Pedro e Paulo gostam muito de jogar batalha naval; apesar de serem grandes amigos, Pedro desconfia que Paulo não esteja jogando honestamente. Para tirar essa dúvida, Pedro decidiu usar um programa de computador para verificar o resultado do jogo, mas Pedro não sabe programar e por isso pediu a sua ajuda.\nO jogo de batalha naval é jogado em um tabuleiro retangular com N linhas e M colunas. Cada posição deste tabuleiro é um quadrado que pode conter água ou uma parte de um navio. Dizemos que dois quadrados são vizinhos se estes possuem um lado em comum. Se duas partes de navio estão em posições vizinhas, então essas duas partes pertencem ao mesmo navio. A regra do jogo proíbe que os quadrados de duas partes de navios distintos tenham um canto em comum (em outras palavras, que quadrados de duas partes de navios distintos compartilhem um vértice).\nCada disparo que um jogador faz deve ser feito em um dos quadrados do tabuleiro do outro jogador. Um jogador informa ao outro a coluna e a linha do quadrado alvo do disparo. Para que um navio seja destruído, o jogador deve acertar todas as partes deste navio. O jogador não pode atirar no mesmo lugar mais de uma vez.\nTarefa Escreva um programa que, dadas a configuração do tabuleiro e uma sequência de disparos feitos por um jogador, determina o número de navios do outro jogador que foram destruídos.\nEntrada\nA primeira linha da entrada contém números dois inteiros N e M (1 ≤ N ≤ 100 e M ≤ 100) representando respectivamente o número de linhas e de colunas do tabuleiro. As N seguintes linhas correspondem ao tabuleiro do jogo. Cada uma dessas linhas contém M caracteres. Cada caractere indica o conteúdo da posição correspondente no tabuleiro. Se esse caractere for ‘.’, essa posição contém água; se for ‘#’, essa posição contém uma parte de um navio. A próxima linha contém um número K que é o número de disparos feitos pelo jogador (1 ≤ K ≤ N × M). As próximas K linhas indicam os disparos feitos pelo jogador. Cada linha contém dois inteiros L e C, indicando a linha e a coluna do disparo feito pelo outro jogador (1 ≤ L ≤ N e 1 ≤ C ≤ M).\nSaída\nSeu programa deve imprimir uma única linha contendo um único número inteiro, o número de navios destruídos.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, os navios são todos compostos por exatamente uma parte (ou seja, um quadrado).\n• Em um conjunto de casos de teste que totaliza 50 pontos, cada navio está contido em exatamente uma linha.\nExemplos",
    "examples": [
      [
        "5 5\n..#.#\n#....\n...#.\n#....\n...#.\n5\n1 3\n1 4\n1 5\n2 1\n3 4",
        "4"
      ],
      [
        "5 5\n..###\n.....\n#####\n.....\n#.##.\n5\n5 1\n5 2\n1 3\n1 4\n1 5",
        "2"
      ],
      [
        "7 7\n.#....#\n###..##\n.#....#\n....#.#\n.#..#.#\n.####.#\n.......\n8\n1 1\n1 2\n2 1\n2 2\n2 3\n3 2\n5 2\n6 2",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "batalha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cometa",
    "description": "O cometa Halley é um dos cometas de menor período do Sistema Solar, completando uma volta em torno do Sol a cada 76 anos; na última ocasião em que ele tornou-se visível do planeta Terra, em 1986, várias agências espaciais enviaram sondas para coletar amostras de sua cauda e assim confirmar teorias sobre suas composições químicas.\nTarefa Escreva um programa que, dado o ano atual, determina qual o próximo ano em que o cometa Halley será visível novamente do planeta Terra. Se o ano atual é um ano de passagem do cometa, considere que o cometa já passou nesse ano (ou seja, considere sempre o próximo ano de passagem, não considerando o ano atual).\nEntrada\nA única linha da entrada contém um único inteiro A (2010 ≤ A ≤ 104), indicando o ano atual.\nSaída\nSeu programa deve imprimir uma única linha, contendo um número inteiro, indicando o próximo ano em que o cometa Halley será visível novamente do planeta Terra.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 20 pontos, A ≤ 2400.\nExemplos",
    "examples": [
      [
        "2010",
        "2062"
      ],
      [
        "10000",
        "10042"
      ],
      [
        "2062",
        "2138"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cometa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Elevador",
    "description": "A Subindo Bem Confortavelmente (SBC) é uma empresa tradicional, com mais de 50 anos de experiência na fabricação de elevadores. Todos os projetos da SBC seguem as mais estritas normas de segurança, mas infelizmente uma série de acidentes com seus elevadores manchou a reputação da empresa.\nAo estudar os acidentes, os engenheiros da companhia concluíram que, em vários casos, o acidente foi causado pelo excesso de passageiros no elevador. Por isso, a SBC decidiu fiscalizar com mais rigor o uso de seus elevadores: foi instalado um sensor em cada porta que detecta a quantidade de pessoas que saem e entram em cada andar do elevador.\nA SBC tem os registros do sensor de todo um dia de funcionamento do elevador (que sempre começa vazio).\nEles sabem que as pessoas são educadas e sempre deixam todos os passageiros que irão sair em um andar saírem antes de outros passageiros entrarem no elevador, mas ainda assim eles têm tido dificuldade em decidir se a capacidade máxima do elevador foi excedida ou não.\nTarefa Escreva um programa que, dada uma sequência de leituras do sensor e a capacidade máxima do elevador, determina se a capacidade máxima do elevador foi excedida em algum momento.\nEntrada\nA primeira linha da entrada contém dois inteiros N e C, indicando o número de leituras realizadas pelo sensor e a capacidade máxima do elevador, respectivamente (1 ≤ N ≤ 1000 e 1 ≤ C ≤ 1000). As N linhas seguintes contêm, cada uma, uma leitura do sensor. Cada uma dessas linhas contém dois inteiros S e E, indicando quantas pessoas saíram e quantas pessoas entraram naquele andar, respectivamente (0 ≤ S ≤ 1000 e 0 ≤ E ≤ 1000).\nSaída\nSeu programa deve imprimir uma única linha contendo o caractere ‘S’, caso a capacidade do elevador tenha sido excedida em algum momento, ou o caractere ‘N’ caso contrário.\nExemplos",
    "examples": [
      [
        "5 10\n0 5\n2 7\n3 3\n5 2\n7 0",
        "N"
      ],
      [
        "5 10\n0 3\n0 5\n0 2\n3 4\n6 4",
        "S"
      ],
      [
        "6 4\n0 5\n3 5\n4 5\n1 0\n1 1\n1 1",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "elevador"
    },
    "imagesQuant": 0
  },
  {
    "name": "Reunião",
    "description": "Todos os anos, a SBC (Sociedade Brasileira de Caminhoneiros) reúne seus membros em alguma cidade para discutir sobre a profissão. Nessas reuniões são discutidos os problemas da categoria e são apresentadas sugestões sobre como melhorar as condições de trabalho.\nO grande problema desse tipo de encontro é que os membros estão espalhados pelo país, uma vez que a profissão exige que eles viajem para diversos lugares todos os dias. Por isso, a escolha da cidade onde será feita a reunião sempre é feita de modo que não prejudique demais nenhum dos caminhoneiros. O critério para tal é que a maior das distâncias percorridas pelos caminhoneiros para chegar ao local da reunião deve ser a menor possível. Ou seja, a distância percorrida pelo caminhoneiro que vai percorrer a maior distância entre todos os caminhoneiros para chegar à reunião deve ser a menor possível.\nTarefa Dadas as cidades onde se encontram os caminhoneiros e a descrição das estradas que interligam essas cidades, escreva um programa que determina qual será a menor distância máxima percorrida por um caminhoneiro para chegar até o local da reunião. Os caminhoneiros conhecem bem as estradas, e portando sempre fazem o menor caminho possível até a cidade da reunião. Sempre existe um caminho ligando quaisquer duas cidades.\nEntrada\nA primeira linha da entrada possui dois números inteiros N (2 ≤ N ≤ 100) e M (N − 1 ≤ M ≤ 10000), que representam, respectivamente, o número de cidades e o número de estradas que as interligam. As cidades são identificadas por números inteiros entre 0 e N − 1. As próximas M linhas da entrada possuem, cada uma, a descrição de uma estrada. Cada descrição de entrada é composta por três números inteiros: U, V e W, onde U e V representam cidades (0 ≤ U ≤ N −1 e 0 ≤ V ≤ N −1) e W representa o comprimento da estrada que une essas duas cidades (todas as estradas são mão dupla, 1 ≤ W ≤ 100). É sempre possível viajar entre qualquer duas cidades com as estradas existentes, mas pode haver mais de uma estrada ligando o mesmo par de cidades.\nSaída\nSeu programa deve imprimir uma única linha contendo um número inteiro, a distância máxima percorrida por um caminhoneiro para ir até a reunião, obedecidas as restrições estabelecidas (ou seja, essa distância máxima deve ser a menor possível).\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 4.\nExemplos",
    "examples": [
      [
        "4 4\n0 1 2\n0 2 4\n1 3 1\n2 3 5",
        "4"
      ],
      [
        "4 5\n0 1 2\n0 2 4\n1 3 1\n2 3 5\n3 2 2",
        "3"
      ],
      [
        "7 12\n0 1 22\n0 2 30\n0 5 35\n1 5 11\n1 6 30\n1 2 25\n2 3 15\n2 6 10\n3 4 15\n3 5 10\n4 5 20\n5 6 33",
        "30"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "reuniao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dentista",
    "description": "Os dentistas são extremamente meticulosos em seu trabalho, tendo que agir com muita precisão em todas as suas atividades. Pedro é um dentista meticuloso como todos os outros. Infelizmente sua secretária não é muito organizada e, com o intuito de ajudar sempre os pacientes, aceita que eles marquem consultas no horário que quiserem, sem se preocupar com os demais horários marcados, ocasionando vários conflitos de horários que muito incomodaram Pedro e os pacientes. Por exemplo, se uma consulta começar às 9 horas e durar 2 horas, nenhuma outra consulta deveria ser marcada para iniciar as 10 horas.\nAo perceber que sua agenda tinha conflito de horários, Pedro pediu sua ajuda para descobrir a maior quantidade de consultas que podem ser atendidas sem sobreposição.\nTarefa Você deve escrever um programa que, dados os horários de início e término das consultas agendadas pela secretária, responda a quantidade máxima de consultas que podem ser atenditas sem sobreposição.\nEntrada\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 10.000) que indica quantas consultas a secretária marcou. Cada uma das N linhas seguintes contém um par de inteiros X e Y separados por um espaço em branco (0 ≤ X < Y ≤ 1.000.000) que representam, respectivamente, o horário de início e de término da consulta. Considere que se uma consulta inicia no exato instante em que outra termina não há sobreposição. Os horários de início são fornecidos em ordem, podendo haver mais de uma consulta que inicie no mesmo horário.\nSaída\nSeu programa deve imprimir uma única linha, contendo um inteiro que representa a quantidade máxima de consultas que podem ser atendidas sem que haja qualquer sobreposição.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, (0 ≤ X < Y ≤ 1.000).\nExemplos",
    "examples": [
      [
        "3\n10 100\n40 130\n120 200",
        "2"
      ],
      [
        "4\n10 20\n20 30\n30 40\n40 50",
        "4"
      ],
      [
        "5\n10 30\n20 40\n30 60\n40 80\n60 100",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "dentista"
    },
    "imagesQuant": 0
  },
  {
    "name": "Escada Rolante",
    "description": "O Shopping Boas Compras – SBC, através de sua política ambiental, está preocupado com o consumo de energia e, resolveu trocar todas as escadas rolantes por modelos mais modernos, que se desligam caso ninguém esteja utilizando, poupando energia.\nA nova escada rolante possui um sensor no início. Toda vez que ela está vazia e alguém passa pelo sensor, a escada começa a funcionar, parando de funcionar novamente após 10 segundos se ninguém mais passar pelo sensor. Estes 10 segundos representam o tempo suficiente para levar alguém de um nível ao outro.\nPreocupados em saber exatamente quanto de energia o shopping está economizando, o gerente pediu sua ajuda.\nComo eles sabem qual era o consumo da escada rolante antiga, eles te pediram para calcular o tempo que a nova escada ficou funcionando.\nTarefa Dados os instantes, em segundos, em que passaram pessoas pela escada rolante, você deve calcular quantos segundos ela ficou ligada.\nEntrada\nA primeira linha da entrada contém um inteiro N que indica o número de pessoas que o sensor detectou (1 ≤ N ≤ 1.000). As N linhas seguintes representam o instante em que a i-ésima pessoa passou pelo sensor e contém um inteiro T (0 ≤ T ≤ 10.000). Os tempos estão em ordem crescente, sem repetições.\nSaída\nSeu programa deve imprimir uma única linha, contendo o tempo que a escada rolante ficou ligada.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, a primeira pessoa passa pelo sensor no tempo 0.\nExemplos",
    "examples": [
      [
        "3\n0\n10\n20",
        "30"
      ],
      [
        "5\n5\n10\n17\n20\n30",
        "35"
      ],
      [
        "3\n1\n2\n3",
        "12"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "escada"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tacógrafo",
    "description": "Tacógrafos são dispositivos instalados em determinados tipos de veículos, que registram a velocidade, tempo e distância percorrida por tal veículo. É utilizada principalmente em veículos de transporte coletivo e de transporte de cargas, assim ajudando a evitar abusos de velocidade por parte dos motoristas.\nA empresa SBC (Sociedade Brasileira dos Caminhoneiros) decidiu encomendar uma versão um pouco mais básica (e barata) para seus associados não precisarem gastar tanto na instalação desses aparelhos. Essas versões modificadas registram apenas os intervalos de tempo e as velocidades médias do caminhão naqueles intervalos.\nTarefa Apesar das restrições dos aparelhos novos, a SBC quer poder saber qual foi a distância percorrida pelos caminhões. Você deverá escrever um programa que recebe uma série de intervalos de tempo com suas respectivas velocidades médias e calcula qual foi a distância total percorrida pelo caminhão de acordo com o tacógrafo.\nEntrada\nA primeira linha da entrada contém um inteiro N (1 ≤ N ≤ 1000) representando a quantidade de intervalos de tempo registrados no tacógrafo. As N linhas seguintes descrevem os intervalos de tempo. Cada uma dessas linhas possui dois inteiros T e V (1 ≤ T ≤ 100, 0 ≤ V ≤ 120), que representam, respectivamente o tempo decorrido (em horas) e a velocidade média (em quilômetros por hora) no intervalo de tempo.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único número inteiro representando a distância total percorrida, em quilômetros.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 20 pontos, N ≤ 10.\nExemplos",
    "examples": [
      [
        "3\n10 0\n55 12\n75 120",
        "9660"
      ],
      [
        "10\n45 46\n46 101\n7 2\n95 104\n12 107\n78 29\n10 26\n52 86\n13 79\n1 107",
        "26022"
      ],
      [
        "8\n37 24\n68 69\n28 26\n79 8\n36 0\n50 71\n13 68\n87 113",
        "21205"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tacografo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Lista de Chamada",
    "description": "Tia Joana é uma respeitada professora e tem vários alunos. Em sua última aula, ela prometeu que iria sortear um aluno para ganhar um bônus especial na nota final: ela colocou N pedaços de papel numerados de 1 a N em um saquinho e sorteou um determinado número K; o aluno premiado foi o K-ésimo aluno na lista de chamada.\nO problema é que a Tia Joana esqueceu o diário de classe, então ela não tem como saber qual número corresponde a qual aluno. Ela sabe os nomes de todos os alunos, e que os números deles, de 1 até N, são atribuídos de acordo com a ordem alfabética, mas os alunos dela estão muito ansiosos e querem logo saber quem foi o vencedor.\nTarefa Dado os nomes dos alunos da Tia Joana e o número sorteado, determine o nome do aluno que deve receber o bônus.\nEntrada\nA primeira linha contém dois inteiros N e K separados por um espaço em branco (1 ≤ K ≤ N ≤ 100). Cada uma das N linhas seguintes contém uma cadeia de caracteres de tamanho mínimo 1 e máximo 20 representando os nomes dos alunos. Os nomes são compostos apenas por letras minúsculas de ‘a’ a ‘z’.\nSaída\nSeu programa deve imprimir uma única linha, contendo o nome do aluno que deve receber o bônus.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 3.\nExemplos",
    "examples": [
      [
        "5 1\nmaria\njoao\ncarlos\nvanessa\njose",
        "carlos"
      ],
      [
        "5 5\nmaria\njoao\ncarlos\nvanessa\njose",
        "vanessa"
      ],
      [
        "5 3\nmaria\njoao\ncarlos\nvanessa\njose",
        "jose"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chamada"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dança Indígena",
    "description": "A OBI (Organização Brasileira dos Índios) promoverá um festival indígena, onde várias tribos irão se reunir e fazer demonstrações de cultura, como artesanato, danças, pinturas, comidas e etc.\nUma das tribos é a dos Tunak Tunak, que possuem uma apresentação de dança muito peculiar. Nessa dança, existem N toras de madeira encrustadas no chão, dispostas de maneira circular e igualmente espaçadas. Em algumas dessas toras fica um índio, olhando em sentido horário ou anti-horário.\nA cada batida do tambor, os índios pulam para a próxima tora (que depende da direção para onde ele está olhando no momento). Durante a dança, porém, algumas coisas podem acontecer: • Dois índios que pulam em sentidos opostos caem na mesma tora ao mesmo tempo.\nNesse caso, ambos permanecem nas toras, mas passam a pular na direção contrária a partir da próxima batida de tambor (isso é, quem estava pulando em sentido horário passa a pular em sentido anti-horário, e vice-versa) • Dois índios em toras consecutivas vão pular um em direção ao outro.\nNesse caso, os índios simplesmente não pulam (para não causar nenhum acidente), e, assim como no caso anterior, passam a pular no sentido contrário a partir da próxima batida de tambor.\nNote que se o índio não pula e inverte seu sentido, mas ao mesmo tempo um outro índio cair na mesma tora no sentido contrário, caimos no primeiro caso, e ambos os índios na tora invertem seus sentidos (assim, o índio que estava na tora anteriormente inverte seu sentido novamente).\nA dança termina quando as toras ocupadas por um índio são exatamente as mesmas toras ocupadas no início da dança, não importando qual índio está em cada tora e nem os sentidos para onde eles estão pulando.\nA figura abaixo ilustra (a) uma configuração inicial com oito toras e seis índios; (b) a posição dos índios após uma batida de tambor; e (c) a posição dos índios após duas batidas de tambor.\n8 1 2 8 1 2 8 1 2 7 3 7 3 7 3 6 4 6 4 6 4 5 5 5 (a) (b) (c) Tarefa Os índios querem se preparar para a dança e precisam saber quanto tempo ela vai durar.\nPara isso, você deverá escrever um programa que, dados a quantidade de toras que serão utilizadas, a quantidade de índios e a posição inicial de cada um, calcule quantas batidas de tambor levará para que a dança termine.\nEntrada\nA primeira linha da entrada possui 2 inteiros: N (3 ≤ N ≤ 1.000.000) e E (1 ≤ E ≤ 1000), que são, respectivamente, a quantidade de toras e a quantidade de índios que irão dançar (E ≤ N). As próximas E linhas contém, cada uma, a descrição da posição inicial de cada índio. Cada linha possui dois inteiros: V (1 ≤ V ≤ N) e D (D = 1 ou D = −1) que representam, respectivamente, o número da tora onde o índio inicia e seu sentido inicial (1 se horário, −1 se anti-horário). A numeração das toras obedece o sentido horário. No início da dança uma tora terá, no máximo, um índio.\nSaída\nSeu programa deverá exibir um número inteiro representando a quantidade de batidas de tambor necessárias para que a dança acabe.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, N ≤ 100 e E ≤ 100.\nExemplos",
    "examples": [
      [
        "6 4\n2 1\n3 1\n5 1\n6 1",
        "3"
      ],
      [
        "3 1\n2 -1",
        "3"
      ],
      [
        "8 6\n2 -1\n3 1\n4 -1\n6 1\n7 -1\n8 1",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "danca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fusões",
    "description": "A informatização dos sistemas bancários permitiu grandes economias de tempo e dinheiro, permitindo que vários tipos de transações financeiras pudessem ser realizadas pela Internet. Para possibilitar isso, cada banco recebeu um código bancário, que é um número utilizado pelos sistemas de computador para identificar cada banco.\nQuando um banco decide comprar outro, ocorre o que se chama uma fusão: os dois bancos tornam-se um só banco. Para manter compatibilidade com os sistemas eletrônicos dos bancos, qualquer um dos códigos dos antigos bancos pode ser usado para se referir ao novo banco.\nCom a crise econômica internacional, as fusões entre bancos têm sido cada vez mais comuns; por isso, muitas vezes é difícil decidir se dois códigos bancários na realidade se referem ao mesmo banco (devido aos dois bancos terem se fundido, diretamente ou não).\nTarefa Escreva um programa que, dada uma série de fusões entre bancos, responde a várias consultas perguntando se dois códigos bancários se referem ao mesmo banco.\nEntrada\nA primeira linha da entrada contém dois inteiros N e K, indicando o número de bancos e o número de operações efetuadas (1 ≤ N ≤ 100.000, 1 ≤ K ≤ 100.000). Os códigos de cada um dos N bancos, inicialmente, são os inteiros de 1 até N.\nCada uma das K linhas seguintes descreve ou uma fusão entre bancos ou uma consulta.\n• Uma fusão é descrita na entrada como uma linha que começa com o caractere ‘F’, um espaço, e dois códigos bancários, que se referem aos dois bancos que estão sofrendo a fusão, separados por um espaço em branco; • Uma consulta é descrita na entrada como uma linha que começa com o caractere ‘C’, um espaço, e os dois códigos a serem consultados, separados por um espaço em branco. Os códigos bancários consultados são sempre distintos.\nAs fusões são sempre realizadas entre bancos diferentes, e todos os códigos bancários fornecidos na entrada são válidos.\nSaída\nSeu programa deve imprimir uma linha para cada consulta na entrada. Caso os dois códigos bancários consultados se refiram ao mesmo banco, imprima uma linha contendo o caractere ‘S’; caso contrário, imprima uma linha contendo apenas o caractere ‘N’.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, N ≤ 100 e K ≤ 100.\nExemplos",
    "examples": [
      [
        "3 5\nC 1 2\nF 1 2\nC 1 2\nF 1 3\nC 1 3",
        "N\nS\nS"
      ],
      [
        "4 5\nF 1 2\nF 2 3\nC 1 3\nF 2 4\nC 1 4",
        "S\nS"
      ],
      [
        "4 4\nF 1 2\nF 3 4\nF 1 3\nC 2 4",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fusoes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sedex Marciano",
    "description": "Estamos no ano 2048 e um dos sonhos da humanidade torna-se finalmente realidade: a colonização do planeta Marte. Nossos primeiros colonizadores acabam de chegar, e já começam a fazer as preparações (como a instalação de cúpulas de oxigênio e tratamento do solo para agricultura) para que mais pessoas possam tentar uma nova vida no planeta vizinho.\nApesar dos avanços tecnológicos e desafios vencidos, ainda resta um grande problema: os foguetes usados para ir a Marte ainda são complicados e caros. Com isso, fica difícil enviar suprimentos para os nossos colonos (enquanto a agricultura ainda não é possível) por muito tempo. Assim, a agência espacial contratou o SBC (Serviço Balístico Cósmico), que desenvolveu um canhão super-potente que consegue disparar esferas até Marte, sem precisar gastar milhões de dólares em equipamento e combustível.\nAgora, tudo o que é necessário fazer para enviar suprimentos a Marte é colocar uma caixa com as encomendas dentro de uma esfera e disparar a mesma até seu destino.\nTarefa Dadas as dimensões de uma caixa com suprimentos e o raio interno da esfera que é disparada pelo canhão, seu programa deverá dizer se é possível enviar tal caixa para Marte usando tal esfera.\nEntrada\nCada entrada contém apenas uma linha com quatro inteiros L, A, P e R, (0 ≤ L,A,P,R ≤ 1000) que representam, respectivamente, a largura, altura e profundidade da caixa, e o raio da esfera.\nSaída\nSeu programa deve imprimir um único caractere: ‘S’ (sem aspas) se é possível colocar a caixa dentro da esfera, ou ‘N’ (sem aspas) caso contrário.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 20 pontos, 0 ≤ L,A,P,R ≤ 20.\nExemplos",
    "examples": [
      [
        "10 20 30 30",
        "S"
      ],
      [
        "10 10 10 7",
        "N"
      ],
      [
        "2 4 4 3",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "marciano"
    },
    "imagesQuant": 0
  },
  {
    "name": "Altas Aventuras",
    "description": "Incentivado por um filme de animação recente, vovô resolveu realizar seu sonho de criança, fazendo sua pequena casa voar amarrada a balões de hélio. Comprou alguns balões coloridos de boa qualidade, para fazer alguns testes, e começou a planejar a grande aventura. A primeira tarefa é determinar qual a quantidade de hélio máxima que pode ser injetada em cada balão de maneira que ele não estoure.\nSuponha que os valores possíveis de quantidade de hélio em cada balão variem entre os valores 1 e N. Claro que vovô poderia testar todas as possibilidades, mas esse tipo de solução ineficiente não é apropriada, ainda mais considerando que vovô comprou apenas K balões para os testes.\nPor exemplo, suponha que N = 5 e K = 2. Nesse caso, a melhor solução seria testar primeiro em 3. Caso o balão estoure, vovô só teria mais um balão, então teria de testar 1 e 2 no pior caso, somando ao todo 3 testes.\nCaso o balão não estoure, vovô poderia testar 4 e depois 5 (ou 5 e depois 4), também somando 3 ao todo.\nTarefa Dados a capacidade máxima da bomba e o número de balões, indicar o número mínimo de testes que devem ser feitos, no pior caso, para determinar o ponto em que um balão estoura.\nEntrada\nA única linha da entrada contém dois inteiros, N e K, separados por espaço em branco (1 ≤ K ≤ N ≤ 1.000.000.000).\nSaída\nSeu programa deve imprimir uma única linha, contendo um inteiro que representa o número mínimo de testes que devem ser feitos no pior caso para determinar o ponto em que o balão estoura.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, (1 ≤ K ≤ N ≤ 200).\nExemplos",
    "examples": [
      [
        "5 2",
        "3"
      ],
      [
        "20 2",
        "6"
      ],
      [
        "11 5",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "altas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Floresta",
    "description": "O desmatamento é um dos maiores problemas enfrentados pelo Brasil hoje; estima-se que mais de 10 mil km2 de vegetação sejam desflorestados todo ano. Além de destruir os habitats de várias espécies em risco de extinção, o desmatamento promove a emissão de gás carbônico, principal responsável pelo efeito estufa e pelo aquecimento global.\nA Fundação de Conservação dos Carvalhos (FCC) tenta combater esta tendência, promovendo o reflorestamento das regiões desmatadas. Para isso, eles pretendem plantar carvalhos formando um quadriculado (um carvalho em cada vértice); no centro de cada quadrado formado por eles, a FCC também plantará um eucalipto. Para preservar a biodiversidade da área plantada, pelo menos uma árvore de cada espécie deve ser plantada durante o reflorestamento.\nPor exemplo, se a FCC quiser plantar 23 árvores, ela poderá fazê-lo de duas maneiras: ou formando um retângulo 3 × 5 com os carvalhos, como na figura (a), ou formando um retângulo 2 × 8, como na figura (b).\nConsidere que, para os propósitos deste problema, um retângulo x × y é equivalente a um retângulo y × x.\n(a) (b) Tarefa Escreva um programa que, dado o número total de árvores que devem ser plantadas, de quantas maneiras diferentes elas podem ser dispostas.\nEntrada\nA única linha da entrada contém um único inteiro N, que indica o número total de árvores que devem ser plantadas (1 ≤ N ≤ 109).\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, indicando o número de arranjos distintos que podem ser feitos para o reflorestamento.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, N ≤ 10.000.\nExemplos",
    "examples": [
      [
        "23",
        "2"
      ],
      [
        "7",
        "0"
      ],
      [
        "53",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "floresta"
    },
    "imagesQuant": 0
  },
  {
    "name": "Multiplicação de matrizes",
    "description": "O conglomerado indiano Tutu é um conjunto de empresas que atua nos mais diversos ramos da indústria, produzindo desde sapatos até aviões e foguetes. Por ser tão diversificada, precisa de grandes e rápidos sistemas para cálculos de contabilidade.\nUm dos módulos mais importantes desse sistema é o de fornecimento de produtos, onde fica a base de dados de produtos e fornecedores. Um mesmo produto pode ser fornecido por vários fornecedores diferentes.\nO sistema possui duas grandes matrizes: a matriz A, onde cada linha representa um produto e cada coluna representa um fornecedor. O valor da matriz na linha m e coluna n representa o preço do produto m se for comprado do fornecedor n.\nA outra grande matriz é a B, onde cada linha representa um dia do mês e cada coluna é um produto. O valor da matriz na linha m e coluna n representa a quantidade do produto n a ser adquirido no dia m.\nTal empresa tem uma política de fidelidade com seus fornecedores, e uma das práticas efetuadas pela empresa é, em um determinado dia, comprar todos os produtos necessários de um único fornecedor. Isto é, em um dia todos os produtos adquiridos serao comprados do fornecedor x, no outro dia do fornecedor y, e assim por diante.\nPara auxiliar a escolha de qual fornecedor será o escolhido no dia, foi gerada outra matriz C, que é o resultado da multiplicação das matrizes A × B. Essa matriz diz o quanto será gasto pela empresa se adquirir todos os produtos de um determinado fornecedor em um determinado dia.\nAs matrizes A e B são quadradas (o número de linhas é igual ao número de colunas) e têm valores definidos pelas fórmulas Aij = (P × i + Q × j) (mod X) Bij = (R × i + S × j) (mod Y ) onde i é o índice da linha da matriz e j é o índice da coluna da matriz (todos os índices vão de 1 até N). Os inteiros P, Q, R, S, X e Y são parâmetros constantes, que definem as duas matrizes A e B.\nTarefa Escreva um programa que, dados os parâmetros das matrizes A e B, e a posição de uma das entradas as matriz C, calcula o valor daquela entrada.\nEntrada\nA primeira linha da entrada contém um inteiro N, indicando as dimensões das matrizes A, B e C (2 ≤ N ≤ 105). A linha seguinte contém seis inteiros P, Q, R, S, X e Y , indicando os parâmetros das matrizes A e B (2 ≤ X,Y ≤ 104; 0 ≤ P,Q < X; 0 ≤ R,S < Y ). Finalmente, a última linha da entrada contém dois inteiros I e J, indicando a linha e a coluna da matriz C a serem consultados (1 ≤ I,J ≤ N).\nSaída\nSeu programa deve imprimir uma única linha contendo o valor da matriz C na linha e coluna especificadas.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 40 pontos, N ≤ 100.\nExemplos",
    "examples": [
      [
        "3\n4 3 2 3 5 6\n2 2",
        "18"
      ],
      [
        "4\n3 5 1 0 6 7\n4 3",
        "30"
      ],
      [
        "2\n2 2 0 1 3 2\n2 1",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "matrizes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Telescópio",
    "description": "Telescópios são instrumentos que auxiliam a observação do céu, melhorando e aumentando o aspecto das estrelas, planetas e outros objetos brilhantes. Existem diversos tipos de telescópios, sendo os tipos mais comuns os de lentes objetivas (refratores) e os de espelhos (refletores).\nA maneira como os telescópios melhoram a nossa percepção dos astros no céu é aumentando a quantidade de luz captada que chega aos nossos olhos. Toda luz que entra pelos nossos olhos entra por um orifício chamado pupila. Tal controla a quantidade de luz que entra nos olhos, aumentando o diâmetro quando o ambiente está escuro (e portanto precisamos obter mais luz para identificar os objetos) e diminuindo quando o ambiente está claro. Num ambiente muito escuro, a pupila pode atingir um diâmetro de 8 mm.\nCada objeto celeste (estrela, planeta, nebulosa, etc) emite uma quantidade de luz (fótons) que é homogeneamente distribuída quando chega na Terra. Por exemplo, a estrela A emite luz que pode ser captada a um fluxo de 40.000 fótons por segundo por milímetro quadrado. Isso é, a cada segundo, é possível captar 40.000 fótons provenientes da estrela A numa área de 1 mm2. Ou seja, uma pupila de 10 mm2 de área captaria 400.000 fótons provenientes da estrela A por segundo.\nPara que nosso cérebro consiga interpretar que existe um objeto ali, porém, ele precisa receber 40.000.000 fótons por segundo. Assim, podemos utilizar um telescópio com lente (ou espelho) de 100 mm2 de área, que vai captar a quantidade necessária de fótons provenientes da estrela A e encaminhá-los até nossa pupila, fazendo assim com que nosso cérebro perceba a presença da estrela ali.\nTarefa Dada uma lista com estrelas no céu,o fluxo de fótons que cada uma delas emite, e área de abertura de um telescópio, dizer quantas estrelas serão perceptíveis usando tal telescópio.\nEntrada\nA primeira linha da entrada terá um inteiro A (1 ≤ A ≤ 10.000) representando a área de abertura do telescópio (em milímetros quadrados) a ser considerado. A segunda linha possui um inteiro N (1 ≤ N ≤ 10.000) representando o número de estrelas a serem estudadas. As N linhas seguintes terão, cada uma, um inteiro F (1 ≤ F ≤ 20.000) representando o fluxo de fótons que cada uma das N estrelas emitem (em fótons por segundo por milímetro quadrado).\nSaída\nImprima um inteiro representando a quantidade de estrelas que serão percebidas ao se utilizar o telescópio em questão.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 10 pontos, N ≤ 10.\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 100.\nExemplos",
    "examples": [
      [
        "10000\n3\n4000\n3500\n5100",
        "2"
      ],
      [
        "5869\n3\n3975\n14234\n8569",
        "2"
      ],
      [
        "2967\n9\n18650\n16338\n2400\n17702\n14619\n13934\n7979\n16316\n10533",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "telescopio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tradutor alienígena",
    "description": "É de conhecimento público e notório que já fomos visitados por alienígenas diversas vezes. A grande dificuldade que temos, porém, é a comunicação com eles, por causa de grandes diferenças entre as línguas. Além disso, assim como nós, eles também têm várias línguas diferentes.\nCom o intuito de auxiliar no processo de tradução, foi criado um método de mapeamento dos símbolos do alfabeto de cada língua alienígena, atribuindo um número inteiro para cada símbolo. Sendo assim, para um alfabeto alienígena com N elementos, atribui-se números de 1 a N a cada um.\nO problema é que o encarregado de transcrever os textos alienígenas para números não foi muito cuidadoso e usou o mesmo espaçamento entre dígitos e números. Assim, por exemplo, digamos que para um alfabeto com 32 símbolos, uma sequência que deveria ser “31 20 4 19” virou “3120419”. Como se pode notar, há diferentes maneiras válidas de interpretar essa sequência além da original, como por exemplo “3 1 20 4 19” e “31 20 4 1 9”. Repare que a transcrição nunca usa zeros à esquerda de um número e, portanto, a sequência “3 12 04 19” é inválida, assim como “31 20 41 9” por conter um número (49) que não corresponde a um símbolo.\nTarefa Dados a quantidade de símbolos do alfabeto e uma sequência transcrita, determine quantas sequências válidas podem ser formadas.\nEntrada\nA entrada é composta por duas linhas. A primeira contém um número inteiro N (1 < N < 10100) que indica a quantidade de símbolos do alfabeto. A segunda linha contém uma cadeia de dígitos de tamanho mínimo 1 e tamanho máximo 100.000 que corresponde a sequência transcrita.\nSaída\nSeu programa deve imprimir uma linha com o resto da divisão da quantidade de sequências válidas por 1.000.000.007.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, a cadeia de caracteres tem no máximo 20 dígitos e N < 100.\nExemplos",
    "examples": [
      [
        "32\n3120419",
        "4"
      ],
      [
        "32\n4021333251231253",
        "0"
      ],
      [
        "500\n12345",
        "13"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2010,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tradutor"
    },
    "imagesQuant": 0
  },
  {
    "name": "Campo Minado",
    "description": "campominado.py Leonardo Viana Ø um garoto fascinado por jogos de tabuleiro. Nas fØrias de janeiro, ele aprendeu um jogo chamado (cid:16)Campo minado(cid:17), que Ø jogado em um tabuleiro com N cØlulas dispostas na horizontal. O objetivo desse jogo Ø determinar, para cada cØlula do tabuleiro, o nœmero de minas explosivas nos arredores da mesma (que sªo a pr(cid:243)pria cØlula e as cØlulas imediatamente vizinhas (cid:224) direita e (cid:224) esquerda, caso essas existam). Por exemplo, a (cid:28)gura abaixo ilustra uma poss(cid:237)vel con(cid:28)gura(cid:231)ªo de um tabuleiro com 5 cØlulas: A primeira cØlula nªo possui nenhuma mina explosiva, mas Ø vizinha de uma cØlula que possui uma mina explosiva. Nos arredores da segunda cØlula temos duas minas, e o mesmo acontece para a terceira e quarta cØlulas; a quinta cØlula s(cid:243) tem uma mina explosiva em seus arredores. A pr(cid:243)xima (cid:28)gura ilustra a resposta para esse caso.\n  Leonardo sabe que vocŒ participa da OBI e resolveu lhe pedir para escrever um programa de computador que, dado um tabuleiro, imprima o nœmero de minas na vizinhan(cid:231)a de cada posi(cid:231)ªo. Assim, ele poderÆ conferir as centenas de tabuleiros que resolveu durante as fØrias.\nEntrada\nA primeira linha da entrada contØm um inteiro N indicando o nœmero de cØlulas no tabuleiro. O tabuleiro Ø dado nas pr(cid:243)ximas N linhas. A i-Øsima linha seguinte contØm 0 se nªo existe mina na i-Øsima cØlula do tabuleiro e 1 se existe uma mina na i-Øsima cØlula do tabuleiro.\nSa(cid:237)da A sa(cid:237)da Ø composta por N linhas. A i-Øsima linha da sa(cid:237)da contØm o nœmero de minas explosivas nos arredores da i-Øsima cØlula do tabuleiro.\nRestri(cid:231)ıes • 1 ≤ N ≤ 50 Exemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "5\n0\n1\n1\n0\n1",
        "Sa(cid:237)da\n1\n2\n2\n2\n1"
      ],
      [
        "5\n0\n1\n1\n1\n0",
        "Sa(cid:237)da\n1\n2\n3\n2\n1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "campominado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Corrida",
    "description": "A escola de Joªozinho tradicionalmente organiza uma corrida ao redor do prØdio. Como todos os alunos sªo convidados a participar e eles estudam em per(cid:237)odos diferentes, Ø dif(cid:237)cil que todos corram ao mesmo tempo.\nPara contornar esse problema, os professores cronometram o tempo que cada aluno demora para dar cada volta ao redor da escola, e depois comparam os tempos para descobrir a classi(cid:28)ca(cid:231)ªo (cid:28)nal.\nSua tarefa Ø, sabendo o nœmero de competidores, o nœmero de voltas de que consistiu a corrida e os tempos de cada aluno competidor, descobrir quem foi o aluno vencedor, para que ele possa receber uma medalha comemorativa.\nEntrada\nA primeira linha da entrada contØm dois inteiros N e M representando o nœmero de competidores e o nœmero de voltas da corrida, respectivamente.\nCada uma das N linhas seguintes representa um competidor: a primeira linha representa o primeiro competidor, a segunda linha representa o segundo competidor, e assim por diante. Cada linha contØm M inteiros representando os tempos em cada volta da corrida: o primeiro inteiro Ø o tempo da primeira volta, o segundo inteiro Ø o tempo da segunda volta, e assim por diante.\nGarante-se que nªo houve dois competidores que gastaram o mesmo tempo para completar a corrida inteira.\nSa(cid:237)da A sa(cid:237)da consiste de um œnico inteiro, que corresponde ao nœmero do competidor que ganhou a corrida.\nRestri(cid:231)ıes • 2 ≤ N ≤ 100 • 1 ≤ M ≤ 100 • 1 ≤ qualquer nœmero da entrada que represente o tempo de uma volta ≤ 106 Exemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Neste exemplo, existem trŒs competidores numa corrida de trŒs voltas. Os tempos de cada competidor em cada volta foram como na tabela a seguir.\n  Sendo assim, o vencedor foi o competidor 3 (com um tempo total de 3).",
    "examples": [
      [
        "2 1\n5\n7",
        "Sa(cid:237)da\n1"
      ],
      [
        "3 3\n3 5 6\n1 2 3\n1 1 1",
        "Sa(cid:237)da\n3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "corrida"
    },
    "imagesQuant": 0
  },
  {
    "name": "Transporte de ContŒineres",
    "description": "transporte.py A Betal(cid:226)ndia Ø um pa(cid:237)s que apenas recentemente se abriu para o comØrcio exterior e estÆ preparando agora sua primeira grande exporta(cid:231)ªo. A Sociedade Betalandesa de ComØrcio (SBC) (cid:28)cou encarregada de conduzir a exporta(cid:231)ªo e determinou que, seguindo os padrıes internacionais, a carga serÆ transportada em contŒineres, que sªo, por sua vez, colocados em grandes navios para o transporte internacional.\nTodos os contŒineres betalandeses sªo idŒnticos, medindo A metros de largura, B metros de comprimento e C metros de altura. Um navio porta-contŒineres pode ser visto como um ret(cid:226)ngulo horizontal de X metros de largura e Y metros de comprimento, sobre o qual os contŒineres sªo colocados. Nenhuma parte de contŒiner pode (cid:28)car para fora do navio. AlØm disso, para possibilitar a travessia de pontes, a altura mÆxima da carga no navio nªo pode ultrapassar Z metros.\n≤ Z C A X B Y Devido a limita(cid:231)ıes do guindaste utilizado, os contŒineres s(cid:243) podem ser carregados alinhados com o navio.\nOu seja, os contŒineres s(cid:243) podem ser colocados sobre o navio de tal forma que a largura e o comprimento do contŒiner estejam paralelos (cid:224) largura e ao comprimento do navio, respectivamente.\nA SBC estÆ com problemas para saber qual a quantidade mÆxima de contŒineres que podem ser colocados no navio e pede sua ajuda. Sua tarefa, neste problema, Ø determinar quantos contŒineres podem ser carregados no navio respeitando as restri(cid:231)ıes acima.\nEntrada\nA entrada consiste de duas linhas. A primeira linha contØm trŒs inteiros A, B e C que representam as dimensıes dos contŒineres, enquanto a segunda linha contØm outros trŒs inteiros X, Y e Z que representam as dimensıes do navio.\nSa(cid:237)da Seu programa deve imprimir apenas uma linha contendo um inteiro que indica a quantidade mÆxima de contŒineres que o navio consegue transportar.\nRestri(cid:231)ıes • 1 ≤ A,B,C,X,Y,Z ≤ 106 • (cid:201) garantido que a maior resposta serÆ menor ou igual a 106.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "1 1 1\n1 1 1",
        "Sa(cid:237)da\n1"
      ],
      [
        "1 2 5\n9 6 11",
        "Sa(cid:237)da\n54"
      ],
      [
        "1 2 12\n6 9 10",
        "Sa(cid:237)da\n0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "transporte"
    },
    "imagesQuant": 0
  },
  {
    "name": "Progressıes AritmØticas",
    "description": "Bob Ø um aluno do ensino mØdio que gosta muito de matemÆtica. Na œltima aula ele aprendeu o que sªo Progressıes AritmØticas (PAs) e (cid:28)cou fascinado por elas. Pelo que Bob entendeu, Progressıes AritmØticas sªo sequŒncias de nœmeros nas quais a diferen(cid:231)a entre dois elementos consecutivos Ø sempre igual a uma constante r, chamada de razªo da PA.\nUm exemplo de Progressªo AritmØtica de razªo 2 Ø −1,1,3,5. AlØm disso, toda sequŒncia com um ou dois elementos Ø sempre uma Progressªo AritmØtica. Por outro lado, 5,6,8,9,10 nªo Ø uma PA porque a diferen(cid:231)a entre elementos consecutivos nªo Ø constante: a diferen(cid:231)a entre os dois primeiros elementos Ø 6−5 = 1, enquanto a diferen(cid:231)a entre o terceiro e o segundo elementos Ø 8 − 6 = 2.\nBob percebeu que qualquer sequŒncia, mesmo que a mesma nªo seja uma Progressªo AritmØtica, pode ser quebrada em sequŒncias menores que sªo PAs. Por exemplo, vimos que a sequŒncia 5,6,8,9,10 nªo Ø uma PA, mas podemos quebrar ela entre o 6 e o 8 para obtermos as sequŒncias 5,6 e 8,9,10, que sªo PAs. Note que nªo existe como quebrar a sequŒncia em menos partes se quisermos ter apenas PAs no (cid:28)m do procedimento.\nBob Ø fascinado por programa(cid:231)ªo mas ainda nªo sabe programar muito bem, e por isso pediu sua ajuda: ele nªo estÆ conseguindo descobrir como quebrar sequŒncias muito grandes de um jeito e(cid:28)ciente; por isso, pediu que vocŒ escrevesse um programa para, dada uma sequŒncia qualquer, imprimir o nœmero m(cid:237)nimo de partes em que precisamos quebrar a sequŒncia para termos apenas Progressıes AritmØticas no tØrmino do processo. Caso a sequŒncia original jÆ seja uma PA, podemos terminar o processo com uma œnica parte, e portanto a resposta para esse caso Ø 1.\nEntrada\nA primeira linha da entrada Ø composta por um inteiro N, o nœmero de elementos da sequŒncia. Na segunda linha existem N inteiros ai, os elementos da sequŒncia.\nSa(cid:237)da A sa(cid:237)da deve conter uma œnica linha, indicando o nœmero m(cid:237)nimo de partes em que Bob precisa quebrar a sequŒncia original para que ele termine apenas com PAs.\nRestri(cid:231)ıes • 1 ≤ N ≤ 105 • −105 ≤ ai ≤ 105 Exemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   (cid:201) fÆcil veri(cid:28)car que a sequŒncia −2,0,2,3,3,4,6 (do exemplo acima) nªo Ø uma PA, pois 2−0 6= 3−2.\nVeri(cid:28)cando manualmente, vocŒ pode constatar que nªo Ø poss(cid:237)vel particionar a sequŒncia em duas de tal forma que ambas as partes sejam PAs. Entretanto, existe uma maneira de particionar a sequŒncia em 3 PAs:   4,6 . Portanto, temos que a resposta para este exemplo Ø 3.\nEntrada\nSa(cid:237)da   A sequŒncia −2,0,3,6 (do exemplo acima) pode ser particionada de vÆrias formas. As œnicas maneiras que resultam em PAs sªo as seguintes: • Com 4 partes temos 1 possibilidade: −2 0 3 6 • Com 3 partes temos 3 possibilidades: −2,0 3 6 −2 0,3 6 −2 0 3,6 • Com 2 partes temos 2 possibilidades: −2,0 3,6 −2 0,3,6",
    "examples": [
      [
        "5\n1 2 3 4 5",
        "Sa(cid:237)da\n1"
      ],
      [
        "7\n-2 0 2 3 3 4 6",
        "Sa(cid:237)da\n3"
      ],
      [
        "4\n-2 0 3 6",
        "Sa(cid:237)da\n2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pulo do Sapo",
    "description": "Sebastiªo Bueno Coelho, apelidado de SBC pelos familiares e amigos, passou as fØrias de janeiro de 2011 no s(cid:237)tio de seus av(cid:243)s. Durante sua estadia, uma das atividades prediletas do SBC era nadar no rio que havia no fundo da casa onde morava.\nUma das caracter(cid:237)sticas do rio que mais impressionava SBC era um belo caminho, feito inteiramente com pedras brancas. HÆ muito tempo, o av(cid:244) de SBC notara que os habitantes do s(cid:237)tio atravessavam o rio com grande frequŒncia e, por isso, construiu um caminho no rio com pedras posicionadas em linha reta; ao fazŒ-lo, tomou muito cuidado para que o espa(cid:231)amento das pedras fosse de exatamente um metro.\nHoje em dia, a œnica utilidade do caminho Ø servir de diversªo para os sapos que vivem no rio, que pulam de uma pedra a outra agitadamente. Um certo dia, enquanto descansava e nadava nas Æguas, SBC assistiu atentamente (cid:224)s acrobacias dos bichos e notou que cada sapo sempre pulava (zero, uma ou mais vezes) uma quantidade (cid:28)xa de metros.\nSBC sabe que vocŒ participa da OBI todos os anos e, chegando na escola, resolveu desa(cid:28)ar-te com o seguinte problema: Dado o nœmero de pedras no rio, o nœmero de sapos, a pedra inicial sobre a qual cada sapo estÆ (cada pedra Ø identi(cid:28)cada por sua posi(cid:231)ªo na sequŒncia de pedras) e a dist(cid:226)ncia que cada sapo pula, determinar as posi(cid:231)ıes onde pode existir um sapo depois que SBC chega no rio.\nEntrada\nA primeira linha da entrada contØm dois inteiros N e M representando o nœmero de pedras no rio e o nœmero de sapos, respectivamente. Cada uma das M linhas seguintes possui dois inteiros P e D representando a posi(cid:231)ªo inicial de um sapo e a dist(cid:226)ncia (cid:28)xa de pulo, respectivamente.\nSa(cid:237)da A sa(cid:237)da contØm N linhas. A i-Øsima linha indica a possibilidade ou nªo de ter um sapo na i-Øsima pedra.\nPara as pedras que podem ter um sapo vocŒ deve imprimir 1, e para as pedras que com certeza nªo podem ter nenhum sapo vocŒ deve imprimir 0.\nRestri(cid:231)ıes • 1 ≤ N,M ≤ 100 • Para cada sapo, 1 ≤ P,D ≤ N Exemplos\nEntrada\nSa(cid:237)da   Neste exemplo, SBC indicou a existŒncia de 5 pedras no rio e 2 sapos. Os sapos estavam inicialmente nas pedras 3 e 4. SBC tambØm lhe disse que o primeiro sapo da entrada sempre pula 2 metros, e o segundo sempre pula 4 metros. A (cid:28)gura a seguir ilustra as poss(cid:237)veis pedras que podem ser ocupadas pelos sapos quando eles come(cid:231)am a pular.\n1 2 3 4 5 Entrada\nSa(cid:237)da   Neste exemplo, SBC indicou a existŒncia de 8 pedras no rio e 3 sapos. Os sapos estavam inicialmente nas pedras 3, 2 e 6. SBC tambØm lhe disse que o primeiro sapo da entrada sempre pula 3 metros, o segundo e terceiro sempre pulam 2 metros. Dessa forma, o primeiro sapo pode estar nas pedras 3 ou 6; o segundo sapo pode estar nas pedras 2,4,6 ou 8; e o terceiro sapo pode estar nas pedras 6,4,2 e 8. A (cid:28)gura a seguir ilustra as poss(cid:237)veis pedras que podem ser ocupadas pelos sapos quando eles come(cid:231)am a pular.\n1 2 3 4 5 6 7 8",
    "examples": [
      [
        "5 2\n3 2\n4 4",
        "Sa(cid:237)da\n1\n0\n1\n1\n1"
      ],
      [
        "8 3\n3 3\n2 2\n6 2",
        "Sa(cid:237)da\n0\n1\n1\n1\n0\n1\n0\n1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pulosapo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tri(cid:226)ngulos",
    "description": "triangulos.py Caio estava brincando de construir tri(cid:226)ngulos com palitos de diferentes tamanhos. Ele fazia isso juntando as pontas de trŒs palitos sobre uma mesa. Ele notou que podia agrupar os tri(cid:226)ngulos formados em trŒs grupos: • Tri(cid:226)ngulos acut(cid:226)ngulos, que sªo aqueles em que todos os (cid:226)ngulos internos medem menos de 90◦; • Tri(cid:226)ngulos ret(cid:226)ngulos, que sªo aqueles que possuem um (cid:226)ngulo interno que mede exatamente 90◦; • Tri(cid:226)ngulos obtus(cid:226)ngulos, que sªo aqueles que possuem um (cid:226)ngulo interno que mede mais de 90◦.\nEle tambØm percebeu que nem sempre Ø poss(cid:237)vel formar um tri(cid:226)ngulo com trŒs palitos.\n  Sua tarefa Ø, dados os comprimentos A, B e C de trŒs palitos, dizer se Ø poss(cid:237)vel formar um tri(cid:226)ngulo com esses palitos e, em caso a(cid:28)rmativo, dizer a qual grupo o tri(cid:226)ngulo formado pertence.\nEntrada\nA entrada consiste de uma œnica linha, contendo trŒs inteiros A, B e C separados por espa(cid:231)o.\nSa(cid:237)da Imprima uma linha contendo apenas uma letra minœscula: • ‘n’ se nªo for poss(cid:237)vel formar um tri(cid:226)ngulo; • ‘a’ se o tri(cid:226)ngulo formado for acut(cid:226)ngulo; • ‘r’ se o tri(cid:226)ngulo formado for ret(cid:226)ngulo; • ‘o’ se o tri(cid:226)ngulo formado for obtus(cid:226)ngulo.\nRestri(cid:231)ıes • 1 ≤ A ≤ 104 • 1 ≤ B ≤ 104 • 1 ≤ C ≤ 104 Exemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "1 1 1",
        "Sa(cid:237)da\na"
      ],
      [
        "1 2 1",
        "Sa(cid:237)da\nn"
      ],
      [
        "5 4 3",
        "Sa(cid:237)da\nr"
      ],
      [
        "6 3 4",
        "Sa(cid:237)da\no"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "triangulos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Desa(cid:28)o cartogrÆ(cid:28)co",
    "description": "cartografico.py Leonardo Nascimento Ø um garoto de 13 anos apaixonado por cartogra(cid:28)a. Ele assina a lista de discussıes da Sociedade Brasileira de Cartogra(cid:28)a (SBC) para (cid:28)car por dentro de todas as novidades. Em um t(cid:243)pico de discussªo na lista da SBC, o presidente da sociedade descobriu que Leonardo tinha apenas 13 anos, e (cid:28)cou muito feliz em saber que uma pessoa tªo jovem tinha tanto interesse pela arte de tra(cid:231)ar mapas geogrÆ(cid:28)cos e topogrÆ(cid:28)cos. Foi entªo que o presidente resolveu criar desa(cid:28)os com intuito de difundir a cartogra(cid:28)a.\nUm dos desa(cid:28)os era o seguinte: dado um mapa de cidades ligadas por estradas, determinar a dist(cid:226)ncia entre um par de cidades mais distantes. Como o objetivo era fazer as crian(cid:231)as se divertirem, o presidente resolveu selecionar mapas bem simples. As restri(cid:231)ıes adotadas foram: (a) todas as estradas sªo de mªo dupla; (b) todas as estradas possuem 1km de comprimento, e portanto toda estrada ligando duas cidades tem o mesmo comprimento; (c) toda estrada conecta apenas duas cidades, e (d) dadas duas cidades quaisquer A e B, s(cid:243) existe uma œnica maneira de chegar em A partindo de B, e vice-versa.\nO presidente da SBC resolveu pedir sua ajuda para escrever um programa de computador que, dado um mapa seguindo as restri(cid:231)ıes acima, devolva a resposta. Assim, ele conseguirÆ gerar um gabarito para enviar junto com o desa(cid:28)o.\nEntrada\nA primeira linha da entrada contØm um inteiro N representando o nœmero de cidades no mapa. Cada uma das N −1 linhas seguintes da entrada contØm dois inteiros A e B indicando que existe uma estrada entre as cidades A e B.\nSa(cid:237)da A œnica linha da sa(cid:237)da contØm um inteiro indicando a dist(cid:226)ncia entre um par de cidades mais distantes.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 20 pontos, N ≤ 200.\n• Em um conjunto de casos de teste que totaliza 40 pontos, N ≤ 1000.\nRestri(cid:231)ıes • 2 ≤ N ≤ 106 • 1 ≤ A,B ≤ N e A 6= B Exemplos\nA (cid:28)gura abaixo ilustra este exemplo, onde temos 5 cidades identi(cid:28)cadas por 1,2,...,5. As cidades 1 e 4 estªo a uma dist(cid:226)ncia de 3km, assim como as cidades 1 e 5. Nªo temos nenhum par de cidades que estªo a uma dist(cid:226)ncia maior que 3km. Portanto, a resposta para esse caso Ø 3.\n1 2 3 4 5",
    "examples": [
      [
        "10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10",
        "Sa(cid:237)da\n9"
      ],
      [
        "5\n1 2\n2 3\n3 4\n3 5",
        "Sa(cid:237)da\n3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cartografico"
    },
    "imagesQuant": 0
  },
  {
    "name": "O mar nªo estÆ para peixe",
    "description": "Em um arquipØlago no meio do Oceano Pac(cid:237)(cid:28)co a economia Ø regida pela pesca, pois o peixe Ø o principal alimento dispon(cid:237)vel. Ultimamente, a popula(cid:231)ªo desse arquipØlago tem aumentado drasticamente, o que levou a um grande aumento da pesca, e, consequentemente, a problemas.\nNeste arquipØlago, cada pescador vai diariamente ao alto mar com a inten(cid:231)ªo de conseguir trazer o maior nœmero de peixes para o seu vilarejo. Com a expansªo da pesca, os pescadores estªo come(cid:231)ando a jogar suas redes de pesca por cima das de outros pescadores. Com isso, os pescadores perdem, pois apenas o primeiro pescador pega os peixes da intersec(cid:231)ªo entre as redes.\nA Associa(cid:231)ªo dos Pescadores da ilha decidiu fazer um levantamento para descobrir quanto do mar estÆ de fato sendo aproveitado, ou seja, qual a Ærea do mar que estÆ coberta por pelo menos uma rede de pesca.\nComo hÆ muitas intersec(cid:231)ıes entre as redes de pesca, Ø muito dif(cid:237)cil para a associa(cid:231)ªo calcular a Ærea total da regiªo coberta pelas redes. Por este motivo, eles pediram para que vocŒ escrevesse um programa para resolver este problema.\nComo Ø muito dif(cid:237)cil navegar pelo mar, os pescadores sempre jogam as redes de forma que as regiıes cobertas por cada rede sªo sempre ret(cid:226)ngulos com lados paralelos aos eixos, se imaginarmos o mar como um plano cartesiano.\nEntrada\nA primeira linha da entrada possui um inteiro N indicando o nœmero de redes que foram lan(cid:231)adas. As pr(cid:243)ximas N linhas descrevem as regiıes cobertas pelas redes: cada uma contØm quatro inteiros Xi e Xf, Yi e Yf. A regiªo coberta pela rede em questªo contØm todo ponto (X,Y ) tal que Xi ≤ X ≤ Xf e Yi ≤ Y ≤ Yf.\nSa(cid:237)da A sa(cid:237)da deve conter apenas uma linha contendo a Ærea da regiªo do mar realmente aproveitada pelos pescadores, ou seja, a Ærea total da regiªo do mar coberta por pelo menos uma rede de pesca.\nRestri(cid:231)ıes • 1 ≤ N ≤ 100 • 1 ≤ Xi ≤ Xf ≤ 100 • 1 ≤ Yi ≤ Yf ≤ 100 Exemplos",
    "examples": [
      [
        "2\n1 3 1 3\n2 4 2 4",
        "Sa(cid:237)da\n7"
      ],
      [
        "3\n1 6 1 2\n3 7 1 2\n2 5 1 2",
        "Sa(cid:237)da\n6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pesca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quadrado AritmØtico",
    "description": "Arnaldo e Bernardo sªo dois garotos que compartilham um peculiar gosto por curiosidades matemÆticas. Nos œltimos tempos, sua principal diversªo tem sido investigar propriedades matemÆgicas de tabuleiros quadrados preenchidos com inteiros. Um belo dia, Arnaldo desenhou o tabuleiro da seguinte (cid:28)gura.\n  (cid:22) Olha s(cid:243), vÆrias somas nesse quadrado sªo iguais! (cid:22) exclamou Bernardo.\n(cid:22) Como assim? (cid:22) devolveu, intrigado, Arnaldo.\n(cid:22) Observe: -41 -29 2 -41 -29 2 -41 -29 2 -41 -29 2 28 40 71 28 40 71 28 40 71 28 40 71 11 23 54 11 23 54 11 23 54 11 23 54 (cid:22) (cid:201) mesmo! (−41) + 40 + 54 dÆ 53, 28 + (−29) + 54 tambØm! (cid:22) exclamou Arnaldo.\n(cid:22) Eu jÆ veri(cid:28)quei: existem 6 formas de escolhermos 3 cØlulas deste quadrado de forma que cada linha e coluna tenha exatamente uma cØlula escolhida. Em todas elas, a soma dÆ 53. AlØm disso, todos os nœmeros sªo distintos nesse quadrado. (cid:22) notou Bernardo, exibindo suas habilidades aritmØticas.\n(cid:22) Que bacana! Esse quadrado Ø realmente mÆgico! Ou, melhor, esse quadrado Ø realmente aritmØtico! SerÆ que existem mais quadrados como esse? Uma escolha legal de cØlulas Ø uma escolha em que toda linha e toda coluna tenha exatamente uma cØlula escolhida. Um quadrado aritmØtico de tamanho N e soma S Ø um tabuleiro de inteiros de N linhas e N colunas em que qualquer escolha legal tem soma S e em que todos os nœmeros sªo distintos.\nSua tarefa, neste problema, Ø gerar um quadrado aritmØtico de tamanho N e soma S, dados N e S. Como Arnaldo e Bernardo vªo querer conferir a sua solu(cid:231)ªo em suas calculadoras, vocŒ nªo deve gerar um quadrado em que alguma cØlula tenha valor absoluto maior do que 109.\nEntrada\nA primeira e œnica linha da entrada contØm dois nœmeros inteiros N e S (1 ≤ N ≤ 1000 e −1000 ≤ S ≤ 1000) representando, respectivamente, o tamanho e a soma do quadrado aritmØtico pedido.\nSa(cid:237)da Seu programa deve imprimir N linhas, cada uma com N inteiros entre −109 e 109, representando o quadrado aritmØtico pedido. Para uma mesma entrada, podem existir vÆrios quadrados aritmØticos vÆlidos; seu programa deve imprimir qualquer um deles, mas apenas um.\n(cid:201) garantido que existirÆ pelo menos um quadrado aritmØtico vÆlido para cada entrada testada.\nRestri(cid:231)ıes • 1 ≤ N ≤ 1000 • −1000 ≤ S ≤ 1000 • −109 ≤ valor de cada cØlula ≤ 109 Informa(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 3; • Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 100; Exemplos\nObserve que, neste problema, para uma mesma entrada, podem existir vÆrias sa(cid:237)das corretas. As sa(cid:237)das abaixo indicam apenas uma de vÆrias potenciais solu(cid:231)ıes. Contanto que sua sa(cid:237)da seja um quadrado aritmØtico vÆlido segundo as condi(cid:231)ıes do enunciado, sua solu(cid:231)ªo serÆ considerada correta, mesmo que nªo seja igual aos exemplos indicados abaixo.\n  Entrada\nSa(cid:237)da 3 53",
    "examples": [
      [
        "2 49",
        "Sa(cid:237)da\n23 40\n9 26"
      ],
      [
        "3 53",
        "Sa(cid:237)da\n-41 -29 2\n28 40 71\n11 23 54"
      ],
      [
        "1 -55",
        "Sa(cid:237)da\n-55"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quadrado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ca(cid:231)a ao Tesouro",
    "description": "Capitªo Tornado Ø um pirata muito cruel que faz qualquer coisa por dinheiro. HÆ alguns dias, o capitªo soube da existŒncia de um tesouro numa ilha deserta, e agora tenta determinar sua posi(cid:231)ªo.\nA ilha pode ser vista como um quadriculado N × N de terra cuja posi(cid:231)ªo (0,0) estÆ a sudoeste, a posi(cid:231)ªo (N − 1,0) estÆ a sudeste, a posi(cid:231)ªo (0,N − 1) estÆ a noroeste e a posi(cid:231)ªo (N − 1,N − 1) estÆ a nordeste. Em alguma posi(cid:231)ªo desse quadriculado estÆ o tesouro.\nUma curiosidade importante Ø a perna de pau que o capitªo possui. Ela impede que o capitªo se locomova em dire(cid:231)ıes que nªo a horizontal ou a vertical: para ir da posi(cid:231)ªo (1,1) para a posi(cid:231)ªo (3,2), por exemplo, o capitªo Ø obrigado a gastar trŒs passos. (cid:201) claro que o capitªo sempre escolhe, dentro de suas limita(cid:231)ıes, um caminho com o menor nœmero de passos poss(cid:237)vel. Chamamos esse modo de andar de passos de capitªo. Um exemplo de caminho por passos de capitªo entre (1,1) e (3,2) Ø ilustrado na (cid:28)gura a seguir.\n0, 3 1, 3 2, 3 3, 3 N 0, 2 1, 2 2, 2 3, 2 L 0, 1 1, 1 2, 1 3, 1 0, 0 1, 0 2, 0 3, 0 Como em toda boa ca(cid:231)a ao tesouro, o capitªo nªo conhece a posi(cid:231)ªo onde o tesouro se encontra: ele possui um mapa que corresponde (cid:224) geogra(cid:28)a da ilha. Em algumas posi(cid:231)ıes desse mapa, existem pistas escritas. Cada pista consiste em um nœmero D, que indica a menor dist(cid:226)ncia em passos de capitªo entre a posi(cid:231)ªo em que a pista se encontra e a do tesouro.\n2 X X? 1 X? 2 3 4 3 Observe que, dependendo da disposi(cid:231)ªo das pistas, a posi(cid:231)ªo do tesouro pode estar determinada de maneira œnica ou nªo. Na (cid:28)gura acima e (cid:224) esquerda, as duas pistas sªo su(cid:28)cientes para se saber, com certeza, onde estÆ o tesouro; na (cid:28)gura (cid:224) direita, as quatro pistas dadas ainda possibilitam que tanto a posi(cid:231)ªo (0,2) quanto a (2,2) guardem o tesouro. Nesse œltimo caso, nªo se pode determinar, com certeza, qual Ø a localiza(cid:231)ªo do tesouro.\nDadas as pistas que o capitªo possui, sua tarefa Ø determinar se as pistas fornecem a localiza(cid:231)ªo exata do tesouro e, caso positivo, qual ela Ø.\nEntrada\nA primeira linha contØm dois inteiros positivos N e K, onde N Ø a dimensªo do quadriculado e K Ø o nœmero de pistas no mapa que o capitªo possui.\nCada uma das pr(cid:243)ximas K linhas contŒm trŒs inteiros X, Y e D, informando que existe uma pista na posi(cid:231)ªo (X,Y ) contendo o nœmero D. Essa pista indica que o tesouro encontra-se a D passos de capitªo da posi(cid:231)ªo da pista.\n(cid:201) garantido que, com essas pistas, existe ao menos uma localiza(cid:231)ªo poss(cid:237)vel para o tesouro. AlØm disso, o mapa nªo contØm duas pistas na mesma posi(cid:231)ªo.\nSa(cid:237)da Se as pistas forem su(cid:28)cientes para determinar com certeza a localiza(cid:231)ªo do tesouro, seu programa deve imprimir uma œnica linha com dois inteiros, X e Y , indicando que o tesouro encontra-se na posi(cid:231)ªo (X,Y ).\nCaso contrÆrio, seu programa deve imprimir uma œnica linha com dois inteiros iguais a −1, como nos exemplos de sa(cid:237)da a seguir.\nRestri(cid:231)ıes • 2 ≤ N ≤ 100 • 1 ≤ K ≤ 100 Exemplos",
    "examples": [
      [
        "4 2\n0 0 3\n3 0 4",
        "Sa(cid:237)da\n1 2"
      ],
      [
        "4 4\n1 0 3\n1 1 2\n1 2 1\n1 3 2",
        "Sa(cid:237)da\n-1 -1"
      ],
      [
        "3 3\n0 0 2\n1 1 2\n2 0 4",
        "Sa(cid:237)da\n0 2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tesouro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Calculadora",
    "description": "calculadora.py Solicitando Boas Contas (SBC) Ø uma organiza(cid:231)ªo de inspe(cid:231)ªo de calculadoras. Todos os fabricantes procuram ter o selo de qualidade da SBC, que faz com que os clientes comprem o produto sem preocupa(cid:231)ªo com contas erradas.\nVocŒ estÆ encarregado de testar mÆquinas que fazem apenas opera(cid:231)ıes de multiplica(cid:231)ªo e divisªo. AlØm disso, o termo a ser digitado em cada opera(cid:231)ªo (que dividirÆ ou multiplicarÆ o nœmero atualmente exibido no visor) s(cid:243) pode conter um œnico d(cid:237)gito.\nA calculadora exibe o nœmero 1 quando ligada. Depois disso, o usuÆrio pode digitar um nœmero com um œnico d(cid:237)gito e escolher se esse nœmero deve multiplicar ou dividir o nœmero exibido anteriormente; o resultado da opera(cid:231)ªo escolhida Ø entªo exibido na calculadora. Pode-se repetir esse processo inde(cid:28)nidamente.\nApesar de s(cid:243) podermos entrar com nœmeros inteiros de um d(cid:237)gito, o visor da calculadora permite exibir nœmeros com mœltiplos d(cid:237)gitos e atØ mesmo nœmeros fracionÆrios.\nDada uma sequŒncia de opera(cid:231)ıes que foram realizadas nessa calculadora logo depois de ligada, sua tarefa Ø conferir o resultado exibido.\nEntrada\nA primeira e œnica linha da entrada contØm um inteiro N. Cada uma das pr(cid:243)ximas N linhas contØm um d(cid:237)gito e um caractere ‘*‘ ou ‘/’, que representam uma opera(cid:231)ªo realizada na calculadora.\nSa(cid:237)da Seu programa deve imprimir uma œnica linha contendo o resultado que deve ser exibido pela calculadora ao (cid:28)nal das opera(cid:231)ıes.\nRestri(cid:231)ıes • 1 ≤ N ≤ 100000.\n• Os nœmeros informados sªo inteiros entre 1 e 9.\n• O resultado (cid:28)nal da conta Ø um nœmero inteiro entre 1 e 230.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 20 pontos, N = 3.\n• Em um conjunto de casos de teste que totaliza 50 pontos, o resultado da expressªo atØ a opera(cid:231)ªo i Ø um inteiro entre 1 e 230, para i = 1,2,..,N.\nExemplos\nEntrada\nSa(cid:237)da   O usuÆrio deseja calcular o resultado da seguinte expressªo: 1 × 2 × 1 × 3. Note que a primeira ocorrŒncia do nœmero 1 vem do fato da calculadora mostrar inicialmente 1 ao invØs de 0.\nEntrada\nSa(cid:237)da   Neste exemplo, o usuÆrio deseja calcular o resultado da seguinte expressªo: ((1/2)/3) × 6.\nEntrada\nSa(cid:237)da",
    "examples": [
      [
        "3\n2 *\n1 *\n3 *",
        "Sa(cid:237)da\n6"
      ],
      [
        "3\n2 /\n3 /\n6 *",
        "Sa(cid:237)da\n1"
      ],
      [
        "11\n9 *\n9 *\n9 *\n9 *\n9 *\n9 *\n9 *\n9 *\n9 *\n9 *\n9 /",
        "Sa(cid:237)da\n387420489"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "calculadora"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chuva",
    "description": "Bob trabalha no OBM ((cid:211)rgªo Brasileiro de Metereologia), que Ø a organiza(cid:231)ªo responsÆvel pela medi(cid:231)ªo dos (cid:237)ndices pluviomØtricos (quantidade de chuva acumulada) em todo o pa(cid:237)s. Eles sªo muito e(cid:28)cientes no que fazem, mas estªo com um problema: eles nªo sabem como proceder para calcular a quantidade acumulada de chuva que caiu em cada regiªo em dois per(cid:237)odos consecutivos, muito embora eles saibam os dados de cada per(cid:237)odo separadamente.\nComo a che(cid:28)a do (cid:211)rgªo estava muito ocupada, acabou (cid:28)cando a cargo de Bob, o estagiÆrio, a tarefa de implementar um programa que some, para cada regiªo, a quantidade de chuva acumulada em dois per(cid:237)odos consecutivos.\nO mapa que o OBM usa Ø dividido em N×N regiıes, sendo que para cada regiªo, a cada per(cid:237)odo, Ø determinado um nœmero inteiro indicando a quantidade de chuva acumulada. A quantidade de chuva acumulada total em cada regiªo em dois per(cid:237)odos consecutivos Ø a soma das quantidades de chuva em cada um dos per(cid:237)odos.\nMas como Bob Ø s(cid:243) um estagiÆrio e nªo estÆ acostumado a fazer nada mais do que tirar c(cid:243)pias de documentos, ele pediu sua ajuda para implementar o programa que calcula a quantidade de chuva acumulada total nos dois per(cid:237)odos para cada uma das regiıes, dadas as quantidades de chuva acumulada em cada per(cid:237)odo para cada regiªo.\nEntrada\nA primeira linha da entrada contØm um inteiro N indicando a dimensªo dos dois mapas que devem ser lidos.\nNas pr(cid:243)ximas 2N linhas sªo dados os dois mapas, cada mapa indicando a quantidade de chuva acumulada nas regiıes em um per(cid:237)odo. Cada mapa Ø descrito em N linhas consecutivas, cada linha contendo N inteiros, sendo que cada inteiro indica a quantidade de chuva acumulada, no per(cid:237)odo, em uma regiªo.\nSa(cid:237)da A sa(cid:237)da deverÆ conter N linhas, com N inteiros em cada linha, indicando a quantidade de chuva acumulada total em cada uma das regiıes nos dois per(cid:237)odos considerados.\nRestri(cid:231)ıes • 1 ≤ N ≤ 100.\n• 0 ≤ quantidade de chuva acumulada em cada regiªo de cada mapa ≤ 100.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "2\n1 2\n3 4\n10 11\n12 13",
        "Sa(cid:237)da\n11 13\n15 17"
      ],
      [
        "3\n1 1 1\n1 2 2\n1 2 3\n3 2 1\n2 2 1\n1 1 1",
        "Sa(cid:237)da\n4 3 2\n3 4 3\n2 3 4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chuva"
    },
    "imagesQuant": 0
  },
  {
    "name": "Gincana",
    "description": "Toda semana Juquinha tem aulas de ACM (Artes CŒnicas e Musicais) no colØgio em que estuda e, recentemente, sua professora anunciou que haverÆ uma gincana no (cid:28)nal do semestre. No entanto, os times devem ser formados o mais breve poss(cid:237)vel para que os alunos possam ensaiar.\nCada time Ø constitu(cid:237)do de um ou mais alunos, e cada aluno tem que pertencer a exatamente um time. AlØm disso, os times nªo podem ser formados de qualquer maneira: se um aluno Ø amigo de outro, esses alunos devem estar no mesmo time. A professora entªo pediu para que os alunos a informassem das rela(cid:231)ıes de amizade na sala de aula.\nOs alunos entªo se numeraram de 1 atØ N e escreveram uma lista cujas linhas contØm pares de nœmeros. Se dois alunos cujos nœmeros sªo i e j sªo amigos, haverÆ ao menos uma linha contendo i e j ou j e i na lista.\nInversamente, se hÆ uma linha contendo i e j na lista, entªo os alunos cujos nœmeros sªo i e j sªo amigos.\nA professora entªo recolheu a lista e, na pr(cid:243)xima aula, deverÆ decidir que times formar. Ela estÆ pensando em formar o maior nœmero poss(cid:237)vel de times e gostaria de saber quantos times ela formaria. Ajude entªo a professora escrevendo um programa que, dada a lista de amizades, determina qual o maior nœmero de times que ela pode formar.\nEntrada\nA primeira linha da entrada contØm dois inteiros N e M que representam, respectivamente, o nœmero de alunos na turma e o nœmero de linhas na lista.\nAs pr(cid:243)ximas M linhas contŒm a lista de amizades. Cada linha contØm dois inteiros I e J separados por exatamente um espa(cid:231)o.\nSa(cid:237)da Seu programa deve imprimir uma linha contendo o nœmero mÆximo de times que podem ser formados pela professora.\nRestri(cid:231)ıes • 1 ≤ N ≤ 1000.\n• 0 ≤ M ≤ 5000.\n• 1 ≤ I,J ≤ N.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "3 1\n1 3",
        "Sa(cid:237)da\n2"
      ],
      [
        "7 6\n1 6\n6 4\n5 2\n3 7\n2 3\n7 2",
        "Sa(cid:237)da\n2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "gincana"
    },
    "imagesQuant": 0
  },
  {
    "name": "BalØ",
    "description": "Uma academia de balØ irÆ organizar uma O(cid:28)cina de BalØ Intensivo (OBI) na Semana de BalØ Contempor(cid:226)neo (SBC). Nessa academia, existem N bailarinas que praticam regularmente. O dono da academia, por ser experiente, consegue medir o n(cid:237)vel de habilidade de cada uma delas por um nœmero inteiro; nessa medi(cid:231)ªo, nœmeros maiores correspondem a dan(cid:231)arinas mais habilidosas, e os nœmeros obtidos sªo todos distintos. AlØm disso, ele possui uma lista das bailarinas em ordem cronol(cid:243)gica de ingresso na academia: As bailarinas que aparecem primeiro na lista estªo hÆ mais tempo na academia, e as que estªo no (cid:28)nal ingressaram mais recentemente.\nO dono da academia decidiu escolher duas das bailarinas para ajudÆ-lo na realiza(cid:231)ªo do evento: uma ajudarÆ no trabalho bra(cid:231)al, enquanto a outra irÆ exempli(cid:28)car os passos de balØ. Por seu perfeccionismo, ele deseja que a bailarina que exempli(cid:28)carÆ os passos de dan(cid:231)a seja, dentre as duas meninas do par, a mais habilidosa e a que frequenta a academia hÆ mais tempo.\nEle sabe que a O(cid:28)cina serÆ um sucesso desde que os dois critØrios mencionados acima sejam satisfeitos pela dupla de dan(cid:231)arinas escolhidas. Com isso, ele (cid:28)cou curioso para saber quantas duplas de dan(cid:231)arinas podem ajudÆ-lo na O(cid:28)cina. A quantidade de dan(cid:231)arinas, contudo, Ø relativamente grande e ele nªo possui nem tempo nem paciŒncia para fazer tal cÆlculo. Como vocŒs sªo amigos, ele pediu a sua ajuda para contar quantas duplas sªo vÆlidas. VocŒ pode ajudÆ-lo? Por exemplo, digamos que a academia possua 5 dan(cid:231)arinas com n(cid:237)veis de habilidade 1,5,2,4 e 3, onde a primeira, que possui n(cid:237)vel (cid:16)1(cid:17), estÆ na academia hÆ mais tempo e a œltima, que possui n(cid:237)vel (cid:16)3(cid:17), estÆ hÆ menos. Temos, entªo, 4 poss(cid:237)veis duplas que poderemos usar nesta O(cid:28)cina, que sªo (5,2),(5,4),(5,3) e (4,3). Note que a dupla (1,3), por exemplo, nªo pode ser escolhida pelo dono da academia, pois a mais habilidosa dentre as duas Ø tambØm a mais nova da dupla.\nEntrada\nA primeira linha contØm um nœmero N, que representa a quantidade de dan(cid:231)arinas que estªo registradas na academia. A segunda linha da entrada contØm N inteiros, onde o primeiro inteiro Ø o n(cid:237)vel da dan(cid:231)arina que estÆ hÆ mais tempo na academia, o segundo inteiro Ø o n(cid:237)vel da pr(cid:243)xima dan(cid:231)arina mais antiga na academia (mas mais nova que a dan(cid:231)arina anterior), e assim sucessivamente.\nSa(cid:237)da A sa(cid:237)da consistirÆ num œnico nœmero X, que representa o total de duplas de dan(cid:231)arinas vÆlidas para essa O(cid:28)cina, dadas as regras descritas anteriormente.\nRestri(cid:231)ıes • 1 ≤ N ≤ 100000.\n• Todas as dan(cid:231)arinas possuirªo n(cid:237)veis distintos, entre 1 e 100000.\n• O total de pares vÆlidos, em todos os casos, serÆ ≤ 1000000.\nInforma(cid:231)ıes sobre Pontua(cid:231)ªo • Em um conjunto de casos de teste que totalizam 70 pontos, N ≤ 300 Exemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "5\n1 5 2 4 3",
        "Sa(cid:237)da\n4"
      ],
      [
        "9\n9 8 7 6 5 4 3 1 2",
        "Sa(cid:237)da\n35"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bale"
    },
    "imagesQuant": 0
  },
  {
    "name": "Colorindo",
    "description": "A Sociedade Brasileira das Cores (SBC) Ø uma editora de livros de colorir. As crian(cid:231)as adoram os livros da SBC porque suas (cid:28)guras, depois de pintadas, (cid:28)cam muito coloridas e bonitas. Isso acontece porque a SBC se preocupa em nªo deixar grandes regiıes cont(cid:237)nuas em suas (cid:28)guras, que devem ser pintadas com uma cor s(cid:243).\nAtØ agora, o processo de veri(cid:28)car se uma (cid:28)gura tinha uma regiªo cont(cid:237)nua grande era completamente visual, mas a SBC resolveu automatizar esse processo e vocŒ foi contratado para programar uma parte desse sistema.\nUma (cid:28)gura Ø representada por uma grade, de dimensªo N por M. Cada quadrado dessa grade Ø representado por uma coordenada (i,j), com 1 ≤ i ≤ N e 1 ≤ j ≤ M. Por exemplo, a coordenada (1,5) representa o quadrado na primeira linha e quinta coluna, enquanto que a coordenada (3,7) representa o quadrado na terceira linha e sØtima coluna. As linhas sªo contadas de baixo para cima e as colunas da esquerda para a direita.\nCada quadrado pode estar vazio ou cheio. Assumimos que uma crian(cid:231)a s(cid:243) vai pintar sobre quadrados vazios e se ela pintar um quadrado de uma cor, ela irÆ pintar os oito vizinhos da mesma cor, desde que eles estejam vazios e que ela nªo saia da Ærea da (cid:28)gura.\nDada a (cid:28)gura e a coordenada onde uma crian(cid:231)a vai come(cid:231)ar a pintar, sua tarefa Ø descobrir quantos quadrados ela irÆ pintar.\nEntrada\nA primeira linha da entrada contØm 5 nœmeros inteiros, N, M,  , Y e K. Os nœmeros inteiros N e M sªo respectivamente o nœmero de linhas e colunas da grade, enquanto que ( ,Y ) Ø a coordenada onde a crian(cid:231)a vai come(cid:231)ar a pintar e K Ø o nœmero de quadrados cheios na (cid:28)gura.\nSeguem-se K linhas, cada uma com dois inteiros A e B, que sªo as coordenadas de um quadrado cheio.\nGarantimos que o quadrado na posi(cid:231)ªo ( ,Y ) estÆ sempre vazio.\nSa(cid:237)da Seu programa deve imprimir uma linha contendo o nœmero de quadrados pintados pela crian(cid:231)a.\nRestri(cid:231)ıes • 1 ≤ N,M ≤ 200.\n• 1 ≤ K ≤ 10000.\n• 1 ≤  ,A ≤ N.\n• 1 ≤ Y,B ≤ M.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Neste exemplo de caso de teste, temos uma (cid:28)gura de dimensıes 5×5. A crian(cid:231)a come(cid:231)a a pintar na posi(cid:231)ªo (3,3). Na (cid:28)gura abaixo ilustramos este caso. A posi(cid:231)ªo que a crian(cid:231)a inicia estÆ marcada com a letra (cid:16) (cid:17), e os quadrados que a crian(cid:231)a consegue pintar estªo destacandos em cinza claro.\nNote que ela consegue pintar o quadrado (4,4), pois este quadrado Ø um dos quadrados que ela consegue pintar ap(cid:243)s ter pintado o quadrado (3,3).\n5 4 3   2 1 1 2 3 4 5 Entrada\nSa(cid:237)da   Neste exemplo de caso de teste, temos uma (cid:28)gura de dimensıes 10×10. A crian(cid:231)a come(cid:231)a a pintar na posi(cid:231)ªo (5,5). Na (cid:28)gura abaixo ilustramos este caso. A posi(cid:231)ªo que a crian(cid:231)a inicia estÆ marcada com a letra (cid:16) (cid:17), e os quadrados que a crian(cid:231)a consegue pintar estªo destacandos em cinza claro.\n10 9 8 7 6 5   4 3 2 1 1 2 3 4 5 6 7 8 9 10",
    "examples": [
      [
        "1 5 1 2 2\n1 1\n1 4",
        "Sa(cid:237)da\n2"
      ],
      [
        "5 5 3 3 7\n2 2\n2 3\n2 4\n3 2\n3 4\n4 2\n4 3",
        "Sa(cid:237)da\n18"
      ],
      [
        "10 10 5 5 22\n2 2\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n3 2\n3 8\n4 2\n4 8\n5 2\n5 8\n6 2\n6 8\n7 2\n7 3\n7 4\n7 5\n7 6\n7 7\n7 8",
        "Sa(cid:237)da\n20"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "colorir"
    },
    "imagesQuant": 0
  },
  {
    "name": "Selos",
    "description": "Euclides Ø um garoto que gosta muito de colecionar selos. No seu aniversÆrio, seus pais o presentearam com N selos, todos em formato de quadrados com 1 cm de lado. Euclides gostaria de guardar todos os N selos que ganhou colando-os numa pÆgina de papel em branco. Ao decidir por guardÆ-los assim, no entanto, ele logo percebeu que a œnica forma que lhe agradava de posicionar os selos na pÆgina era a forma de um ret(cid:226)ngulo completamente coberto pelos mesmos, sem sobreposi(cid:231)ªo.\nEle percebeu tambØm que, independente do nœmero de selos obtido, colocar todos os selos numa œnica linha ou todos os selos numa œnica coluna Ø uma con(cid:28)gura(cid:231)ªo vÆlida. Como essa maneira usa a pÆgina do caderno de um jeito muito ine(cid:28)ciente, Euclides gostaria de saber se existe algum modo de dispor os N selos num ret(cid:226)ngulo que tenha mais de uma linha e mais de uma coluna tal que todas as linhas e colunas sejam completamente ocupadas por selos (isto Ø, tal que nªo existam posi(cid:231)ıes sem selos no interior do ret(cid:226)ngulo).\nEntrada\nA entrada contØm uma œnica linha com um œnico inteiro N, o nœmero de selos que Euclides ganhou.\nSa(cid:237)da A sa(cid:237)da deve conter uma linha com um œnico caracter, que deve ser ‘S’ se for poss(cid:237)vel organizar os selos em um ret(cid:226)ngulo com mais que uma linha e mais que uma coluna ou ‘N’ caso nªo seja poss(cid:237)vel.\nRestri(cid:231)ıes • 1 ≤ N ≤ 10000000000.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 1000000.\nExemplos\nEntrada\nSa(cid:237)da   A (cid:28)gura abaixo exempli(cid:28)ca duas maneiras de guardar os selos em forma de ret(cid:226)ngulo.\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da 1",
    "examples": [
      [
        "8",
        "Sa(cid:237)da\nS"
      ],
      [
        "1",
        "Sa(cid:237)da\nN"
      ],
      [
        "11",
        "Sa(cid:237)da\nN"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "selos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Escalonamento (cid:243)timo",
    "description": "O SBC (System for Batch Computing) Ø um sistema operacional voltado para a execu(cid:231)ªo sequencial de tarefas.\nO operador do sistema cria tarefas e o sistema operacional Ø responsÆvel por agendar a execu(cid:231)ªo destas tarefas.\nCada tarefa pode depender da conclusªo de algumas tarefas para poder come(cid:231)ar. Se uma tarefa A depende de uma tarefa B, a tarefa B deve terminar antes que a tarefa A inicie sua execu(cid:231)ªo.\nAlØm disto, cada tarefa possui uma prioridade. (cid:201) sempre mais vantajoso para o sistema come(cid:231)ar executando uma tarefa de mais alta prioridade, depois continuar executando uma tarefa de mais alta prioridade dentre as que sobraram e assim por diante.\nNeste problema, serÆ dado um inteiro N, que irÆ representar o nœmero de tarefas no sistema. As tarefas serªo numeradas de 0 atØ N − 1. Tarefas com (cid:237)ndice menor possuem prioridade maior, de forma que a tarefa 0 Ø a tarefa de mais alta prioridade, a tarefa 1 Ø a tarefa com a segunda maior prioridade e assim por diante, atØ a tarefa N −1, que Ø a tarefa com a menor prioridade. AlØm disso, serªo dadas M rela(cid:231)ıes de dependŒncia entre as tarefas.\nSeu objetivo serÆ decidir se Ø poss(cid:237)vel executar as tarefas em alguma ordem. Caso seja poss(cid:237)vel, vocŒ deverÆ produzir uma ordem de execu(cid:231)ªo (cid:243)tima para as tarefas, isto Ø, desempate as ordens poss(cid:237)veis pela prioridade da primeira tarefa. Se o empate ainda persistir, desempate pela prioridade da segunda tarefa, e assim por diante.\nEntrada\nA primeira linha da entrada contØm inteiros N e M. As pr(cid:243)ximas M linhas descrevem, cada uma, uma dependŒncia entre as tarefas da entrada. Cada uma dessas linhas irÆ conter dois inteiros A e B que indicam que a tarefa B depende da tarefa A, isto Ø, que a tarefa A deve terminar antes que a tarefa B inicie.\nSa(cid:237)da Se nªo for poss(cid:237)vel ordenar as tarefas de forma que as dependŒncias sejam satisfeitas, imprima uma œnica linha contendo o caracter (cid:16)*(cid:17). Caso contrÆrio, imprima N linhas contendo cada uma um nœmero inteiro. O inteiro na i-Øsima linha deve ser o (cid:237)ndice da i-Øsima tarefa a ser executada na ordem (cid:243)tima de execu(cid:231)ªo das tarefas.\nRestri(cid:231)ıes • 0 ≤ N ≤ 50000.\n• 0 ≤ M ≤ 200000.\n• 0 ≤ A,B < N.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste totalizando 60 pontos, N ≤ 1000.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "3 1\n2 0",
        "Sa(cid:237)da\n1\n2\n0"
      ],
      [
        "2 2\n0 1\n1 0",
        "Sa(cid:237)da\n*"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "escalona"
    },
    "imagesQuant": 0
  },
  {
    "name": "Expressıes",
    "description": "expressoes.py Pedrinho e Zezinho estªo precisando estudar resolu(cid:231)ªo de expressıes matemÆticas para uma prova que irªo fazer.\nPara isso, eles querem resolver muitos exerc(cid:237)cios antes da prova. Como sabem programar, entªo decidiram fazer um gerador de expressıes matemÆticas.\nO gerador de expressıes que eles criaram funciona em duas fases. Na primeira fase Ø gerada uma cadeia de caracteres que contØm apenas os caracteres ‘{’, ‘[’, ‘(’, ‘}’, ‘]’ e ‘)’. Na segunda fase, o gerador adiciona os nœmeros e operadores na estrutura criada na primeira fase. Uma cadeia de caracteres Ø dita bem de(cid:28)nida (ou vÆlida) se atende as seguintes propriedades: 1. Ela Ø uma cadeia de caracteres vazia (nªo contØm nenhum caractere).\n2. Ela Ø formada por uma cadeia bem de(cid:28)nida envolvida por parŒnteses, colchetes ou chaves. Portanto, se a cadeia S Ø bem de(cid:28)nida, entªo as cadeias (S), [S] e {S} tambØm sªo bem de(cid:28)nidas.\n3. Ela Ø formada pela concatena(cid:231)ªo de duas cadeias bem de(cid:28)nidas. Logo, se as cadeias X e Y sªo bem de(cid:28)nidas, a cadeia XY Ø bem de(cid:28)nida.\nDepois que Pedrinho e Zezinho geraram algumas expressıes matemÆticas, eles perceberam que havia algum erro na primeira fase do gerador. Algumas cadeias nªo eram bem de(cid:28)nidas. Eles querem come(cid:231)ar a resolver as expressıes o mais rÆpido poss(cid:237)vel, e sabendo que vocŒ Ø um (cid:243)timo programador (e participa da OBI) resolveram pedir que escreva um programa que dadas vÆrias cadeias geradas na primeira fase, determine quais delas sªo bem de(cid:28)nidas e quais nªo sªo.\nEntrada\nA entrada Ø composta por diversas inst(cid:226)ncias. A primeira linha da entrada contØm um inteiro T indicando o nœmero de inst(cid:226)ncias. Em seguida temos T linhas, cada uma com uma cadeia A.\nSa(cid:237)da Para cada inst(cid:226)ncia imprima uma linha contendo a letra S se a cadeia Ø bem de(cid:28)nida, ou a letra N caso contrÆrio.\nRestri(cid:231)ıes • 1 ≤ T ≤ 20.\n• a cadeia de caracteres A tem entre 1 e 100000 caracteres.\n• a cadeia de caracteres A contØm apenas caracteres ‘{’, ‘[’, ‘(’, ‘}’, ‘]’ e ‘)’.\nExemplos\nEntrada\nSa(cid:237)da",
    "examples": [
      [
        "12\n()\n[]\n{}\n(]\n}{\n([{}])\n{}()[]\n()]\n{[]\n(\n(([{}{}()[]])(){}){}\n(((((((((({([])}])))))))))",
        "Sa(cid:237)da\nS\nS\nS\nN\nN\nS\nS\nN\nN\nN\nS\nN"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "expressoes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quadrado MÆgico",
    "description": "Arnaldo e Bernardo sªo dois garotos que compartilham um peculiar gosto por curiosidades matemÆticas. Nos œltimos tempos, sua principal diversªo tem sido investigar propriedades matemÆgicas de tabuleiros quadrados preenchidos com inteiros. Recentemente, durante uma aula de matemÆtica, os dois desa(cid:28)aram os outros alunos da classe a criar quadrados mÆgicos, que sªo quadrados preenchidos com nœmeros de 1 a N2, de tal forma que a soma dos N nœmeros em uma linha, coluna ou diagonal principal do quadrado tenham sempre o mesmo valor.\nA ordem de um quadrado mÆgico Ø o seu nœmero de linhas, e o valor do quadrado mÆgico Ø o resultado da soma de uma linha. Um exemplo de quadrado mÆgico de ordem 3 e valor 15 Ø mostrado na (cid:28)gura abaixo:   Para surpresa de Arnaldo e Bernardo, os outros alunos criaram um grande nœmero de quadrados, alguns enormes, e alegaram que todos eram quadrados mÆgicos. Arnaldo e Bernardo agora precisam de sua ajuda, para veri(cid:28)car se os quadrados criados sªo realmente mÆgicos.\nVocŒ deve escrever um programa que, dado um quadrado, veri(cid:28)que se ele Ø realmente mÆgico.\nEntrada\nA primeira linha da entrada contØm um œnico nœmero inteiro N, indicando a ordem do quadrado (seu nœmero de linhas). As N linhas seguintes descrevem o quadrado. Cada uma dessas linhas contØm N nœmeros inteiros separados por um espa(cid:231)o em branco.\nSa(cid:237)da Seu programa deve imprimir uma œnica linha. Caso o quadrado seja mÆgico, a linha deve conter o valor do quadrado (ou seja, a soma de uma de suas linhas). Caso contrÆrio, a linha deve conter o nœmero 0.\nRestri(cid:231)ıes • 3 ≤ N ≤ 1000.\n• 1 ≤ valor de cada cØlula ≤ 109.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 3.\n• Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 100.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "3\n1 1 1\n1 1 1\n1 1 1",
        "Sa(cid:237)da\n0"
      ],
      [
        "4\n16 3 2 13\n5 10 11 8\n9 6 7 12\n4 15 14 1",
        "Sa(cid:237)da\n34"
      ],
      [
        "3\n4 8 9\n11 7 3\n6 5 10",
        "Sa(cid:237)da\n0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "magico"
    },
    "imagesQuant": 0
  },
  {
    "name": "Reduzindo detalhes em um mapa",
    "description": "Leonardo Nascimento Ø um garoto de 13 anos apaixonado por cartogra(cid:28)a. Durante as fØrias de janeiro de 2011, ele alternava seu tempo entre navegar na internet (pesquisando sobre mapas) e arrumar sua cole(cid:231)ªo de mapas.\nNavegando na internet, Leonardo descobriu um site especializado em mapas, o Google Maps. Depois de alguns dias usando o site, Leonardo percebeu que quando diminu(cid:237)a o zoom algumas ruas nªo eram mais exibidas no mapa, isto Ø, o zoom determinava tambØm o n(cid:237)vel de detalhe do mapa. A (cid:28)gura abaixo ilustra um dos testes feito por Leonardo.\nEle sabe que vocŒ participa da OBI e que vocŒ adora resolver os problemas que envolvem mapas. Entªo resolveu formular o seguinte problema: dado um mapa de cidades e rodovias que as ligam, selecione um subconjunto das rodovias tal que entre qualquer par de cidades exista uma rota ligando-as e a soma dos comprimentos das rodovias Ø m(cid:237)nimo. Na (cid:28)gura abaixo e (cid:224) esquerda temos um exemplo com cinco cidades e seis rodovias ligando-as. A (cid:28)gura abaixo e (cid:224) direita ilustra uma solu(cid:231)ªo cuja soma dos comprimentos Ø 34.\n15 1 2 1 2 1 1 10 5 5 10 5 3 4 20 3 4 20 3 3 Para facilitar um pouco sua vida, Leonardo, determinou que vocŒ s(cid:243) precisa dizer a soma dos comprimentos das rodovias do subconjunto selecionado para um dado mapa.\nEntrada\nA primeira linha da entrada contØm dois nœmeros N e M que representam o nœmero de cidades e o nœmero de rodovias respectivamente. Cada uma das pr(cid:243)ximas M linhas Ø composta por trŒs inteiros U,V e C que indiciam que existe uma rodovia de comprimento C que liga as cidades U e V .\nSa(cid:237)da A sa(cid:237)da consiste em apenas uma linha contendo a soma do comprimento das rodovias selecionadas.\nRestri(cid:231)ıes • 1 ≤ N ≤ 500.\n• 1 ≤ M ≤ 124750.\n• 1 ≤ U,V ≤ N e U 6= V .\n• 1 ≤ C ≤ 500.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "5 6\n1 2 15\n1 3 10\n2 3 1\n3 4 3\n2 4 5\n4 5 20",
        "Sa(cid:237)da\n34"
      ],
      [
        "4 6\n1 2 1\n1 3 10\n1 4 1\n2 3 1\n2 4 10\n3 4 1",
        "Sa(cid:237)da\n3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "rmapa"
    },
    "imagesQuant": 2
  },
  {
    "name": "Vira!",
    "description": "Vira! Ø um jogo individual que se inicia com N pe(cid:231)as igualmente espa(cid:231)adas em uma linha. Cada pe(cid:231)a do Vira! possui dois lados, sendo um branco e um preto; assim, ao virar uma pe(cid:231)a, alterna-se a cor que estÆ sendo mostrada entre branco e preto. A (cid:28)gura abaixo ilustra um poss(cid:237)vel arranjo com 5 pe(cid:231)as, duas mostrando o lado branco e duas mostrando o lado preto.\nUm movimento consiste em retirar uma pe(cid:231)a preta (cid:22) criando um espa(cid:231)o (cid:22) e inverter as pe(cid:231)as vizinhas (cid:224) retirada. Sendo assim, dependendo do nœmero de pe(cid:231)as vizinhas (cid:224) retirada, um movimento pode inverter duas, uma, ou mesmo nenhuma pe(cid:231)a (se nªo houver pe(cid:231)as vizinhas (cid:224) que estÆ sendo retirada). VocŒ vence o jogo quando consegue remover todas as pe(cid:231)as. A (cid:28)gura abaixo exempli(cid:28)ca uma sequŒncia de movimentos que resolvem uma inst(cid:226)ncia do problema com 5 pe(cid:231)as, em que as pe(cid:231)as sªo retiradas na ordem 5-2-1-3-4.\n  Para uma determinada disposi(cid:231)ªo inicial das pe(cid:231)as, podem existir vÆrias solu(cid:231)ıes diferentes. Por exemplo, poder(cid:237)amos retirar as pe(cid:231)as na ordem 5-2-3-4-1 e ainda assim conseguir retirar todas as pe(cid:231)as.\nSua tarefa, neste problema, consiste em contar o nœmero de solu(cid:231)ıes diferentes para uma dada disposi(cid:231)ªo inicial das pe(cid:231)as. Como o nœmero de solu(cid:231)ıes pode ser muito grande, vocŒ deve imprimir apenas o resto do nœmero quando dividido por 10007.\nEntrada\nA primeira linha da entrada contØm o inteiro N. A linha seguinte contØm N letras separadas por espa(cid:231)o representando o arranjo inicial das pe(cid:231)as. Uma pe(cid:231)a branca Ø indicada pela letra B na entrada, e uma pe(cid:231)a preta Ø indicada pela letra P.\nSa(cid:237)da Seu programa deve imprimir uma linha contendo o nœmero de solu(cid:231)ıes distintas que resolvem o jogo.\nRestri(cid:231)ıes • 1 ≤ N ≤ 1000.\nInforma(cid:231)ıes sobre a pontua(cid:231)ªo • Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 7.\n• Em um cojunto de casos de teste que totaliza 60 pontos, N ≤ 100.\nExemplos\nEntrada\nSa(cid:237)da   Entrada\nSa(cid:237)da",
    "examples": [
      [
        "5\nB P B P P",
        "Sa(cid:237)da\n15"
      ],
      [
        "3\nB P B",
        "Sa(cid:237)da\n2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2011,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "vira"
    },
    "imagesQuant": 0
  },
  {
    "name": "Busca na Internet",
    "description": "João fez uma pesquisa em seu site de busca predileto, e encontrou a resposta que estava procurando no terceiro link listado. Além disso, ele viu, pelo site, que t pessoas já haviam clicado neste link antes. João havia lido anteriormente, também na Internet, que o número de pessoas que clicam no segundo link listado é o dobro de número de pessoas que clicam no terceiro link listado. Nessa leitura, ele também descobriu que o número de pessoas que clicam no segundo link é a metade do número de pessoas que clicam no primeiro link.\nJoão está intrigado para saber quantas pessoas clicaram no primeiro link da busca, e, como você é amigo dele, quer sua ajuda nesta tarefa.\nEntrada\nCada caso de teste possui apenas um número, t, que representa o número de pessoas que clicaram no terceiro link da busca.\nSaída\nPara cada caso de teste imprima apenas uma linha, contendo apenas um inteiro, indicando quantas pessoas clicaram no primeiro link, nessa busca.\nRestrições\n• 1 ≤ t ≤ 1000 Exemplos",
    "examples": [
      [
        "2",
        "8"
      ],
      [
        "25",
        "100"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "busca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Campeonato",
    "description": "campeonato.py Dois times, Cormengo e Flaminthians, participam de um campeonato de futebol, juntamente com outros times.\nCada vitória conta três pontos, cada empate um ponto. Fica melhor classificado no campeonato um time que tenha mais pontos. Em caso de empate no número de pontos, fica melhor classificado o time que tiver maior saldo de gols. Se o número de pontos e o saldo de gols forem os mesmos para os dois times então os dois times estão empatados no campeonato.\nDados os números de vitórias e empates, e os saldos de gols dos dois times, sua tarefa é determinar qual dos dois está melhor classificado, ou se eles estão empatados no campeonato.\nEntrada\nA entrada é descrita em uma única linha, que contém seis inteiros, separados por um espaço em branco: Cv,Ce,Cs,Fv,Fe,Fs, que são, respectivamente, o número de vitórias do Cormengo, o número de empates do Cormengo, o saldo de gols do Cormengo, o número de vitórias do Flaminthians, o número de empates do Flaminthians e o saldo de gols do Flaminthians.\nSaída\nSeu programa deve imprimir uma única linha. Se Cormengo é melhor classificado que Flaminthians, a linha deve conter apenas a letra ‘C’; se Flaminthians é melhor classificado que Cormengo, a linha deve conter apenas a letra ‘F’; e se os dois times estão empatados a linha deve conter apenas o caractere ‘=’.\nRestrições\n• 0 ≤ Cv,Ce,Fv,Fe ≤ 100 • −1000 ≤ Cs,Fs ≤ 1000 Exemplos",
    "examples": [
      [
        "10 5 18 11 1 18",
        "C"
      ],
      [
        "10 5 18 11 2 18",
        "="
      ],
      [
        "9 5 -1 10 2 10",
        "F"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "campeonato"
    },
    "imagesQuant": 0
  },
  {
    "name": "Desafio do maior número",
    "description": "Leonardo é um garoto muito criativo. Ele adora criar desafios para seus colegas da escola. Seu último desafio é o seguinte: diversos números são ditos em voz alta, quando o número 0 (zero) é dito então o desafio termina e seus colegas devem dizer imediatamente qual foi o maior número. Leonardo tem muita dificuldade de verificar se a resposta dada pelos colegas é correta ou não, pois a sequência de números costuma ser longa. Por este motivo, ele resolveu pedir sua ajuda.\nSua tarefa é escrever um programa que dada uma sequência de números inteiros positivos terminada por 0 (zero), imprime o maior número da sequência.\nEntrada\nA entrada é dada em uma única linha contendo uma sequência de números inteiros positivos. O último número da linha é 0 (zero).\nSaída\nSeu programa deve imprimir o maior número dentre os números da entrada.\nRestrições\n• 1 ≤ tamanho da sequência ≤ 100.\n• 1 ≤ número da sequência ≤ 1000.\nExemplos",
    "examples": [
      [
        "10 30 20 5 0",
        "30"
      ],
      [
        "99 1000 55 1 2 9 0",
        "1000"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "maior"
    },
    "imagesQuant": 0
  },
  {
    "name": "Corrida",
    "description": "Leonardo é um corredor profissional que participa de diversos campeonatos de atletismo pelo mundo. O tamanho das pistas ao redor do mundo não é padronizado. Por isso, Leonardo, que treina em um clube que possui uma pista circular, resolveu fixar seu treinamento em C metros, ao invés de um número fixo de voltas na pista. Após cada treinamento, Leonardo deve tomar meio litro de água antes de fazer qualquer esforço, e por isso quer deixar sua garrafa de água exatamente no ponto da pista onde ele termina o seu treinamento.\nSabendo o comprimento da pista de corrida que Leonardo pretende treinar, ele resolveu pedir sua ajuda para calcular o local do ponto de término do treinamento. O ponto de término é o local da pista onde ele termina o percurso de C metros considerando que ele parte do ponto de partida e se movimenta sempre na mesma direção.\nO ponto de término é dado pelo número de metros entre o ponto de partida e o local onde Leonardo termina seu treinamento, contados na direção do percurso. Leonardo quer deixar sua garrafa de água neste ponto.\nPor exemplo, se a pista tem 12 metros e Leonardo fixou seu treinamento em 22 metros, o ponto de término é 10.\nSua tarefa é, dado o número C de metros que Leonardo pretende correr e o comprimento N em metros da pista circular, determinar o ponto de término de seu treinamento.\nEntrada\nA entrada consiste em apenas uma linha contendo dois inteiros C e N que indicam, respectivamente, o número de metros que Leonardo pretende correr e o comprimento da pista.\nSaída\nSeu programa deve imprimir apenas uma linha, contendo apenas um inteiro, indicando o ponto de término do treinamento de Leonardo.\nRestrições\n• 1 ≤ C ≤ 108 • 1 ≤ N ≤ 100 Exemplos",
    "examples": [
      [
        "7000 100",
        "0"
      ],
      [
        "918 76",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "corrida"
    },
    "imagesQuant": 0
  },
  {
    "name": "Consecutivos",
    "description": "Num sorteio que distribui prêmios, um participante inicialmente sorteia um inteiro N e depois N valores. O número de pontos do participante é o tamanho da maior sequência de valores consecutivos iguais. Por exemplo, suponhamos que um participante sorteia N = 11 e, nesta ordem, os valores 30,30,30,30,40,40,40,40,40,30,30 Então, o participante ganha 5 pontos, correspondentes aos 5 valores 40 consecutivos. Note que o participante sorteou 6 valores iguais a 30, mas nem todos são consecutivos.\nSua tarefa é ajudar a organização do evento, escrevendo um programa que determina o número de pontos de um participante.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de valores sorteados. A segunda linha contém N valores, V1,V2,...,VN, na ordem de sorteio, separados por um espaço em branco.\nSaída\nSeu programa deve imprimir apenas uma linha, contendo apenas um inteiro, indicando o número de pontos do participante.\nRestrições\n• 1 ≤ N ≤ 104 • −231 ≤ VI ≤ 231 − 1, para I = 1,2,...,N Exemplos",
    "examples": [
      [
        "11\n30 30 30 40 40 40 40 40 30 30 30",
        "5"
      ],
      [
        "14\n1 1 1 20 20 20 20 3 3 3 3 3 3 3",
        "7"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "iguais"
    },
    "imagesQuant": 0
  },
  {
    "name": "Vice-campeão",
    "description": "A OBI (Organização de Bocha Internacional) é responsável por organizar a competição mundial de bocha.\nInfelizmente esse esporte não é muito popular, e numa tentativa de aumentar a sua popularidade, ficou decidido que seriam chamados, para a Grande Final Mundial, o campeão e o vice-campeão de cada sede nacional, ao invés de apenas o primeiro lugar.\nTumbólia é um país pequeno que já havia realizado a sua competição nacional quando a nova regra foi instituída, e o comitê local não armazenou quem foi o segundo classificado. Felizmente eles armazenaram a pontuação de todos competidores – que foram apenas três, devido ao tamanho diminuto do país. Sabe-se também que as pontuações de todos jogadores foram diferentes, de forma que não ocorreu empate entre nenhum deles.\nResta agora descobrir quem foi o vice-campeão e para isso o comitê precisa de ajuda.\nEntrada\nA primeira e única linha da entrada consiste de três inteiros separados por espaços, A, B e C, as pontuações dos 3 competidores.\nSaída\nImprima uma única linha na saída, contendo apenas um número inteiro, a pontuação do vice-campeão.\nRestrições\n• 1 ≤ A ≤ 100 • 1 ≤ B ≤ 100 • 1 ≤ C ≤ 100 Exemplos",
    "examples": [
      [
        "4 5 6",
        "5"
      ],
      [
        "10 5 9",
        "9"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "vice"
    },
    "imagesQuant": 0
  },
  {
    "name": "O Tabuleiro Esburacado",
    "description": "Um tabuleiro normal, 8 x 8, foi danificado, e 4 posições ficaram esburacadas. A Figura 1(a) mostra o tabuleiro.\nA posição inferior esquerda tem coordenadas ( , ). Os 4 buracos estão marcados em preto, e têm coordenadas (1,3), (2,3), (2,5) e (5,4). Um cavalo de xadrez foi colocado na posição (4,3), marcada como   no tabuleiro.\n8 1 7 2     6 3 5 4 (a) (b) Os 8 movimentos de um cavalo estão numerados de 1 a 8 na Figura 1(b), a partir da posição marcada como  .\nPor exemplo, se o cavalo estiver na posição inicial (4,3), o movimento 7 leva o cavalo à posição (2,4), sem cair no buraco (2,3), porque o cavalo salta da posição (4,3) para a posição (2,4).\nSeu problema é simular um passeio do cavalo, dados os movimentos através dos números de 1 a 8 e determinar quantos movimentos o cavalo faz até ou (i) terminar o passeio ou (ii) cair em um buraco. Por exemplo, na trajetória dada pelos 5 movimentos 1,8,5,3,4, o cavalo passa pelas posições (5,5), (4,7), (3,5) e cai no buraco (5,4), fazendo portanto apenas 4 movimentos.\nJá no passeio dado pelos 3 movimentos 6,8,1, o cavalo passa pelas posições (2,2), (1,4) e (2,6) e não cai em nenhum buraco: portanto, perfaz todos os 3 movimentos do passeio.\nEntrada\nA primeira linha da entrada contém N, o número de movimentos do passeio. A segunda linha contém N inteiros M1,M2,...,MN, separados por um espaço em branco, correspondentes aos N movimentos do cavalo no passeio.\nUm movimento pode levar o cavalo a cair em um buraco, mas nunca leva o cavalo a sair do tabuleiro.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único número inteiro, o número de movimentos do cavalo até terminar o passeio ou o cavalo cair em um buraco.\nRestrições\n• 1 ≤ N ≤ 1   • 1 ≤ MI ≤ 8, para I = 1,2,...,N.\nExemplos",
    "examples": [
      [
        "5\n1 8 5 3 4",
        "4"
      ],
      [
        "3\n6 8 1",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cavalo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Colchão",
    "description": "João está comprando móveis novos para sua casa. Agora é a vez de comprar um colchão novo, de molas, para substituir o colchão velho. As portas de sua casa têm altura H e largura L e existe um colchão que está em promoção com dimensões A × B × C.\nO colchão tem a forma de um paralelepípedo reto retângulo e João só consegue arrastá-lo através de uma porta com uma de suas faces paralelas ao chão, mas consegue virar e rotacionar o colchão antes de passar pela porta.\nEntretanto, de nada adianta ele comprar o colchão se ele não passar através das portas de sua casa. Portanto ele quer saber se consegue passar o colchão pelas portas e para isso precisa de sua ajuda.\nEntrada\nA primeira linha da entrada contém três números inteiros A, B e C, as três dimensões do colchão, em centímetros.\nA segunda linha contém dois inteiros H e L, respectivamente a altura e a largura das portas em centímetros.\nSaída\nSe programa deve escrever uma única linha, contendo apenas a letra ‘S’ se o colchão passa pelas portas e apenas a letra ‘N’ em caso contrário.\nRestrições\n• 1 ≤ A,B,C ≤ 300 • 1 ≤ H,L ≤ 250 Exemplos",
    "examples": [
      [
        "25 120 220\n200 100",
        "S"
      ],
      [
        "25 205 220\n200 100",
        "N"
      ],
      [
        "25 200 220\n200 100",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "colchao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Frequencia na aula",
    "description": "frequencia.py Certa vez, numa aula, a professora passou um filme para os alunos assistirem. Durante este filme, ela passou uma lista de presença em sua sala para verificar a presença dos alunos, onde cada aluno deveria inserir apenas seu número de registro. Alguns alunos contudo, como possuem amigos que fogem da aula, decidiram ser camaradas e inseriram os números de registro de seus amigos fujões. O problema é que muitos alunos são amigos de alunos que fogem da aula e alguns números de registro acabaram sendo repetidamente inseridos na lista de presença.\nAlém de tudo, alguns dos alunos que se esperava que não estivessem na aula de fato estavam! A professora, ao notar que a lista de presença continha alguns números repetidos, ficou sem entender, mas decidiu dar um voto de confiança e dar presença a todos os alunos cujos números de registro estavam na lista.\nComo são muitos alunos na sala e muitos números com repetição, ela pediu a sua ajuda para determinar o total de alunos que receberam presença na aula.\nEntrada\nA primeira linha da entrada contém um número inteiro N, que informa a quantidade de números de registro que apareceram na lista de presença. Cada uma das N linhas seguintes contém um número de registro Vi que foi inserido na lista de presença.\nSaída\nSeu programa deve imprimir uma única linha, contendo apenas um número inteiro, o número de alunos que receberam presença.\nRestrições\n• 1 ≤ N ≤ 105 • Para cada elemento Vi, 0 ≤ Vi ≤ 106 Informações sobre pontuação • Em um conjunto de casos que totaliza 40 pontos, N ≤ 103 e Vi ≤ 103 Exemplos",
    "examples": [
      [
        "3\n2\n3\n1",
        "3"
      ],
      [
        "7\n0\n5\n12\n41\n7\n5\n41",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "frequencia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tarzan",
    "description": "Tarzan vive na floresta e é o responsável por manter a ordem na região onde vive. Para locomover-se entre as árvores ele só usa cipós pois esse é um meio de transporte muito mais rápido e seguro do que andar no chão da selva, além de, é claro, poder soltar seu grito característico enquanto viaja.\nOs cipós das árvores têm todos o mesmo alcance. Dessa forma, é possível viajar de cipó de uma árvore para outra se a distância entre elas é no máximo D, onde D é o alcance dos cipós.\nRecentemente uma forte chuva assolou a região e derrubou algumas árvores, restando na floresta apenas N árvores. Agora Tarzan quer saber se ele consegue viajar de cipó entre todas árvores remanescentes para poder continuar mantendo a ordem na região.\nPara poder manter a ordem ele precisa ser capaz de, partindo de qualquer uma das árvores, poder chegar a todas as outras árvores remanescentes, possivelmente passando por outras árvores no caminho, sempre utilizando somente cipós.\nEntrada\nA primeira linha da entrada contém dois inteiros, N e D, indicando respectivamente o número de árvores remanescentes e o alcance dos cipós. Cada uma das N linhas seguintes contém dois inteiros Xi e Yi, as coordenadas da i-ésima árvore. Não existem duas árvores com as mesmas coordenadas.\nSaída\nSeu programa deve escrever uma única linha, contendo um único caractere: ‘S’ se Tarzan consegue viajar de cipó entre todas as árvores remanescentes, e ‘N’ caso contrário.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 30 pontos, N ≤ 10 • Em um conjunto de casos de teste que totaliza 70 pontos, N ≤ 100 Restrições\n• 2 ≤ N ≤ 1000 • 1 ≤ D ≤ 5000 • 0 ≤ Xi,Yi ≤ 5000 Exemplos",
    "examples": [
      [
        "4 5\n1 1\n6 1\n6 6\n11 6",
        "S"
      ],
      [
        "4 5\n1 1\n6 6\n11 6\n13 8",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tarzan"
    },
    "imagesQuant": 0
  },
  {
    "name": "Receita de Bolo",
    "description": "João deseja fazer bolos para seus amigos, usando uma receita que indica que devem ser usadas 2 xícaras de farinha de trigo, 3 ovos e 5 colheres de sopa de leite. Em casa ele tem A xícaras de farinha de trigo, B ovos e C colheres de sopa de leite.\nJoão não tem muita prática com a cozinha, e portanto ele só se arriscará a fazer medidas exatas da receita de bolo (por exemplo, se ele tiver material suficiente para fazer mais do que 2 e menos do que 3 bolos, ele fará somente 2 bolos). Sabendo disto, ajude João escrevendo um programa que determine qual a quantidade máxima de bolos que ele consegue fazer.\nEntrada\nA entrada é dada em uma única linha, que contém três números inteiros A, B e C, indicando respectivamente o número de xícaras de farinha de trigo, o número de ovos e o número de colheres de sopa de leite que João tem em casa.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, a quantidade máxima de bolos que João consegue fazer.\nRestrições\n• 1 ≤ A ≤ 100 • 1 ≤ B ≤ 100 • 1 ≤ C ≤ 100 Exemplos",
    "examples": [
      [
        "4 6 10",
        "2"
      ],
      [
        "4 6 9",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bolo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chocolate",
    "description": "Por lei, na Nlogônia todas as barras de chocolate são quadradas. Anamaria tem uma barra quadrada de chocolate de lado L, que ela quer compartilhar com alguns colegas da obi. Mas ela é uma boa cidadã e cumpre a lei.\nEntão, ela divide a barra em quatro pedaços quadrados, de lado L/2. Depois, ela repete esse procedimento com cada pedaço gerado, sucessivamente, enquanto o lado for maior do que, ou igual a 2cm. Você deve escrever um programa que, dado o lado L da barra inicial, em centímetros, determina quantos pedaços haverá ao final do processo.\nEntrada\nA entrada consiste de uma linha, com um único inteiro, L, o número de centímetros do lado do quadrado.\nSaída\nSe programa deve imprimir uma única linha, contendo um único inteiro, igual ao número total de pedaços obtidos pela Anamaria.\nRestrições\n• 2 ≤ L ≤ 104 Informações sobre a pontuação\nEm um conjunto de casos de teste totalizando 30 pontos, L < 64.\nExemplos",
    "examples": [
      [
        "4",
        "16"
      ],
      [
        "9",
        "64"
      ],
      [
        "2",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chocolate"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tira-teima",
    "description": "Uma quadra de tênis tem o formato de um retângulo, cujos lados medem 36 pés por 78 pés, que correspondem a um retângulo de 432 polegadas por 936 polegadas. No último Grand Slam da Austrália, Rafael Nadal perdeu para Novak Djoković, num dos jogos mais bonitos de tênis dos últimos tempos.\nMuitas vezes, uma jogada é tão rápida, e a bola tão próxima da borda da quadra, que o juiz pode tomar uma decisão que pode ser contestada por um dos jogadores. Para isso, existe o tira-teima, que utiliza a imagem gravada do jogo para decidir se a bola estava dentro ou fora da metade da quadra correspondente a um dos jogadores.\nConsidere que a semi-quadra de Rafael Nadal corresponde a um retângulo em que dois vértices têm coordenadas (0,0) e (432, 468), onde todos os números são em polegadas.\nVocê deve escrever um programa para, dadas as coordenadas (X,Y ) do ponto de contato da bola com o solo, determinar se uma bola bateu no solo dentro ou fora da semi-quadra. Note que se a bola bate na linha divisória ela é considerada uma bola dentro.\nEntrada\nA entrada é dada em uma única linha, que contém dois inteiros X e Y , que correspondem às coordenadas do ponto (X,Y ) de contato da bola com o solo, em polegadas.\nSaída\nSeu programa deve imprimir uma única linha, contendo a palavra dentro se a bola bateu dentro da semi-quadra, e a palavra fora caso contrário.\nRestrições\n• −500 ≤ X,Y ≤ 500 Exemplos",
    "examples": [
      [
        "-2 200",
        "fora"
      ],
      [
        "432 10",
        "dentro"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tenis"
    },
    "imagesQuant": 0
  },
  {
    "name": "Carnaval",
    "description": "O Carnaval é um feriado celebrado normalmente em fevereiro; em muitas cidades brasileiras, a principal atração são os desfiles de escolas de samba. As várias agremiações desfilam ao som de seus sambas-enredos e são julgadas pela liga das escolas de samba para determinar a campeã do Carnaval.\nCada agremiação é avaliada em vários quesitos; em cada quesito, cada escola recebe cinco notas que variam de 5,0 a 10,0. A nota final da escola em um dado quesito é a soma das três notas centrais recebidas pela escola, excluindo a maior e a menor das cinco notas.\nComo existem muitas escolas de samba e muitos quesitos, o presidente da liga pediu que você escrevesse um programa que, dadas as notas da agremiação, calcula a sua nota final num dado quesito.\nEntrada\nA entrada contém uma única linha, contendo cinco números Ni (1 ≤ i ≤ 5), todos com uma casa decimal, indicando as notas recebidas pela agremiação em um dos quesitos.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único número com exatamente uma casa decimal, a nota final da escola de samba no quesito considerado.\nRestrições\n• 5.0 ≤ Ni ≤ 10.0 Exemplos",
    "examples": [
      [
        "6.4 8.2 8.2 7.4 9.1",
        "23.8"
      ],
      [
        "10.0 10.0 5.0 5.0 10.0",
        "25.0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "carnaval"
    },
    "imagesQuant": 0
  },
  {
    "name": "Costa",
    "description": "A Nlogônia é um país tropical, com muitas belezas naturais internacionalmente famosas; dentre elas, encontramse as belas praias que compõem o arquipélago do país, que todo verão recebem milhões de turistas estrangeiros.\nO Ministério do Turismo da Nlogônia está preparando o país para a chegada dos turistas, mas para fazer seu planejamento, precisa saber a extensão da costa nlogônica. Para isso, ele gerou um mapa que divide o território nacional em vários quadrados, que podem ser ocupados por água ou por terra; considera-se que um quadrado é parte da costa nlogônica se ele é um quadrado ocupado por terra que tem um lado em comum com um quadrado ocupado por água.\nNa figura abaixo, (a) mostra um trecho do mapa gerado e (b) mostra os quadrados do trecho dado que são costa.\nTerra Costa Mar (a) (b) Como a Nlogônia é um país muito grande, o ministro do turismo pediu que você escrevesse um programa que, dado o mapa da Nlogônia, determina a extensão da costa nlogônica.\nEntrada\nA primeira linha da entrada contém dois inteiros M e N indicando, respectivamente, o número de linhas e o número de colunas do mapa. Cada uma das M linhas seguintes contém N caracteres: um caractere ‘.’ indica que aquele quadrado do território é ocupada por água; um caractere ‘#’ indica que aquele quadrado do território é ocupada por terra.\nConsidere que todo o espaço fora da área do mapa é ocupado por água.\nSaída\nSeu programa deve imprimir uma única linha contendo um único inteiro, indicando quantos quadrados do território fazem parte da costa da Nlogônia.\nRestrições\n• 1 ≤ M,N ≤ 1000 Exemplos",
    "examples": [
      [
        "5 5\n.....\n..#..\n.###.\n..#..\n.....",
        "4"
      ],
      [
        "10 10\n..........\n.....###..\n....#####.\n.#...##...\n..........\n.......##.\n.##.......\n..##......\n..###.....\n..#####...",
        "22"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "costa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Guerra por território",
    "description": "Tombólia do Oeste e Tombólia do Leste travaram uma guerra durante 50 anos. O motivo da guerra era o tamanho do território de cada país. Pelo bem da população dos dois países, os governos resolveram fazer um tratado para finalizar a guerra. O tratado consiste em fazer um divisão justa, e certamente contínua, do território. Eles resolveram pedir sua ajuda para calcular o ponto de divisão do território. Depois de tantos anos de guerra, os países não podem lhe pagar uma viagem para ver previamente o território que será dividido.\nAo invés disso, eles prepararam uma lista a1,a2,...,aN de inteiros que indicam o tamanho de cada seção do território. A seção a1 é vizinha da seção a2 que por sua vez é vizinha da seção a3 e assim por diante. Os governos querem uma divisão em uma seção k de tal forma que a1 + a2 + ··· + ak = ak+1 + ak+2 + ··· + aN.\nSua tarefa é dada uma lista de inteiros positivos a1,a2,...,aN, determinar a seção k tal que soma dos comprimentos das seções a1 até ak é igual a soma dos comprimentos das seções ak+1 até aN.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de seções do território. A segunda linha da entrada contém N inteiros a1,a2,...,aN separados por um único espaço que indicam os comprimentos das seções.\nSaída\nSeu programa deve imprimir uma única linha contendo um inteiro que indica a seção do território onde acontecerá a divisão.\nNota: é garantido que sempre existe uma divisão que satisfaz as condições dos países.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste que totaliza 50 pontos, N ≤ 1000.\nRestrições\n• 1 ≤ N ≤ 105.\n• 1 ≤ ai ≤ 100, para i = 1,2,...,N.\nExemplos",
    "examples": [
      [
        "4\n5 3 2 10",
        "3"
      ],
      [
        "9\n2 8 2 8 4 4 4 4 4",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "guerra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Álbum de fotos",
    "description": "Clara está organizando as fotos da sua última viagem num álbum de fotos. Como ela tem muitas fotos, para economizar páginas do álbum ela quer colar duas fotos por página do álbum.\nComo as fotos são retangulares, as fotos podem ser coladas giradas (mas sempre com lados paralelos aos da página do álbum, para preservar o equilíbrio estético do álbum), mas elas devem sempre ficar inteiramente contidas no interior da página, e não devem se sobrepor.\nEm geral, das muitas formas de posicionar as fotos do álbum só algumas (ou nenhuma) satisfazem estas restrições, então pode ser difícil decidir se é possível colar as duas fotos em uma mesma página do álbum, e por isso Clara pediu a sua ajuda para escrever um programa que, dadas as dimensões da página e das fotos, decide se é possível colar as fotos na página.\nPor exemplo, cada página pode ser   ×  , e duas fotos são 3 × 4. Nesse caso, é possível colar as duas fotos:   4 3   4 3 Entrada\nA primeira linha da entrada contém dois inteiros X e Y , indicando a largura e a altura da página do álbum.\nCada uma das duas linhas seguintes contém dois inteiros L e H, indicando a largura e a altura das fotos.\nSaída\nImprima uma única linha, contendo um único caractere: ‘S’, se é possível colar as duas fotos na página do álbum, e ‘N’, caso contrário.\nRestrições\n• 1 ≤ X,Y ≤ 1000 • 1 ≤ L,H ≤ 1000 Exemplos\nEntrada\nSaída\nS 3 4 3 4   Entrada\nSaída\n13 8 N 4 9 6",
    "examples": [
      [
        "7 5\n3 4\n3 4",
        "S"
      ],
      [
        "10 10\n6 6\n6 6",
        "N"
      ],
      [
        "13 8\n4 9\n6 5",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "album"
    },
    "imagesQuant": 0
  },
  {
    "name": "Banco",
    "description": "A legislação em vigor obriga os bancos a iniciarem o atendimento a um cliente em no máximo 20 minutos após a entrada do cliente na fila única da agência bancária. A fila é única, assim um caixa livre solicita ao primeiro cliente da fila que venha ao seu guichê para ser atendido. (Vamos ignorar aqui o problema dos clientes prioritários, idosos, gestantes, portadores de necessidades especiais, etc.) Estamos supondo também que nenhum caixa atende dois clientes ao mesmo tempo.\nSeu programa receberá o número de caixas ativas na agência, o número de clientes e, para cada cliente, duas informações, a saber, o momento de entrada do cliente na fila, e a duração do atendimento daquele cliente.\nInicialmente todos os caixas estão vazios, já que a agência acabou de abrir.\nSeu problema é determinar o número de clientes que esperarão mais de 20 minutos para ter seu atendimento iniciado.\nEntrada\nA primeira linha da entrada contém dois inteiros separados por um espaço em branco. O primeiro, C, é o número de caixas ativas na agência bancária. O segundo, N, o número de clientes que procurarão atendimento na agência naquele dia.\nAs próximas N linhas terão cada uma informações sobre um cliente, consistindo de dois inteiros, T e D, separados por um espaço em branco. O inteiro T fornece o momento em que o cliente entra na fila, em minutos, a partir do instante de abertura da agência. O inteiro D fornece, em minutos, o tempo necessário para atender o cliente.\nAs linhas estão ordenadas por entrada dos clientes na fila.\nSaída\nA saída deverá conter apenas uma linha, contendo um único inteiro, o número de clientes cujo atendimento será iniciado mais do que 20 minutos após sua entrada na fila.\nRestrições\n• 1 ≤ C ≤ 10 • 1 ≤ N ≤ 1000 • 0 ≤ T ≤ 300 • 1 ≤ D ≤ 10 Exemplos",
    "examples": [
      [
        "1 5\n0 10\n0 10\n1 10\n2 10\n30 10",
        "1"
      ],
      [
        "3 16\n0 10\n0 10\n0 10\n3 10\n5 10\n7 10\n11 10\n13 10\n14 10\n15 10\n16 10\n17 10\n18 3\n19 10\n20 10\n23 3",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "banco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bomba",
    "description": "Um terrorista internacional telefonou avisando que há uma bomba a bordo de um dos diversos ônibus interestaduais da Nlogônia. Essa bomba explodirá se, por qualquer motivo, o ônibus for obrigado a parar. O esquadrão anti-bombas já se posicionou na estrada para desarmar a bomba em movimento, mas o ônibus está prestes a entrar na capital da Nlogônia, Nlogópolis, e precisa sair de lá para o esquadrão poder desarmar o artefato. Por questões de segurança, o esquadrão anti-bombas somente pode desarmar o artefato fora da capital.\nNo projeto urbano de Nlogópolis, todas as interseções consistem de rotatórias, de forma que os veículos nunca precisam parar nas interseções. Em compensação, toda rua (que tem mão única e sempre liga duas rotatórias) possui uma faixa de pedestres com um semáforo; enquanto alguns semáforos abrem nos minutos múltiplos de 3 e fecham nos demais, outros fecham nos minutos múltiplos de 3 e abrem nos demais. Todas as ruas de Nlogópolis foram projetadas de tal forma que sempre levam exatamente um minuto para serem percorridas.\nO ônibus vai entrar em Nlogópolis exatamente meio-dia em ponto em uma das rotatórias, e deve sair por outra rotatória específica para encontrar o esquadrão anti-bombas na estrada. O comandante da polícia local lhe pediu que escreva um programa que determina o menor tempo necessário para que o ônibus saia da cidade, pela rotatória específica de saída. Note que o ônibus pode ser forçado a parar em um semáforo, por falta de alternativas adequadas, e nesse caso a bomba explodirá. Ele também pode ficar circulando indefinidamente pela cidade, e nesse caso eventualmente terá que parar por falta de combustível (e a bomba explodirá).\nEntrada\nA primeira linha da entrada contém quatro inteiros N, E, S, M, indicando, respectivamente, o número de rotatórias (numeradas de 0 a N − 1), o número da rotatória de entrada do ônibus, o número da rotatória de saída do ônibus e o número de ruas da cidade.\nCada uma das M linhas seguintes contém três inteiros A, B e T, indicando respectivamente a rotatória de origem da rua, a rotatória de destino da rua e a temporização do semáforo daquela rua: T = 1 se o semáforo daquela rua abre nos minutos múltiplos de 3, e T = 0 se o semáforo daquela rua fecha nos minutos múltiplos de 3.\nSaída\nImprima uma única linha contendo um único número inteiro, o menor tempo necessário em minutos para que o ônibus saia da cidade ileso. Se for impossível evitar a explosão do ônibus, imprima uma única linha contendo o caractere ‘*’.\nRestrições\n• 2 ≤ N ≤ 500 • 1 ≤ M ≤ 2000 • 0 ≤ E,S ≤ N − 1 • pode haver até duas ruas de uma rotatória A para outra B (possivelmente igual a A), mas no caso de haver duas ruas, então numa o semáforo abre nos minutos múltiplos de 3, na outra o semáforo fecha nos minutos múltiplos de 3.\nExemplos",
    "examples": [
      [
        "6 5 4 7\n0 1 0\n1 2 0\n1 2 1\n2 3 1\n2 4 0\n3 0 0\n5 0 1",
        "8"
      ],
      [
        "4 0 3 4\n0 1 1\n1 2 0\n2 3 1\n2 0 0",
        "*"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bomba"
    },
    "imagesQuant": 0
  },
  {
    "name": "Soma das casas",
    "description": "Joãozinho mora em uma rua que tem N casas. Marquinhos é o melhor amigo dele, mas sempre gosta de pregar peças em Joãozinho. Desta vez, ele pegou os dois brinquedos prediletos de Joãozinho e os escondeu em duas casas distintas da rua. Em compensação, Marquinhos deu uma dica importante para Joãozinho: A soma dos números das casas em que escondi teus brinquedos é igual a K. Além disso, escolhi as casas de tal forma que não existe outro par de casas cuja soma tenha esse mesmo valor.\nSabendo disto, encontre qual é o par de casas em que se encontram os brinquedos de Joãozinho. Para auxiliar seu amigo, Marquinhos entregou a Joãozinho uma lista com o número das casas já em ordem crescente (isto é, do menor para o maior número).\nEntrada\nA primeira primeira linha da entrada contém um número inteiro N, que representa o número de casas que existem na rua. Cada uma das N linhas seguintes contém um número inteiro, representando o número de uma casa. Note que esses N números estão ordenados, do menor para o maior. A última linha da entrada contém um inteiro K, que é a soma dos números das duas casas onde os brinquedos estão escondidos.\nSaída\nSe programa deve imprimir uma única linha, contendo dois inteiros, A e B, A < B, que representam os números das casas em que estão escondidos os brinquedos. Os dois números devem ser separados por um espaço em branco.\nInformações sobre a pontuação\n• Em um conjunto de casos que totaliza 30 pontos, N ≤ 103.\nRestrições\n• 2 ≤ N ≤ 105 • Para cada casa Ci, 0 ≤ Ci ≤ 109, i = 1,2,...,N • Os números das casas estão em ordem crescente, do menor para o maior número, e casas distintas têm números distintos.\nExemplos",
    "examples": [
      [
        "4\n1\n2\n3\n5\n8",
        "3 5"
      ],
      [
        "4\n1\n2\n3\n5\n5",
        "2 3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2012,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "soma"
    },
    "imagesQuant": 0
  },
  {
    "name": "Capital",
    "description": "O governo do estado de Queensland está com problemas sérios de trânsito na capital Brisbane, onde estão os prédios administrativos. Para desafogar o trânsito, o prefeito de Brisbane e o governador de Queensland decidiram que uma nova capital administrativa deve ser construída em uma área fora de Brisbane. Para projetar a nova capital, o renomado arquiteto minimalista Joe Bloggs foi contratado.\nBloggs foi informado de que o terreno destinado à nova capital ainda não foi demarcado, mas será retangular.\nAlém disso, a cidade deverá ser dividida em quatro zonas, uma delas destinada a uma reserva ambiental e cada uma das outras três receberá os novos prédios de cada um dos três poderes (Executivo, Legislativo e Judiciário). Em um arroubo de criatividade, Bloggs decidiu que duas avenidas, perpendiculares entre si, cada uma paralela a dois dos lados do terreno retangular, dividirão a capital nas quatro zonas.\nBloggs recebeu do governo as áreas de cada uma das zonas e, após muito esforço, encontrou um retângulo que pode ser dividido conforme seus planos e de forma a respeitar as áreas delimitadas. No entanto, a Fundação de Conservação dos Cangurus determinou que a área destinada à reserva ambiental era muito pequena, o que obrigou o governo a alterar as áreas das quatro zonas. Após receber as novas medidas, Bloggs tentou encontrar um novo retângulo que viabilizasse seu projeto, porém sem sucesso. Cansado de fazer testes, ele pensou que talvez tenha que abandonar sua brilhante ideia. Por isso, ele pediu para você escrever um programa que, dadas as áreas das quatro zonas, determine se ele poderá ou não manter seu projeto (ou seja, se existe um retângulo que possa ser dividido por duas retas perpendiculares, cada uma paralela a dois dos lados do retângulo, tal que as quatro áreas formadas obedeçam às exigências do governo).\nEntrada\nA entrada consiste de uma única linha contendo quatro inteiros A1, A2, A3, A4, indicando a área de casa uma das zonas.\nSaída\nImprima uma única linha contendo um único caractere: ‘S’ se Bloggs pode preservar seu projeto e ‘N’ caso contrário.\nRestrições\n• 1 ≤ Ai ≤ 104 Exemplos",
    "examples": [
      [
        "1 2 4 8",
        "S"
      ],
      [
        "1 2 3 4",
        "N"
      ],
      [
        "15 14 6 35",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "capital"
    },
    "imagesQuant": 0
  },
  {
    "name": "Saldo do Vovô",
    "description": "Vovô João tem uma banca de jornais; ele tem muitos clientes, e diariamente recebe muito dinheiro, mas também faz muitos pagamentos para manter o seu estoque de jornais e revistas. Todo dia ele vai ao banco realizar um depósito ou uma retirada de dinheiro. Em alguns dias, o saldo de sua conta no banco fica negativo, mas Vovô João tem um acordo com o banco que garante que ele somente é cobrado se o saldo for menor do que um valor pré-estabelecido.\nDada a movimentação diária da conta do banco do Vovô João, você deve escrever um programa que calcule o menor saldo da conta, no período dado.\nEntrada\nA primeira linha da entrada contém dois números inteiros N e S que indicam respectivamente o número de dias do período de interesse e o saldo da conta no início do período. Cada uma das N linhas seguintes contém um número inteiro indicando a movimentação de um dia (valor positivo no caso de depósito, valor negativo no caso de retirada). A movimentação é dada para um período de N dias consecutivos: a primeira das N linhas corresponde ao primeiro dia do período de interesse, a segunda linha corresponde ao segundo dia, e assim por diante.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único número inteiro, o menor valor de saldo da conta no período dado.\nRestrições\n• 1 ≤ N ≤ 30 • −103 ≤ S ≤ 103 • −103 ≤ cada movimentação ≤ 103 Exemplos",
    "examples": [
      [
        "3 1000\n100\n-800\n50",
        "300"
      ],
      [
        "6 -200\n-100\n1000\n-2000\n100\n-50\n2000",
        "-1300"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "saldo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tomadas",
    "description": "A Olimpíada Internacional de Informática (IOI, no original em inglês) é a mais prestigiada competição de programação para alunos de ensino médio; seus aproximadamente 300 competidores se reúnem em um país diferente todo ano para os dois dias de prova da competição. Naturalmente, os competidores usamo o tempo livre para acessar a Internet, programar e jogar em seus notebooks, mas eles se depararam com um problema: o saguão do hotel só tem uma tomada.\nFelizmente, os quatro competidores da equipe brasileira da IOI trouxeram cada um uma régua de tomadas, permitindo assim ligar vários notebooks em uma tomada só; eles também podem ligar uma régua em outra para aumentar ainda mais o número de tomadas disponíveis. No entanto, como as réguas têm muitas tomadas, eles pediram para você escrever um programa que, dado o número de tomadas em cada régua, determina quantas tomadas podem ser disponibilizadas no saguão do hotel.\nEntrada\nA entrada consiste de uma linha com quatro inteiros positivos T1, T2, T3, T4, indicando o número de tomadas de cada uma das quatro réguas.\nSaída\nSeu programa deve imprimir uma única linha contendo um único número inteiro, indicando o número máximo de notebooks que podem ser conectados num mesmo instante.\nRestrições\n• 2 ≤ Ti ≤ 6.\nExemplos",
    "examples": [
      [
        "2 4 3 2",
        "8"
      ],
      [
        "6 6 6 6",
        "21"
      ],
      [
        "2 2 2 2",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tomadas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Corrida",
    "description": "A Federação de Corridas de Charrete (FCC) organiza todo ano a Subida Brigite Cardoso (SBC), disputada nas ladeiras de paralelepípedo de Ouro Preto. A corrida é uma das mais tradicionais do esporte, completando 100 anos em 2013. Para comemorar o centenário, a FCC pretende integrar dispostivos GPS às charretes, permitindo aos espectadores desfrutarem de dados de telemetria em tempo real.\nNo mesmo viés de inovação tecnológica, a FCC transmitirá a SBC via satélite para todo o planeta, e quer integrar a telemetria na transmissão, indicando qual seria o vencedor da corrida se as charretes mantivessem suas velocidades até o final da corrida; ela pediu que você escrevesse um programa que, dados as distâncias até a linha de chegada, as velocidades e os números das duas charretes que lideram a corrida, determina quem seria o vencedor da corrida (você pode supor que as charretes não cruzam a linha de chegada simultaneamente).\nEntrada\nA entrada consiste de duas linhas; cada linha descreve uma das charretes que lidera a corrida. A descrição de uma charrete consiste de três inteiros N, D e V indicando, respectivamente, o número da charrete, a sua distância à linha de chegada em metros, e a sua velocidade, em quilômetros por hora. Os números das duas charretes são distintos.\nSaída\nImprima uma única linha, contendo um único número inteiro, indicando o número da charrete que seria vencedora, conforme descrito acima.\nRestrições\n• 1 ≤ N ≤ 99 • 0 < D ≤ 1000 • 0 < V ≤ 50 Exemplos",
    "examples": [
      [
        "45 900 40\n17 300 20",
        "17"
      ],
      [
        "1 1000 100\n2 1000 99",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "corrida"
    },
    "imagesQuant": 0
  },
  {
    "name": "Robô",
    "description": "Um novo robô de limpeza para um grande salão retangular está sendo desenvolvido. O robô vai percorrer o caminho definido por uma linha marcada no chão, que é coberto com ladrilhos quadrados, brancos e pretos: ladrilhos pretos indicam o caminho que o robô deve percorrer. Ao movimentar-se, o robô pode andar apenas em linha reta, para a frente. Parado, o robô pode girar para as quatro direções (Norte, Sul, Leste e Oeste).\nDados um mapa indicando a cor de cada ladrilho no chão e a posição inicial do robô, você deve escrever um programa que determine a posição final do robô.\nEntrada\nA primeira linha contém dois inteiros L e C indicando as dimensões do salão (número de linhas e número de colunas), medidas em ladrilhos. A segunda linha contém dois inteiros A e B indicando respectivamente a linha e a coluna da posição inicial do robô (as linhas são numeradas de 1 a L, de cima para baixo; as colunas são numeradas de 1 a C, da esquerda para a direita). Cada uma das L linhas seguintes contém C inteiros, zeros ou uns. Nessa representação, o valor ‘1’ indica que o ladrilho corresponte é preto. O ladrilho da linha A e coluna B sempre é preto. O caminho do robô é definido unicamente: em nenhum momento o robô necessita fazer uma escolha sobre em qual direção ir (em outras palavras, todo ladrilho preto tem no máximo dois vizinhos pretos e o ladrilho inicial tem um vizinho preto).\nSaída\nSeu programa deve imprimir apenas uma linha, contendo dois números inteiros, respectivamente a linha e a coluna da posição final do robô.\nRestrições\n• 1 ≤ L,C ≤ 1000 • 1 ≤ A ≤ L, 1 ≤ B ≤ C • A posição final é diferente da posição inicial.\nExemplos",
    "examples": [
      [
        "3 5\n1 1\n1 0 0 0 1\n1 0 0 1 1\n1 1 1 1 0",
        "1 5"
      ],
      [
        "4 7\n3 4\n0 0 1 1 1 1 1\n1 1 1 0 0 0 1\n1 0 0 1 0 1 1\n1 1 0 1 1 1 0",
        "4 2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "robo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Rodovia",
    "description": "As estradas da Nlogônia estão severamente danificadas, devido ao intenso fluxo de veículos pesados criado pelo desenvolvimento econômico do reino. Para resolver o problema, o rei da Nlogônia decretou que seriam construídas novas rodovias. O decreto determinou que: • todas as rodovias construídas terão mão única, e ligarão exatamente duas cidades; • nenhum par de rodovias se intersectará — serão construídos viadutos, túneis e pontes conforme necessário; • por razões orçamentárias, o número de rodovias a construir será igual ao número de cidades que existem na Nlogônia; • deve ser possível, partindo de qualquer cidade, chegar a qualquer outra cidade usando só as novas rodovias, sempre respeitando a mão das rodovias.\nO engenheiro-chefe do reino desenhou uma proposta de mapa viário; o rei verificou que o plano satisfaz as três primeiras restrições, mas não conseguiu verificar a última. Por isso, ele pediu que você escrevesse um programa que determina se o plano de rodovias permite viajar de qualquer cidade até qualquer outra cidade da Nlogônia.\nEntrada\nA primeira linha de cada caso de teste contém um inteiro N, indicando o número de cidades. Cada uma das N linhas seguintes descrevem uma estrada: a linha contém dois inteiros A e B que indicam que existe uma estrada de mão única ligando a cidade A a outra cidade, B (as cidades são numeradas de 1 a N).\nSaída\nImprima uma única linha contendo um único caractere: ‘S’ se for possível ir de qualquer cidade a qualquer outra cidade por rodovias e ‘N’ caso contrário.\nRestrições\n• 2 ≤ N ≤ 104 • A (cid:54)= B; Informações sobre a pontuação\n• em um conjunto de casos de teste totalizando 20 pontos, N ≤ 3; • em um conjunto de casos de teste totalizando 40 pontos, N ≤ 8; Exemplos",
    "examples": [
      [
        "3\n1 2\n2 3\n3 1",
        "S"
      ],
      [
        "3\n1 2\n2 3\n1 3",
        "N"
      ],
      [
        "6\n1 2\n2 3\n4 1\n5 6\n3 5\n6 4",
        "S"
      ],
      [
        "6\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "rodovia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tiro ao Alvo",
    "description": "Recentemente Juquinha ganhou de aniversário um joguinho bem clássico: Tiro ao Alvo. Ele arrumou um ótimo lugar em seu quarto para se divertir com o jogo, porém após ler todas as regras do jogo ele percebeu que precisa da sua ajuda para calcular a pontuação obtida.\nSegundo as regras, o alvo do jogo é composto por C círculos, todos centrados na origem (0,0). Juquinha atira T vezes e após cada tiro informa suas coordenadas. A pontuação de cada tiro é feita da seguinte forma: para cada círculo em que o tiro estiver contido Juquinha recebe um ponto.\nConsidere por exemplo a figura abaixo. O tiro marcado com a letra A recebe zero pontos, pois não está contido por nenhum círculo. O tiro marcado com a letra B recebe um ponto, pois está contido por um círculo (o mais externo). O tiro marcado com a letra C recebe dois pontos, pois está contido por dois círculos (note que este caso mostra que tiros exatamente na borda de um círculo são considerados como contidos pelo círculo). Já o tiro marcado com a letra D recebe três pontos, pois está contido pelos três círculos.\nConsiderando todos os pontos, a pontuação total de Juquinha é de 13 pontos.\nA B D C Dados os raios de C círculos centrados na origem e as coordenadas dos T tiros realizados por Juquinha, escreva um programa que calcula o total de pontos que Juquinha obteve.\nEntrada\nA primeira linha da entrada contém dois inteiros positivos, C e T, que representam, respectivamente, o número de círculos do alvo e o número de tiros.\nCada uma das C linhas seguintes contém um inteiro positivo. O i-ésimo inteiro Ri representa o raio do i-ésimo círculo. Os raios Ri são fornecidos em ordem crescente.\nCada uma das T linhas seguintes contém um par X,Y de inteiros, que representam as coordenadas de cada tiro.\nSaída\nSeu programa deve imprimir uma única linha, contendo apenas um inteiro, o total de pontos obtidos por Juquinha.\nRestrições\n1 C 105 •   • 1  Ri  106 para 1  i  C • Ri > Ri\u00001 para 2  i  C 1 T 105 •   105 X,Y 105 •\u0000   Informações sobre a pontuação\nEm um conjunto de casos de teste que totaliza 30 pontos: 1 C 103 •   • 1  Ri  104 para 1  i  N 1 T 103 •   102 X,Y 102 •\u0000   Exemplos",
    "examples": [
      [
        "3 10\n1\n2\n5\n0 0\n-2 0\n0 -2\n3 -4\n-4 -3\n3 1\n6 2\n-1 2\n-5 -2\n1 -1",
        "13"
      ],
      [
        "3 6\n1\n2\n5\n1 0\n0 3\n-5 0\n0 0\n-3 -3\n1 1",
        "11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "alvo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Catálogo de Músicas",
    "description": "catalogo.py Joyce é uma menina que gosta muito de ouvir música, e possui uma enorme coleção de músicas num dvd.\nEla é uma menina organizada e deixa suas músicas em pastas, mas como o número de músicas e de pastas é grandre, Joyce construiu um catálogo para melhor localizá-las.\nPara o catálogo Joyce utilizou uma convenção usual em sistemas operacionais, em que a descrição da localização de cada arquivo é formada pela sequência dos nomes das pastas no caminho da raiz do dvd até o arquivo, separados pelo caractere barra (‘/’). Por exemplo, na figura abaixo, a descrição da música Sampa.mp3 no catálogo é MPB/Caetano/Sampa.mp3.\nRock MPB AngraCarryOn.mp3 Caetano Cartola Sampa.mp3 Alvorada.mp3 Utilizando essa convenção, o catálogo do dvd mostrado na figura é: Rock/AngraCarryOn.mp3 MPB/Caetano/Sampa.mp3 MPB/Cartola/Alvorada.mp3 Como o dvd de Joyce tem muitas músicas e pastas, o catálogo é muito grande. Joyce notou no entanto que o catálogo poderia ser menor (ter um número menor de caracteres) caso ela utilizasse outro conceito usual na nomeação de arquivos em sistemas operacionais: usar uma pasta como referência, ao invés da raiz.\nSe uma pasta diferente da raiz for escolhida como referência, então para todos os arquivos que estejam diretamente nessa pasta ou em alguma subpasta não será mais necessário escrever o nome da pasta referência no catálogo. Para as demais pastas, é necessário indicar o caminho utilizando as pastas acima (na direção da raiz) utilizando a convenção ‘../’ para a pasta imediatamente acima da pasta referência. No exemplo da figura acima, no caso de a referência ser a pasta Caetano, a música Sampa.mp3 seria simplesmente descrita como Sampa.mp3. Já a música Alvorada.mp3 seria descrita como ../Cartola/Alvorada.mp3.\nAssim, se a pasta Caetano for utilizada como referência, o catálogo será: ../../Rock/AngraCarryOn.mp3 Sampa.mp3 ../Cartola/Alvorada.mp3 Nesse caso, a descrição do catálogo tem 59 carateres, menor do que quando a referência utilizada é a raiz do dvd.\nSeu objetivo é, dada a informação de todas as músicas do catálogo, determinar o número mínimo de caracteres necessários para descrever o catálogo.\nEntrada\nA primeira linha da entrada contém um inteiro N, indicando quantos arquivos Joyce possui no dvd. Cada uma das N linhas seguintes contém a descrição de um arquivo, a partir da raiz.\nSaída\nSeu programa deve imprimir uma única linha, contendo apenas um inteiro, o número mínimo de caracteres necessários para descrever o catálogo.\nRestrições\n1 N 105 •   Número de pastas na entrada 105 •  O nome de cada pasta e de cada arquivo é composto por no máximo 20 caracteres, entre letras • minúsculas, maiúsculas e ponto (.) Cada pasta possui no máximo 100 pastas como filhas diretas.\n• Informações sobre a pontuação\nEm um conjunto de casos de teste que totaliza 30 pontos, N 1000 e o número de pastas 1000.\n•   Exemplos",
    "examples": [
      [
        "3\nRock/AngraCarryOn.mp3\nMPB/Caetano/Sampa.mp3\nMPB/Cartola/Alvorada.mp3",
        "59"
      ],
      [
        "2\nPreferidas/chacoalha/uia.mp3\nPreferidas/chacoalha/eia.mp3",
        "14"
      ],
      [
        "6\ndelta/india/juliet/lima\nbravo/echo\nbravo/foxtrot\ncharlie/hotel\ndelta/india/kilo\nbravo/golf",
        "76"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "catalogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Lençol",
    "description": "João dispõe de dois pedaços retangulares de tecido, e quer usá-los para fazer um lençol, também retangular, de dimensões A B. Se necessário, os dois pedaços retangulares podem ser unidos por ⇥ uma costura, mas João quer que a costura seja paralela aos lados dos retângulos. Os cortes, se necessários, também devem ser paralelos aos lados dos retângulos.\nDadas as dimensões dos pedaços de tecido e do lençol, escreva um programa que determina se é possível João fazer o lençol com as dimensões desejadas.\nEntrada\nA entrada contém uma única linha, com seis inteiros A1, B1, A2, B2, A e B, representando, respectivamente, as dimensões dos dois retângulos disponíveis, e as dimensões do retângulo desejado.\nSaída\nSeu programa deve imprimir uma única linha contendo um caractere S se é possível fazer o lençol, e N caso contrário.\nRestrições\n• 1  A1,B1,A2,B2,A,B  106 Exemplos",
    "examples": [
      [
        "4 2 3 5 4 4",
        "S"
      ],
      [
        "4 2 2 5 4 5",
        "N"
      ],
      [
        "1 2 3 5 5 2",
        "S"
      ],
      [
        "3 4 10 9 9 10",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "lencol"
    },
    "imagesQuant": 0
  },
  {
    "name": "Vende-se",
    "description": "A Otacílio Busílis Imóveis (OBI) é a maior imobiliária de Nlogópolis, especializada no aluguel de prédios comerciais; todas as suas propriedades se localizam na Avenida Doutor Otacílio Busílis, assim chamada em homenagem ao fundador da OBI.\nDevido à crise econômica mundial, a OBI precisa vender K de seus imóveis para levantar capital de giro.\nDr. Otacílio quer que os prédios restantes após a venda sejam o mais próximos possível — ou seja, a distância entre o primeiro e o último prédios restantes deve ser a menor possível.\nInfelizmente, a OBI é proprietária de tantos prédios que o Dr. Otacílio não sabe quais prédios ele deve vender; ele lhe contratou para que você escreva um programa que determina qual é a mínima distância possível entre o primeiro e o último prédios da OBI na avenida, após a venda de K prédios.\nEntrada\nA primeira linha da entrada contém os inteiros N e K, indicando, respectivamente, quantos prédios a OBI possui, e quantos prédios ela pretende vender. A linha seguinte contém N inteiros Xi, indicando a distância de cada um dos N prédios ao início da avenida, em metros.\nSaída\nA saída deve conter um único inteiro indicando a menor distância possível entre o primeiro e o último prédio possuídos pela OBI após a venda.\nRestrições\n3 N 105 •   N K 2 • \u0000 \u0000 • 1  Xi  106 • todos os Xi são distintos Informações sobre a pontuação\nEm um conjunto de casos de teste que totaliza 30 pontos, N 10 •  Em um conjunto de casos de teste que totaliza 70 pontos, N 2000 •  Exemplos",
    "examples": [
      [
        "5 2\n10 7 4 8 2",
        "3"
      ],
      [
        "8 6\n16 11 1 7 29 4 22 2",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "vende"
    },
    "imagesQuant": 0
  },
  {
    "name": "Soma de Frações",
    "description": "Joãozinho está aprendendo a somar frações na escola e quer sua ajuda para escrever um programa que dadas duas frações imprima a soma delas em sua forma irredutível. Assim ele vai poder conferir as respostas dos exercícios que está fazendo.\nA forma irredutível de uma fração é quando o divisor (número de baixo) é o menor possível. Por exemplo, s1 3 e0 ré siu mm pa lifif cra aç dã ao pi ar rr aed 35u ,tí dv ie vl i, dp ino dis o-1 s0 e e 103 en 6ão potê rm 2.nenhum divisor em comum. Mas 1 60 não é, pois ela pode Dados quatro inteiros a, b, c, d, escreva um programa que calcule a b + dc na sua forma irredutível.\nEntrada\nA única linha da entrada contém quatro inteiros a, b, c, d, respectivamente dividendo e divisor da primeira fração e dividendo e divisor da segunda fração.\nSaída\nSeu programa deve imprimir uma única linha contendo dois inteiros, dividendo e divisor da fração irredutível formada pela soma das duas frações dadas.\nRestrições\n• 1 ≤ a,b,c,d ≤ 100 Exemplos",
    "examples": [
      [
        "2 3 7 3",
        "3 1"
      ],
      [
        "7 5 3 2",
        "29 10"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fracoes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Plantação",
    "description": "plantacao.py A N-logônia é uma região com um clima muito intenso e variável, onde em questão de poucos dias é possível observar uma forte seca, seguida de uma intensa estação de chuvas. O Seu João tem uma plantação de obilina, uma fruta típica e muito apreciada na região, o que a torna muito valiosa. A obilina, entretanto, é muito suscetível a mudanças climáticas, de forma que é difícil prever quanto desta fruta será colhido durante a safra.\nObservou-se que as árvores de obilina seguem as seguintes regras: • As árvores produzem frutas todos os dias, exceto quando elas morrem; • As árvores mortas não produzem frutas, e infelizmente, mesmo que volte a chover, continuam mortas; • Se choveu na noite anterior, a árvore produz uma fruta a mais que no dia anterior; • Se estiou na noite anterior, a árvore produz uma fruta a menos que no dia anterior; e • Uma árvore morre se não produzir nenhuma fruta.\nO Seu João deseja vender toda a obilina produzida para uma grande rede de mercados local, mas para isso, precisa saber exatamente quantas frutas de obilina ele colherá durante a safra.\nPara ajudar o Seu João nesta tarefa, você deve escrever um programa que, dada a previsão do tempo para cada noite do período da safra, e quantas frutas cada árvore do Seu João produziu no dia anterior ao início da safra, determine quantas obilinas serão colhidas durante a safra.\nPor exemplo, considerando apenas um pé de obilina, se a safra dura dois dias, choveu durante duas noites, e o pé de obilina produziu 3 frutos antes de começar a safra, a produção total da safra será de 9 frutas: 4 no primeiro dia da safra, e 5 no segundo dia.\nEntrada\nA primeira linha da entrada contém dois inteiros, N e K, respectivamente o número de dias que dura a safra, e o número de árvores que o Seu João possui.\nA segunda linha contém K inteiros ai indicando quantas frutas foram produzidas no dia anterior ao início da safra por cada uma das K árvores.\nA linha seguinte contém N letras separadas por um espaço em branco. Cada uma das letras indica se choveu ou se estiou durante a noite respectiva: a primeira letra se refere à primeira noite, a segunda letra se refere à segunda noite, e assim por diante. Se a letra for um ‘C’, indica que choveu aquela noite chuvosa, e se for um ‘E’, indica que estiou (ou seja, não choveu).\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, indicando o número de frutas que serão produzidas pela plantação do Seu João.\nRestrições\n• 1 ≤ N ≤ 100000 • 1 ≤ K ≤ 100000 • 1 ≤ ai ≤ 100 para todo i Informações sobre a pontuação\n• Em um conjunto de casos de teste valendo 70 pontos, N ≤ 1000 e K ≤ 1000.\n• Em um conjunto de casos de teste valendo 70 pontos, a resposta não excederá 1.000.000.000.\nExemplos",
    "examples": [
      [
        "3 2\n1 2\nC E C",
        "13"
      ],
      [
        "5 3\n2 3 1\nE E E C C",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "plantacao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Volume da TV",
    "description": "Bruno é um menino que gosta muito de ver televisão. No entanto ele se depara com um problema muito chato. Sempre que começa um novo programa no canal preferido dele, a TV Nlogônia, acontece de o volume do som deste programa estar diferente do anterior, às vezes com volume menor, outras vezes com volume maior. Quando está com volume menor, ele aumenta o volume pressionando uma quantidade de vezes seguidas o botão de aumentar para o volume ficar ideal; a mesma coisa acontece quando está um volume maior, e ele diminui o volume pressionando alguma quantidade de vezes seguidas o botão de diminuir o volume para ficar com o volume que ele goste no momento.\nO aparelho de TV dele tem umas peculiaridades: ele possui volume mínimo, com valor 0 (também chamado de mudo), e volume máximo, com valor 100. A TV nunca ultrapassa os volumes máximo e mínimo. Por exemplo, se o volume já estiver no máximo e ele pressionar o botão de aumentar o som, o volume não se altera. Da mesma forma, se o volume estiver no valor mínimo e ele pressionar o botão de diminuir o som, o volume não se altera.\nAgora Bruno quer sua ajuda: ele lembra qual era o volume inicial da TV, e quantas vezes ele pressionou cada botão. Mas, como foram várias mudanças de volume, ele não sabe qual é o volume atual da TV. Por isso, pediu que você o ajude a calcular qual é o volume atual, dados o volume inicial e a lista de trocas de volume que ele realizou.\nEntrada\nA primeira linha da entrada contém dois números inteiros V e T, que indicam, respectivamente, o volume inicial e o número de trocas de volume.\nA segunda linha contém T números inteiros Ai que mostram as modificações de volume realizadas, na ordem em que estas modificações foram feitas. O primeiro número indica a primeira modificação de volume, o segundo número indica a segunda modificação, e assim por diante. Para cada modificação, um número maior do que zero significa quantas vezes Bruno pressionou o botão de aumentar o som; um número menor do que zero significa quantas vezes ele pressionou o botão de diminuir o som. Ou seja, se o número é igual a 5, significa que nessa modificação ele pressionou cinco vezes o botão de aumentar o som; se o número é igual a −3, significa que nessa modificação ele pressionou o botão de diminuir o som três vezes.\nSaída\nSeu programa deve imprimir apenas uma linha, contendo apenas um inteiro F, que indica qual o volume atual da TV após as mudanças de volume.\nRestrições\n• 0 ≤ V ≤ 100 • 0 ≤ T ≤ 1000 • Para cada variação de volume Ai, −100 ≤ Ai ≤ 100 Exemplos",
    "examples": [
      [
        "50 4\n11 20 -15 -13",
        "53"
      ],
      [
        "50 5\n30 30 30 40 -78",
        "22"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "volume"
    },
    "imagesQuant": 0
  },
  {
    "name": "Distância de Manhattan",
    "description": "manhattan.py Maria é uma moradora de Nlogópolis, uma cidade na Nlogônia que tem uma característica muito interessante: todas as ruas da cidade ou são orientadas no sentido norte-sul ou são orientadas no sentido leste-oeste. Isso significa que, dadas duas ruas, ou elas são paralelas ou elas são perpendiculares entre si.\nTodas as ruas da cidade são de mão dupla e é possível seguir em qualquer direção em um cruzamento.\nAgora Maria está atrasada para uma reunião e precisa de sua ajuda. Dadas as coordenadas iniciais de Maria e da reunião, determine o número mínimo de cruzamentos que Maria deve atravessar para chegar ao seu destino. Esse número inclui o cruzamento onde ocorrerá a reunião mas não inclui a posição inicial de Maria.\nEntrada\nA única linha da entrada contém quatro inteiros, Xm, Ym, Xr, Yr, indicando as coordenadas de Maria (Xm, Ym) e da reunião (Xr, Yr). O ponto de partida de Maria nunca será igual ao local da reunião, ou seja, pelo menos uma das coordenadas será diferente.\nSaída\nSeu programa deve imprimir uma única linha contendo um único inteiro: o número mínimo de cruzamentos que Maria precisa atravessar para chegar até o local da reunião.\nRestrições\n• 0 ≤ Xm,Ym ≤ 1000 • 0 ≤ Xr,Yr ≤ 1000 Exemplos",
    "examples": [
      [
        "0 0 5 6",
        "11"
      ],
      [
        "52 75 120 75",
        "68"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "manhattan"
    },
    "imagesQuant": 0
  },
  {
    "name": "Polígono",
    "description": "poligono.py Renato gosta muito de geometria e acaba de achar alguns palitos em seu quarto. Ele está tentando utilizar esses palitos de forma a fazer um polígono com o maior número de lados possíveis.\nPara montar o polígono, Renato não quer cruzar os palitos; ou seja, os palitos devem se tocar apenas nas pontas. Ele também não quer quebrar nenhum palito, de forma que todos os palitos que forem usados devem manter sua medida original.\nSe, por exemplo, os palitos têm medidas 3, 4 e 5, é possível utilizar todos os três palitos para formar um triângulo. Mas se as medidas são 1, 1, 1 e 5, é possível formar um triângulo com três lados iguais a 1 mas não é possivel formar um polígono com todos os 4 palitos.\nVocê consegue ajudar Renato a descobrir qual é o maior número de palitos que ele consegue usar? Entrada\nA primeira linha contém apenas um inteiro N que indica o número de palitos. A segunda linha possui N inteiros indicando as medidas dos palitos.\nSaída\nSe programa deve imprimir uma única linha, contendo um único inteiro, o maior número de lados que o polígono pode ter seguindo as restrições do enunciado. Se não for possível formar nenhum polígono usando os palitos, imprima 0.\nRestrições\n• 3 ≤ N ≤ 100000 • As medidas dos palitos são inteiros positivos menores ou iguais a 10000 Informações sobre a pontuação\n• Para um conjunto de entradas totalizando 50 pontos, N ≤ 1000 Exemplos",
    "examples": [
      [
        "3\n3 4 5",
        "3"
      ],
      [
        "3\n3 1 2",
        "0"
      ],
      [
        "4\n1 1 5 1",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "poligono"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quadradinho de 8",
    "description": "quadrado.py Fernando ficou sabendo de um novo jogo chamado quadradinho de 8. Nesse jogo, é apresentado ao jogador uma fileira de quadrados, um do lado do outro. Em cada quadrado há um número escrito. Veja abaixo um exemplo de fileira de quadrados:   Para ganhar, o jogador deve escolher alguns quadrados de forma que eles juntos formem apenas um retângulo contíguo e que a soma de seus números seja divisível por 8. Na fileira de quadrados acima, o jogador ganha se escolher os quadrados com os números 6, 0 e 2. O jogador perde se escolher os quadrados com 3, 4 e 9, apesar da soma ser divisivel por 8, os quadrados não estão juntos, eles acabam formando dois retângulos separados.\nVocê deve estar pensando agora que Fernando quer sua ajuda para que você mostre a ele como ganhar o jogo, mas Fernando é um garoto muito esperto e sabe resolver o jogo rapidamente. Ele quer na verdade que você o ajude a descobrir de quantas formas é possível ganhar esse jogo.\nEntrada\nA entrada possui duas linhas. A primeira linha contém apenas um inteiro N que indica o número de quadrados na fileira de um jogo. A segunda linha contém N inteiros indicando na ordem os números presentes nos quadrados da fileira de um jogo.\nSaída\nSeu programa deve imprimir uma única linha, contendo apenas um inteiro, o número de maneiras de ganhar o jogo apresentado na entrada. Se não for possível que o jogador ganhe o jogo, imprima 0.\nRestrições\n• 1 ≤ N ≤ 1000000 • Os números nos quadrados são inteiros não negativos menores ou iguais a 1000.\nInformações sobre a pontuação\n• Para um conjunto de entradas totalizando 50 pontos, N ≤ 200 • Para um conjunto de entradas totalizando 70 pontos, N ≤ 5000 Exemplos\nEntrada\nSaída\n6 3",
    "examples": [
      [
        "6\n3 4 6 0 2 9",
        "3"
      ],
      [
        "7\n1 1 1 1 1 1 1",
        "0"
      ],
      [
        "5\n8 0 8 0 8",
        "15"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quadrado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Troco",
    "description": "Você está num supermercado e está na fila do caixa para comprar alguns produtos. Assim que você termina de passar as compras pelo caixa, se lembra que tem várias moedas em seu bolso, algumas repetidas, e fica pensando se com elas dá para pagar exatamente o valor das compras (para assim se livrar destas moedas e ficar com os bolsos mais leves). Você consegue pagar o valor exato da conta usando estas moedas? Entrada\nA primeira linha da entrada contém dois números inteiros V e M, indicando, respectivamente, o valor final da compra e o número de moedas que você tem em seu bolso. A segunda linha contém M números inteiros que descrevem o valor Mi de cada moeda existente em seu bolso.\nSaída\nSeu programa deve imprimir apenas uma linha, contendo apenas um caractere: S caso seja possível pagar o valor exato da conta usando apenas suas moedas, ou N caso contrário.\nRestrições\n• 1 ≤ V ≤ 105 • 1 ≤ M ≤ 103 • 1 ≤ Mi ≤ 105 Informações sobre a pontuação\n• Para um conjunto de entradas que vale 70 pontos, M ≤ 20 Exemplos",
    "examples": [
      [
        "16 4\n25 10 5 1",
        "S"
      ],
      [
        "20 4\n25 10 5 1",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "troco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cachecol da Vovó Vitória",
    "description": "cachecol.py Vovó Vitória possui muitos netinhos; como toda boa avó, ela se preocupa constantemente com a saúde de seus netos, e quer garantir que eles estejam sempre bem agasalhados o tempo todo.\nVovó Vitória dispõe de um saco com vários retalhos quadrados de mesmo tamanho, em três cores diferentes, e quer usá-los para costurar cachecóis para seus netos. Ela quer que cada cachecol tenha três retalhos de largura por N de comprimento e, além disso, retalhos adjacentes devem ter cores diferentes. Por exemplo, a figura abaixo mostra três cachecóis que Vovó Vitória pode costurar.\nVovó Vitória tem muitos netos, e quer fazer um cachecol diferente para cada um deles, mas ela não sabe de quantas formas ela pode arrumar os retalhos para formar cachecóis diferentes. Por isso, ela pediu para você escrever um programa que determina quantos cachecóis diferentes ela pode costurar.\nEntrada\nA entrada consiste de uma única linha contendo um único inteiro N, indicando o número de retalhos no comprimento do cachecol.\nSaída\nImprima uma única linha contendo um único número inteiro, indicando o número de cachecóis distintos que a Vovó Vitória pode costurar. Como este número pode ser muito grande, imprima o resto que este número deixa quando dividido por 1.000.000.007 (109 + 7).\nRestrições\n• 1 ≤ N ≤ 1018 Exemplos",
    "examples": [
      [
        "1",
        "12"
      ],
      [
        "2",
        "54"
      ],
      [
        "4",
        "1122"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cachecol"
    },
    "imagesQuant": 0
  },
  {
    "name": "Janela",
    "description": "A sala de aulas utilizada para os cursos da OBI tem uma grande janela, composta de três folhas de vidro. A janela tem um metro de altura por seis metros de comprimento. Cada folha da janela tem um metro de altura e dois metros de comprimento. As folhas deslizam sobre trilhos, ao longo do comprimento da janela, de forma que é possível controlar a abertura da janela, para circulação de ar.\nDadas as posições das três folhas da janela, deseja-se determinar qual a área da janela que está aberta, em centímetros quadrados.\nA figura abaixo ilustra duas configurações das folhas da janela. Na figura, os cantos inferiores esquerdos de cada folha são indicados por F1,F2 e F3. Na configuração (a) a janela está totalmente fechada, e portanto o total da área aberta é igual a zero. Na configuração (b) há duas aberturas, e o total de área aberta é igual a (100 × 100) + (50 × 100) = 15.000 cm2.\n100 (a)   0 0 100 200 300 400 500 600 100 (b)   0 0 100 200 300 400 500 600 Dadas as posições das três folhas da janela, escreva um programa que calcule a área da janela que está aberta, em centímetros quadrados.\nEntrada\nA primeira e única linha da entrada contém três inteiros F1, F2 e F3, indicando as posições das três folhas. A posição de cada folha é dada pela distância, em centímetros, da extremidade esquerda da janela até a extremidade esquerda da folha.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, a área aberta da janela em centímetros quadrados.\nRestrições\n• 0 ≤ F1,F2,F3 ≤ 400.\nExemplos",
    "examples": [
      [
        "0 200 400",
        "0"
      ],
      [
        "0 50 350",
        "15000"
      ],
      [
        "344 344 344",
        "40000"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "janela"
    },
    "imagesQuant": 0
  },
  {
    "name": "Torneio",
    "description": "Juquinha foi convidado para participar do prestigiado torneio de tênis de Rolando Barros, na Nlogônia. O torneio é composto de N rodadas no estilo mata-mata: todo jogador que perde uma partida é eliminado do torneio, e o vencedor desta partida avança para a próxima rodada. Como o número de jogadores ativos cai pela metade a cada rodada, é necessário que o número de jogadores participantes seja uma potência de 2.\n1 2 3 4 Vencedor 5 6 7 Terceira 8 Segunda r (o fd ina ad l)a Primeira rodada rodada Os jogadores são inicialmente dispostos na chave por sorteio. Em uma disposição é atribuido a cada jogador um valor de 1 a 2N, que corresponde a sua posição na chave do torneio. Jogadores vencedores avançam para a direita da chave, e disputam com o vencedor da sub-chave vizinha. Na imagem acima, caso os jogadores das posições 1 e 3 vençam suas partidas na primeira rodada, estes se enfrentarão na segunda rodada.\nJuquinha não quer perder a chance de tornar-se um jogador mundialmente famoso, e para isso contratou você para ajudá-lo em suas análises estatísticas. Ele atribuiu a cada jogador um coeficiente de habilidade Hi, e sabe que se dois jogadores disputarem uma partida, aquele com maior coeficiente de habilidade certamente será o vencedor. Seu papel é calcular quantas disposições iniciais dos jogadores forçam Juquinha perder na K-ésima rodada (ou vencer o torneio, caso K = N +1). Duas disposições são consideradas distintas se para algum jogador foi atribuido um valor diferente nas duas disposições.\nEntrada\nA primeira linha contém dois inteiros N e K. Cada uma das próximas 2N linhas seguintes contêm um único inteiro representando o coeficiente de habilidade de um jogador. O coeficiente de Juquinha é representado pelo primeiro desses inteiros.\nSaída\nSeu programa deve imprimir uma única linha contendo um único inteiro indicando o número de disposições iniciais que forçam Juquinha a perder na K-ésima rodada (ou ganhar o torneio, se K = N + 1). Como este número pode ser muito grande, imprima o resto que este número deixa quando dividido por 1.000.000.007 (109 + 7).\nRestrições\n• 1 ≤ N ≤ 16 • 1 ≤ K ≤ N + 1 • 0 ≤ coeficiente de habilidade de um jogador ≤ 109 • Não existem dois jogadores diferentes com a mesma habilidade.\nInformações sobre a pontuação\n• Em um conjunto de casos de testes que totaliza 30 pontos, N ≤ 3 Exemplos",
    "examples": [
      [
        "2 2\n3\n4\n2\n1",
        "16"
      ],
      [
        "1 2\n7\n5",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "torneio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Famílias de Troia",
    "description": "A Guerra de Troia pode ter sido um grande conflito bélico entre gregos e troianos, possivelmente ocorrido entre 1300 a.C. e 1200 a.C. (fim da Idade do Bronze no Mediterrâneo). Recentemente foram encontradas inscrições numa caverna a respeito de sobreviventes. Após um trabalho árduo, arqueólogos descobritam que as incrições descreviam relações de parentesco numa certa população. Cada item da inscrição indicavam duas pessoas que pertenciam a uma mesma família. Seu problema é determinar quantas famílias distintas existem.\nEntrada\nO arquivo de entrada consiste de M + 1 linhas. A primeira linha do arquivo de entrada contém um inteiro positivo N, que indica o número de elementos da comunidade, numerados de 1 a N. As demais M linhas do arquivo de entrada contêm, cada uma, dois inteiros. Cada inteiro identifica um elemento da comunidade.\nCada linha indica que os dois indivíduos pertencem a uma mesma família.\nSaída\nA saída deve conter apenas uma linha contendo um único inteiro, que é o número de famílias.\nRestrições\n• 1 ≤ N ≤ 5 × 104 • 1 ≤ M ≤ 105 Exemplos",
    "examples": [
      [
        "4 4\n1 2\n2 3\n3 4\n4 1",
        "1"
      ],
      [
        "8 10\n1 2\n2 3\n3 6\n6 5\n5 4\n4 3\n6 7\n7 8\n8 1\n1 5",
        "1"
      ],
      [
        "9 8\n1 2\n2 3\n3 6\n4 3\n6 5\n7 8\n1 4\n6 2",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2013,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "troia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fila",
    "description": "Com a proximidade da Copa do Mundo, o fluxo de pessoas nas filas para compra de ingressos aumentou consideravelmente. Como as filas estão cada vez maiores, pessoas menos pacientes tendem a desistir da compra de ingressos e acabam deixando as filas, liberando assim vaga para outras pessoas. Quando uma pessoa deixa a fila, todas as pessoas que estavam atrás dela dão um passo a frente, sendo assim nunca existe um espaço vago entre duas pessoas. A fila inicialmente contém N pessoas, cada uma com um identificador diferente. Joãozinho sabe o estado inicial dela e os identificadores em ordem das pessoas que deixaram a fila. Sabendo que após o estado inicial nenhuma pessoa entrou mais na fila, Joãozinho deseja saber o estado final da fila.\nEntrada\nA primeira linha contém um inteiro N representando a quantidade de pessoas inicialmente na fila.\nA segunda linha contém N inteiros representando os identificadores das pessoas na fila. O primeiro identificador corresponde ao identificador da primeira pessoa na fila. É garantido que duas pessoas diferentes não possuem o mesmo identificador. A terceira linha contém um inteiro M representando a quantidade de pessoas que deixaram a fila. A quarta linha contém M inteiros representando os identificadores das pessoas que deixaram a fila, na ordem em que elas saíram. É garantido que um mesmo identificador não aparece duas vezes nessa lista.\nSaída\nSeu programa deve imprimir uma linha contedo N − M inteiros com os identificadores das pessoas que permaneceram na fila, em ordem de chegada.\nRestrições\n• 1 ≤ N ≤ 50000 • 1 ≤ M ≤ 50000 e M < N • Cada identificador está entre 1 e 100000 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 30 pontos, N ≤ 1000 e M ≤ 1000.\nExemplos",
    "examples": [
      [
        "8\n5 100 9 81 70 33 2 1000\n3\n9 33 5",
        "100 81 70 2 1000"
      ],
      [
        "4\n10 9 6 3\n1\n3",
        "10 9 6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fila"
    },
    "imagesQuant": 0
  },
  {
    "name": "Flíper",
    "description": "Flíper é um tipo de jogo onde uma bolinha de metal cai por um labirinto de caminhos até chegar na parte de baixo do labirinto. A quantidade de pontos que o jogador ganha depende do caminho que a bolinha seguir. O jogador pode controlar o percurso da bolinha mudando a posição de algumas portinhas do labirinto. Cada portinha pode estar na posição 0, que significa virada para a esquerda, ou na posição 1 que quer dizer virada para a direita. Considere o flíper da figura abaixo, que tem duas portinhas. A portinha P está na posição 1 e a portinha R, na posição 0. Desse jeito, a bolinha vai cair pelo caminho B.\n0 1 P 0 1 R A B C Você deve escrever um programa que, dadas as posições das portinhas P e R, neste flíper da figura, diga por qual dos três caminhos, A, B ou C, a bolinha vai cair! Entrada\nA entrada é composta por apenas uma linha contendo dois números P e R, indicando as posições das duas portinhas do flíper da figura.\nSaída\nA saída do seu programa deve ser também apenas uma linha, contendo uma letra maiúscula que indica o caminho por onde a bolinha vai cair: ‘A’, ‘B’ ou ‘C’.\nRestrições\n• O número P pode ser 0 ou 1. O número R pode ser 0 ou 1.\nExemplos",
    "examples": [
      [
        "1 0",
        "B"
      ],
      [
        "0 0",
        "C"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fliper"
    },
    "imagesQuant": 0
  },
  {
    "name": "Gangorra",
    "description": "gangorra.py Joãozinho acaba de mudar de escola e a primeira coisa que percebeu na nova escola é que a gangorra do parquinho não é simétrica, uma das extremidades é mais longa que a outra. Após brincar algumas vezes com um amigo de mesmo peso, ele percebeu que quando está em uma extremidade, a gangorra se desequilibra para o lado dele (ou seja, ele fica na parte de baixo, e o amigo na parte de cima), mas quando eles trocam de lado, a gangorra se desequilibra para o lado do amigo. Sem entender a situação, Joãozinho pediu ajuda a outro amigo de outra série, que explicou que o comprimento do lado interfere no equilíbrio da gangorra, pois a gangorra estará equilibrada quando P1 ∗ C1 = P2 ∗ C2 onde P1 e P2 são os pesos da criança no lado esquerdo e direito, respectivamente, e C1 e C2 são os comprimentos da gangorra do lado esquerdo e direito, respectivamente.\nCom a equação, Joãozinho já consegue dizer se a gangorra está equilibrada ou não mas, além disso, ele quer saber para qual lado a gangorra descerá caso esteja desequilibrada.\nEntrada\nA primeira e única linha da entrada contém 4 inteiros, P1, C1, P2 e C2, nesta ordem.\nSaída\nSe a gangorra estiver equilibrada, imprima ‘0’. Se ela estiver desequilibrada de modo que a criança esquerda esteja na parte de baixo, imprima ‘-1’, senão, imprima ‘1’.\nRestrições\n• 10 ≤ P1 ≤ 100 e 10 ≤ C1 ≤ 100 • 10 ≤ P2 ≤ 100 e 10 ≤ C2 ≤ 100 Exemplos",
    "examples": [
      [
        "30 100 60 50",
        "0"
      ],
      [
        "40 40 38 60",
        "1"
      ],
      [
        "35 80 35 75",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "gangorra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Letras",
    "description": "Considere as definições abaixo: • Uma palavra é uma sequência de letras consecutivas.\n• Um texto é um conjunto de palavras separadas pelo caractere espaço em branco.\nVocê foi contratado pela empresa Booble para escrever um programa que, dados uma letra e um texto, determina a porcentagem de palavras do texto que contém a letra dada.\nEntrada\nA primeira linha da entrada contém um único caractere, a letra de interesse na pesquisa. A segunda linha contém um texto, como definido acima.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número real, a porcentagem de palavras do texto que contêm a letra dada, com precisão de uma casa decimal.\nRestrições\n• O texto é composto apenas por letras minúsculas e o caractere espaço em branco.\n• O texto é formado por no mínimo um caractere, e no máximo 1000 caracteres.\n• O texto não contém dois espaços em branco consecutivos.\nExemplos",
    "examples": [
      [
        "p\npapagaio",
        "100.0"
      ],
      [
        "o\nno meio do caminho tinha uma pedra tinha uma pedra no meio do caminho",
        "57.1"
      ],
      [
        "b\nnunca me esquecerei que no meio do caminho tinha uma pedra",
        "0.0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "letra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Semente",
    "description": "Um experimento biológico utiliza uma fita de papel branco especial, na qual algumas gotas de um reagente são colocadas em posições específicas. Inicialmente a gota de reagente faz com que o papel se torne preto na posição em que foi colocada. A cada dia o reagente se propaga pelo papel, em todas as direções, com velocidade de 1 posição por dia, colorindo a região em que o reagente se propagou. A figura abaixo mostra um experimento com uma fita de 13 posições, com três gotas de reagente inicialmente, colocadas nas posições 2, 6 e 13 (a posição 1 é a primeira mais à esquerda da fita). Ao final do terceiro dia, a fita está completamente tomada pelo reagente.\nFita no estado inicial Fita após um dia Fita após dois dias Fita após três dias Você foi contratado para escrever um programa que, dados o comprimento da fita de papel e as posições das gotas de reagente no início do experimento, determine quantos dias serão necessários para a fita de papel ficar completamente tomada pelo reagente.\nEntrada\nA primeira linha contém dois inteiros F e R, indicando respectivamente o comprimento da fita de papel, em números de posições, e o número de gotas no início do experimento. A segunda linha contém R inteiros, indicando as posições das gotas de reagente, que são dadas em ordem crescente.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de dias necessários para que a fita de papel fique totalmente tomada pelo reagente.\nRestrições\n• 1 ≤ F ≤ 100000, 1 ≤ R ≤ 1000 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 80 pontos, F ≤ 1000.\nExemplos",
    "examples": [
      [
        "13 3\n2 6 13",
        "3"
      ],
      [
        "10 2\n9 10",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "semente"
    },
    "imagesQuant": 0
  },
  {
    "name": "Setas",
    "description": "Gabriel é um garoto que gosta muito de um jogo onde há várias letras em um tabuleiro e o jogador precisa rapidamente pisar nas letras corretas, de acordo com as instruções na tela, seguindo uma música. Cansado de vencer, Gabriel inventou um novo jogo: agora temos um tabuleiro quadrado, com N células de cada lado, em que cada célula possui uma seta que aponta para uma das quatro posições vizinhas. O jogador primeiro escolhe uma célula inicial para se posicionar e, quando a música começa, ele deve caminhar na direção para onde a seta em que ele está aponta. Ganha o jogo quem pisar em mais setas corretas durante um período de tempo.\nO problema é que Gabriel joga tão rápido que quando a seta atual manda ele sair do tabuleiro, ele segue a orientação, muitas vezes quebrando alguns objetos próximos. Quando isso acontece, dizemos que a célula inicial deste jogo não é segura, pois leva a um caminho que termina fora do tabuleiro. A figura abaixo mostra dois tabuleiros.\nTabuleiro 3x3 com oito células seguras Tabuleiro 4x4 com onze células seguras Ajude Gabriel: dada a configuração do tabuleiro, determine quantas células são seguras para ele iniciar o jogo.\nEntrada\nA primeira linha da entrada contém um inteiro N, o tamanho do tabuleiro. Cada uma das N linhas seguintes contém N caracteres, com as direções das setas. As direções válidas são: • ‘V’ Aponta para a célula da linha abaixo, na mesma coluna • ‘<’ (sinal menor-que) aponta para a célula à esquerda, na mesma linha • ‘>’ (sinal maior-que) aponta para a célula à direita, na mesma linha • ‘A’ Aponta para a célula da linha acima, na mesma coluna Saída\nSeu programa deve produzir um único inteiro, o número de células seguras.\nRestrições\n• 1 ≤ N ≤ 500 Informações sobre a pontuação\n• Em um subconjunto dos casos totalizando 50 pontos, 1 ≤ N ≤ 50.\nExemplos",
    "examples": [
      [
        "3\n>>V\nAV<\nA<>",
        "8"
      ],
      [
        "4\n>>V<\nA<<<\nAAA>\n>>>A",
        "11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "setas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Triângulo",
    "description": "triangulo.py Ana e suas amigas estão fazendo um trabalho de geometria para o colégio, em que precisam formar vários triângulos, numa cartolina, com algumas varetas de comprimentos diferentes. Logo elas perceberam que não dá para formar triângulos com três varetas de comprimentos quaisquer. Se uma das varetas for muito grande em relação às outras duas, não dá para formar o triângulo.\nAna fez uma pesquisa na internet e aprendeu que com três varetas é possível formar um triângulo quando, para todas as varetas, vale a seguinte relação: o comprimento da vareta é menor do que a soma dos comprimentos das outras duas varetas. Por exemplo, se os comprimentos forem 6, 9 e 5, vai dar para formar o triângulo, pois a relação vale para as três varetas: 6 < 9 + 5, 9 < 6 + 5 e 5 < 6 + 9. Mas, se os comprimentos forem, por exemplo, 4, 10 e 3, não vai dar para formar um triângulo, porque a relação não vale para uma das varetas (pois 10 não é menor do que 3 + 4).\nNeste problema, você precisa ajudar Ana e suas amigas a descobrir se, dados os comprimentos de quatro varetas, é ou não é possível selecionar três varetas, dentre as quatro, e formar um triângulo! Entrada\nA entrada é composta por apenas uma linha contendo quatro números inteiros.\nSaída\nSeu programa deve produzir apenas uma linha contendo o caractere ‘S’, caso seja possível formar o triângulo; ou o caractere ‘N’, caso não seja possível formar o triângulo.\nRestrições\n• O valor dos quatro números está entre 1 e 100.\nExemplos",
    "examples": [
      [
        "6 9 22 5",
        "S"
      ],
      [
        "14 40 12 60",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "triangulo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Copa do Mundo",
    "description": "A Nlogônia é atualmente um dos países com maior crescimento econômico no mundo, e seus governantes têm se esforçado para que o país seja mais conhecido e respeitado internacionalmente.\nRecentemente a Nlogônia foi escolhida para ser a sede da Copa do Mundo de Futebol Amador, e está se preparando para receber os milhares de torcedores que o evento atrai.\nComo parte da preparação para a Copa, o governo planeja realizar uma reforma em todo o sistema de transporte intermunicipal, que é hoje composto de uma malha de rodovias e ferrovias, cada rodovia ou ferrovia interligando um par de cidades. Com as rodovias e ferrovias existentes já é possível viajar entre qualquer par de cidades (possivelmente passando por outras cidades no caminho), mas o governo quer oferecer melhores condições de transporte para os visitantes e a população.\nComo não há recursos para reformar todas as rodovias e ferrovias, o governo quer escolher um conjunto de rodovias e ferrovias para ser reformado, e já realizou um estudo para estabelecer o custo de reforma de cada rodovia e ferrovia. A escolha deve obedecer aos seguintes critérios: 1. ao final da reforma, deve ser possível viajar entre qualquer par de cidades (possivelmente passando por outras cidades) utilizando apenas rodovias ou ferrovias reformadas; 2. para priorizar o transporte público, dentre as escolhas que satisfazem a restrição 1, deve-se escolher uma que minimize o número de rodovias reformadas; 3. dentre as escolhas que satisfazem as restrições 1 e 2, deve-se escolher uma que minimize o custo total.\nVocê foi contratado para escrever um programa que, conhecidos os custos de reforma de cada rodovia e ferrovia, determine o menor custo possível para a reforma, obedecidos os critérios estabelecidos.\nEntrada\nA primeira linha da entrada contém três inteiros N, F e R, indicando respectivamente o número de cidades, de ferrovias e de rodovias. As cidades são identificadas por inteiros de 1 a N. Cada uma das F linhas seguintes descreve uma ferrovia e contém três inteiros A, B e C, onde A e B representam cidades e C representa o custo da reforma da ferrovia que interliga A e B. Cada uma das R linhas seguintes descreve uma rodovia e contém três inteiros I, J e K, onde I e J representam cidades e K representa o custo da reforma da rodovia que interliga I e J.\nSaída\nSeu programa deve produzir uma única linha, contendo o menor custo possível para o conjunto de reformas de ferrovias e rodovias, obedecendo aos critérios estabelecidos.\nRestrições\n• 2 ≤ N ≤ 100; 1 ≤ F ≤ N(N − 1)/2; 1 ≤ R ≤ N(N − 1)/2 • 1 ≤ A < B ≤ N e 1 ≤ I < J ≤ N • 1 ≤ C ≤ 1000 e 1 ≤ K ≤ 1000 Informações sobre a pontuação\n• Para um conjunto de casos de testes totalizando 20 pontos, 2 ≤ N ≤ 6.\nExemplos",
    "examples": [
      [
        "3 3 2\n1 2 1000\n1 3 1000\n2 3 900\n1 3 800\n2 3 700",
        "1900"
      ],
      [
        "5 4 5\n3 4 300\n1 2 100\n2 4 300\n1 3 250\n4 5 600\n3 4 200\n2 3 100\n2 5 400\n1 5 450",
        "1050"
      ],
      [
        "5 2 3\n4 5 60\n2 3 60\n1 2 50\n1 4 50\n3 4 50",
        "220"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "copa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Matriz Escada",
    "description": "Joãozinho está aprendendo sobre matrizes. Hoje ele aprendeu como deixar matrizes na forma escada, e está exercitando. Para ajudá-lo, você deve escrever um programa que determine se o resultado dele realmente está no formato correto.\nUma matriz está na forma escada quando, para cada linha, as condições a seguir forem satisfeitas: • Se a linha só possuir zeros, então todas as linhas abaixo desta também só possuem zeros.\n• Caso contrário, seja X o elemento diferente de zero mais à esquerda da linha; então, para todas as linhas abaixo da linha de X, todos os elementos nas colunas à esquerda de X e na coluna de X são iguais a zero.\nEntrada\nA primeira linha possui dois inteiros N e M, as dimensões da matriz. Cada uma das N linhas seguintes contém M inteiros não-negativos, os elementos da matriz.\nSaída\nSeu programa deve produzir uma única linha, contendo o caractere ‘S’ caso a matriz esteja no formato escada, ou ‘N’, caso contrário.\nRestrições\n• 1 ≤ N ≤ 500 e 1 ≤ M ≤ 500.\n• Cada elemento da matriz está entre 0 e 105.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 80 pontos, N ≤ 50 e M ≤ 50.\nExemplos",
    "examples": [
      [
        "4 6\n1 2 9 9 9 9\n0 0 3 9 9 9\n0 0 0 0 5 9\n0 0 0 0 0 6",
        "S"
      ],
      [
        "5 8\n0 5 1 0 3 2 2 0\n0 0 0 0 4 0 1 2\n0 0 0 0 0 0 3 2\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
        "S"
      ],
      [
        "5 5\n1 1 2 3 4\n0 1 1 4 5\n0 1 2 3 6\n0 0 0 2 0\n0 0 0 0 0",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "escada"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fechadura",
    "description": "fechadura.py Joãozinho estava um dia chegando em casa quando percebeu que havia perdido a chave da porta. Desesperado, ele resolveu pedir ajuda a seu amigo Roberto, que em poucos segundos conseguiu abrir a porta usando suas ferramentas.\nAdmirado com a velocidade em que seu amigo conseguiu abrir a porta de sua casa sem a chave, ele decidiu perguntar como ele tinha conseguido aquilo. Roberto explicou que a fechadura da casa de Joãozinho é baseada em um sistema de pinos de tamanhos diferentes que, uma vez alinhados na mesma altura M, possibilitam a abertura da porta.\nUma fechadura é um conjunto de N pinos dispostos horizontalmente que podem ser movimentados para cima ou para baixo com o auxílio de uma chave de metal que, ao ser inserida dentro da fechadura, pode aumentar ou diminuir em 1mm, simultaneamente, a altura de quaisquer dois pinos consecutivos.\nJoãozinho como um exemplar perfeccionista decidiu desbloquear sua fechadura na menor quantidade de movimentos, onde cada movimento consiste em escolher dois pinos consecutivos da fechadura e aumentar ou diminuir a altura dos dois pinos em 1mm. Após todos os pinos possuírem altura exatamente igual a M, a fechadura é desbloqueada.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M representando, respectivamente, a quantidade de pinos da fechadura e a altura em que eles devem ficar para a fechadura ser desbloqueada.\nA segunda linha da entrada contém N inteiros, representando as alturas dos pinos da fechadura.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando a quantidade mínima de movimentos para desbloquear a fechadura.\nRestrições\n• 1 ≤ N ≤ 1000 • 1 ≤ M ≤ 100 • Cada altura dos pinos está entre 1 e 100.\n• É garantido que os casos de testes sempre possuem uma solução.\nExemplos",
    "examples": [
      [
        "4 50\n45 45 55 55",
        "10"
      ],
      [
        "5 84\n84 39 17 72 94",
        "77"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fechadura"
    },
    "imagesQuant": 0
  },
  {
    "name": "Língua do P",
    "description": "Uma brincadeira que crianças adoram é se comunicar na língua do P, acrescentando pê antes de cada sílaba, como uma forma de código para dificultar que outras pessoas entendam a conversa (pê-va pê-mos pê-no pê-ci pê-ne pê-ma?).\nJacy e Kátia adaptaram a língua do P para mensagens eletrônicas, acrescentando a letra P minúscula ‘p’ antes de cada letra das palavras de uma mensagem. Um exemplo de mensagem codificada e a respectiva mensagem decodificada é mostrada na figura abaixo.\nMensagem codificada Mensagem decodificada pVpapmpops papo pcpipnpepmpa Vamos ao cinema Sua tarefa é escrever um programa que decodifique uma mensagem escrita na língua do P eletrônica de Jacy e Kátia.\nEntrada\nA entrada consiste de uma única linha, contendo uma mensagem escrita na língua do P eletrônica de Jacy e Kátia.\nSaída\nSeu programa deve produzir uma única linha, contendo a mensagem decodificada.\nRestrições\n• A mensagem contém apenas letras maiúsculas e minúsculas e espaços em branco.\n• A mensagem tem entre 1 e 1000 caracteres.\n• Não há dois espaços em branco consecutivos na mensagem.\nExemplos",
    "examples": [
      [
        "pUpm pfpiplpmpe plpepgpapl",
        "Um filme legal"
      ],
      [
        "pA pppapppa pdpo pPpapppa",
        "A papa do Papa"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "lingua"
    },
    "imagesQuant": 0
  },
  {
    "name": "PacMan",
    "description": "Pacman é um jogo muito conhecido, onde o personagem tenta comer a maior quantidade possível de bolinhas, tendo ao mesmo tempo que fugir de vários fantasmas. Dessa vez, nosso personagem quer carregar a comida coletada para casa, mas o encontro com um fantasma, ao invés de terminar o jogo, faz com que toda a comida coletada seja roubada.\nNeste problema os fantasmas não se movem, e o jogador sempre faz o Pacman percorrer o seguinte caminho: 1. O Pacman começa no canto superior esquerdo do tabuleiro.\n2. O Pacman percorre toda a linha, da esquerda para direita, até chegar ao lado direito do tabuleiro.\n3. O jogador desce uma posição, e percorre toda a linha, desta vez da direita para a esquerda.\n4. As etapas 2 e 3 se repetem até que todo o tabuleiro tenha sido percorrido.\nInfelizmente, Pacman não pode ignorar os comandos do usuário para fugir dos fantasmas ou pegar mais comida, mas ele pode, a qualquer momento, se aproveitar de um bug de implementação e interromper o jogo, levando consigo toda a comida que estiver carregando.\nVocê deve escrever um programa que determine a maior quantidade de comida que o Pacman pode levar, se escolher a melhor hora possível para sair. Note que o jogador também tem a opção de não sair antes do final do jogo.\nEntrada\nA primeira linha contém um inteiro N, o tamanho do tabuleiro do jogo, que é quadrado. Cada uma das N linhas seguintes contém N caracteres, que podem ser (aspas para melhor clareza): • ‘.’ um espaço vazio; • ‘o’ uma comida; • ‘A’ um fantasma.\nSaída\nSeu programa deve produzir uma única linha contendo um único inteiro, a quantidade máxima de comida que o Pacman pode levar para casa.\nRestrições\n• 2 ≤ N ≤ 100 • Não há um fantasma e uma comida na mesma posição.\n• Não há fantasma nem comida na posição inicial do Pacman (ou seja, o primeiro caractere da primeira linha do tabuleiro é ‘.’).\nExemplos",
    "examples": [
      [
        "5\n.ooo.\n..ooA\n..Aoo\nAoooo\n..ooo",
        "6"
      ],
      [
        "3\n.o.\noAA\nooo",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pacman"
    },
    "imagesQuant": 0
  },
  {
    "name": "Passa Bolinha",
    "description": "O professor Miguel desafiou os alunos do colégio onde ele leciona com uma brincadeira que exige muita atenção! No pátio do colégio, os alunos formam um quadrado com N fileiras e N colunas, de modo que a primeira fileira esteja voltada para o norte. Cada um dos N2 alunos segura uma bandeira e tem um número colado na camiseta. Inicialmente, as bandeiras estão abaixadas e os alunos estão voltados para o norte. Todos os alunos têm que seguir exatamente o mesmo comportamento: • Ao receber a bolinha, levanta sua bandeira e realiza a seguinte ação quatro vezes, em sequência: – Vira-se 90 graus no sentido horário. Se o colega que ficou à sua frente tiver um número na camiseta maior ou igual ao seu, e estiver com a bandeira abaixada, passa a bolinha ao colega e aguarda que ele lhe devolva a bolinha; • Devolve a bolinha a quem lhe passou a bolinha inicialmente.\nNesta tarefa, você deve escrever um programa que, dados os números nas camisetas de cada aluno, e a posição do aluno a quem o professor Miguel vai entregar a bolinha, calcule quantas bandeiras estarão levantadas ao final, quando esse aluno devolver a bolinha ao professor. Por exemplo, a parte direita da figura abaixo mostra que sete alunos vão levantar a bandeira se o professor entregar inicialmente a bolinha ao aluno na fileira 3, coluna 1, como indicado na parte esquerda da figura.\n1 2 3 4 1 2 3 4 1 6 7 9 9 norte 1 6 7 9 9 2 1 4 3 5 2 1 4 3 5 3 2 4 5 1 3 2 4 5 1 4 1 3 2 9 4 1 3 2 9 Entrada\nA primeira linha da entrada contém um inteiro N, o número de fileiras (que é igual ao de colunas).\nA segunda linha contém dois números, I e J, indicando respectivamente, a fileira e a coluna do aluno a quem o professor Miguel entregará a bolinha. As N linhas seguintes contém N inteiros cada uma, indicando os números que estão nas camisetas dos alunos.\nSaída\nSeu programa deve imprimir apenas uma linha contendo um inteiro, o número de bandeiras que estarão levantadas ao final.\nRestrições\n• 1 ≤ N ≤ 100 • 1 ≤ I ≤ N e 1 ≤ J ≤ N • Os números nas camisetas estão entre 1 e 9, inclusive Exemplos\nEntrada\nSaída\n4 7 3 1",
    "examples": [
      [
        "4\n3 1\n6 7 9 9\n1 4 3 5\n2 4 5 1\n1 3 2 9",
        "7"
      ],
      [
        "6\n4 5\n9 4 9 6 1 9\n9 9 3 8 9 3\n9 9 3 9 9 6\n9 9 3 9 2 1\n9 9 9 9 7 9\n9 4 9 4 9 7",
        "21"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bolinha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Loteria",
    "description": "Flavinho sabe que a chance de ganhar na loteria é bem pequena. Ele gosta muito de estudar probabilidade! Mas, justamente por entender de probabilidades, Flavinho segue o ditado, “quem não arrisca, não petisca!”, e faz um jogo toda semana.\nNa loteria preferida dele, o jogador aposta seis números entre 1 e 99. No sorteio, também são escolhidos seis números ganhadores entre 1 e 99. Quem acerta 3, 4, 5 ou 6 números ganha como prêmio, respectivamente, um “terno”, uma “quadra”, uma “quina” ou uma “sena”.\nNesta tarefa, você deve escrever um programa que diga qual foi o prêmio que Flavinho ganhou, dados os seis números que ele apostou e os seis números que foram sorteados.\nEntrada\nA entrada consiste de duas linhas apenas. Na primeira linha são dados seis números inteiros distintos entre 1 e 99, representando a aposta do Flavinho. A segunda linha contém os seis números inteiros distintos sorteados.\nSaída\nSeu programa deve imprimir uma linha contendo uma palavra: “terno”, “quadra”, “quina” ou “sena”; caso Flavinho tenha acertado, respectivamente, 3, 4, 5, ou 6 números. Caso ele tenha acertado menos do que 3 números, imprima a palavra “azar”.\nExemplos",
    "examples": [
      [
        "34 55 77 12 23 99\n5 3 77 55 42 34",
        "terno"
      ],
      [
        "22 41 9 71 88 4\n41 9 88 71 4 22",
        "sena"
      ],
      [
        "25 51 53 17 19 87\n23 33 1 2 81 92",
        "azar"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "loteria"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sinuca",
    "description": "Nadine e Celine inventaram um passatempo com bolas de sinuca, pretas e brancas, que são colocadas uma por vez na mesa, de acordo com uma regra fixa. Agora elas estão tentando descobrir, com um computador, a cor da bola que vai ser colocada por último! Você pode ajuda-las? Funciona assim. No início, são colocadas N bolas formando a primeira fileira. Em seguida, um triângulo equilátero é formado, fileira a fileira, de acordo com a seguinte regra. Ao se colocar uma bola na nova fileira, ela ficará encostada em duas bolas da fileira anterior e sua cor será: • Preta, se estiver encostada em duas bolas de mesma cor; • Branca, se estiver encostada em duas bolas de cores diferentes.\nA figura abaixo ilustra a formação de um triângulo para N = 5.\nNesta tarefa, você deve escrever um programa que, dadas as cores das bolas da primeira fileira, descubra qual é a cor da bola que será colocada por último. Na figura, foi uma bola branca! Entrada\nA entrada é composta por duas linhas. A primeira linha contém um inteiro N, o número de bolas da primeira fileira. A segunda linha contém N inteiros representando as cores das bolas da primeira fileira. Se a bola é preta, o número será “1”, se for branca, será “-1”.\nSaída\nSeu programa deve imprimir uma linha contendo a palavra “preta”, se a última bola for preta; ou a palavra “branca”, se for branca.\nRestrições\n• 2 ≤ N ≤ 64 Exemplos",
    "examples": [
      [
        "5\n1 -1 1 1 -1",
        "branca"
      ],
      [
        "8\n1 -1 -1 1 -1 1 1 -1",
        "preta"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sinuca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Corredor",
    "description": "corredor.py Bruninho está programando um personagem virtual para o próximo desafio de um jogo de aventura em que, numa das fases, o personagem tem que entrar em um corredor, percorrer algumas salas e depois sair do corredor. Ele pode entrar apenas uma vez, e passar por cada sala apenas uma vez. Todas as salas possuem uma porta de entrada e uma de saída, como ilustra a parte (a) da figura abaixo. Ao passar por uma sala o jogador ganha um certo número de vidas (que pode ser negativo!). O objetivo é passar pelo corredor coletando a maior quantidade possível de vidas! Por sorte, sempre existe ao menos uma sala onde se ganha um número positivo de vidas.\n1 2 3 4 5 6 7 1 2 3 4 5 6 7 −2 5 −1 8 −11 7 3 −2 5 −1 8 −11 7 3 (a) (b) No exemplo acima, o personagem de Bruninho pode ganhar, no máximo, 12 vidas, por exemplo, entrando pela sala 2 e saindo pela sala 4, como mostrado na parte (b) da figura. Nesta tarefa, você deve escrever um programa que, dados os números de vidas correspondentes a cada sala do corredor, calcule a quantidade máxima de vidas que será possível ganhar.\nEntrada\nA entrada é composta por duas linhas. A primeira linha contém um inteiro N, o número de salas no corredor. A segunda linha contém N números inteiros, positivos ou negativos, indicando a quantidade de vidas que se ganha em cada sala.\nSaída\nSeu programa deve imprimir uma linha, com o número máximo de vidas que é possível ganhar.\nRestrições\n• 1 ≤ N ≤ 50000; e o número de vidas nas salas está entre −100 e 100 Informações sobre a Pontuação • Em um conjunto de casos de teste totalizando 30 pontos, N ≤ 1000 Exemplos",
    "examples": [
      [
        "7\n-2 5 -1 8 -11 7 3",
        "12"
      ],
      [
        "10\n50 42 -35 2 -60 5 30 -1 40 31",
        "105"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "corredor"
    },
    "imagesQuant": 0
  },
  {
    "name": "Decifra",
    "description": "Dimas é um renomado investigador de roubos a antiguidades e obras de arte, que sempre é chamado para casos intrigantes que necessitam de bastante trabalho mental. Desta vez, o quadro que sumiu de um conhecido museu na França foi a Donalisa, do pintor Leonardo da Silva. Este é um caso bastante especial, visto que o ladrão deixou uma frase escrita na parede, aparentemente criptografada. Que desafio para Dimas! É que ele não tem muito conhecimento nessa área de criptografia. Porém, ele usou de suas excelentes observações e conseguiu perceber que a frase foi escrita através de alguma permutação inversível do alfabeto.\nUma permutação inversível do alfabeto é apenas uma troca entre suas letras, duas a duas. Por exemplo, todo “a” será trocado por “m” e, portanto, todo “m” será trocado por “a”. Dessa forma, veja que dado um texto original, se aplicarmos a permutação, teremos uma frase criptografada; e se aplicarmos a mesma permutação novamente, teremos o texto original recuperado! Apesar de parecer fácil, a tradução se tornou uma tarefa difícil, já que a frase é bastante longa.\nÉ por isso que Dimas resolveu pedir sua ajuda, um exímio programador, para traduzir a frase criptografada, recuperando o texto original, e resolver o mistério! Entrada\nA primeira linha da entrada contém uma sequência de 26 letras minúsculas distintas, representando a permutação inversível usada na frase criptografada. A permutação é a seguinte: a letra “a” é trocada pela primeira letra dessa sequência; a letra “b” é trocada pela segunda letra dessa sequência; a letra “c” pela terceira; e assim por diante, seguindo a sequência padrão do alfabeto: abcdefghijklmnopqrstuvwxyz. A segunda linha da entrada consiste de uma frase criptografada, contendo apenas letras minúsculas.\nSaída\nSeu programa deve imprimir o texto original, de acordo com a permutação fornecida.\nRestrições\n• A frase criptografada não excede 104 caracteres.\nExemplos",
    "examples": [
      [
        "zcbedfghljkinmypqrutsvwxoa\nbzedzeymziluz",
        "cadeadonalisa"
      ],
      [
        "iohmunlcawygdfbqpvxzerjskt\nhaufhaimihbdqezihib",
        "cienciadacomputacao"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "decifra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo da Memória",
    "description": "Pedro e Paulo resolveram complicar um pouco o tradicional Jogo da Memória, em que os jogadores precisam virar duas cartas iguais. Eles colocam as cartas no chão, viradas para baixo, e fazem algumas linhas ligando pares de cartas, usando giz, de modo que para qualquer par de cartas (A,B) existe uma e apenas uma sequência de cartas distintas que leva de A até B através das linhas que eles desenharam. Com isso, ao virar duas cartas, o jogador ganha uma quantidade de pontos igual ao tamanho da sequência de linhas entre as duas cartas, se elas forem iguais. Se forem diferentes, o jogador perde aquela quantidade de pontos.\nPedro e Paulo, agora, estão estudando qual é a melhor estratégia para esse jogo e precisam da sua ajuda para resolver uma tarefa específica: dadas as ligações entre as N cartas, calcular a soma dos tamanhos das sequências entre todos os N/2 pares de cartas iguais! O jogo possui N cartas, de índices 1 até N. Cada carta possui a figura de um número de 1 até N/2 desenhada. Exatamente duas cartas possuem a figura de cada número entre 1 e N/2.\nEntrada\nA primeira linha da entrada contém o número de cartas N. A segunda linha da entrada contém N inteiros Ci, 1 ≤ i ≤ N, indicando qual número está anotado na carta de índice i. Cada uma das N −1 linhas seguintes contém dois números A e B, indicando que existe uma linha desenhada entre as cartas de índices A e B.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro, a soma dos tamanhos das sequências entre todos os N/2 pares de cartas iguais.\nRestrições\n• 2 ≤ N ≤ 50000, N é par • 1 ≤ Ci ≤ N/2 • 1 ≤ A ≤ N e 1 ≤ B ≤ N Informações sobre a Pontuação • Em um conjunto de casos de teste valendo 50 pontos, N ≤ 1000 Exemplos",
    "examples": [
      [
        "6\n2 2 1 1 3 3\n1 2\n3 4\n6 5\n2 6\n3 6",
        "3"
      ],
      [
        "8\n1 2 3 3 2 4 1 4\n1 2\n2 3\n2 6\n5 6\n6 8\n7 8\n4 7",
        "12"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "memoria"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quadrado",
    "description": "quadrado.py Um quadrado quase mágico, de dimensões N ×N, é um quadrado que obedece à seguinte condição.\nExiste um número inteiro positivo M tal que: para qualquer linha, a soma dos números da linha é igual a M; e para qualquer coluna, a soma dos números da coluna é também igual a M. O quadrado seria mágico, e não apenas quase mágico, se a soma das diagonais também fosse M. Por exemplo, a figura abaixo, parte (a), apresenta um quadrado quase mágico onde M = 21.\n4 9 8 3 6 6 11 8 2 8 6 7 6 4 11 4 3 8 (a) (b) Laura construiu um quadrado quase mágico e alterou, propositalmente, um dos números! Nesta tarefa, você deve escrever um programa que, dado o quadrado quase mágico alterado por Laura, descubra qual era o número original antes da alteração e qual número foi colocado no lugar. Por exemplo, na parte (b) da figura, o número original era 1, que Laura alterou para 7.\nEntrada\nA primeira linha da entrada contém apenas um número N, representando a dimensão do quadrado.\nAs N linhas seguintes contêm, cada uma, N números inteiros, definindo o quadrado. A entrada é garantidamente um quadrado quase mágico onde exatamente um número foi alterado.\nSaída\nSeu programa deve imprimir apenas uma linha contendo dois números: primeiro o número original e depois o número que Laura colocou no seu lugar.\nRestrições\n• 3 ≤ N ≤ 50; e o valor de todos os números está entre 1 e 10000 Exemplos\nEntrada\nSaída\n3 1 7",
    "examples": [
      [
        "3\n3 6 6\n8 6 7\n4 3 8",
        "1 7"
      ],
      [
        "4\n16 3 2 13\n5 10 11 8\n8 6 7 12\n4 15 14 1",
        "9 8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quadrado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Blefe",
    "description": "Pedro está desenvolvendo um jogo on-line para dois jogadores, em que o objetivo é forçar um erro do adversário, blefando. A questão é que, à medida que o jogo prossegue, mais tempo é necessário para verificar se uma jogada é válida ou não, ou seja, se é um blefe ou não. Daí que Pedro precisa da sua ajuda para implementar um algoritmo rápido para verificar se uma jogada é ou não um blefe.\nConsidere um conjunto A fixo de N números inteiros, positivos ou negativos, e uma sequência de números inteiros B, inicialmente vazia. Os jogadores se alternam em jogadas que consistem em incluir um número por vez no final da sequência B. Quando chega a sua vez, um jogador deve fazer uma de duas jogadas válidas possíveis: (i) incluir em B qualquer um dos números do conjunto A; (ii) ou incluir em B um número que é a soma de dois números quaisquer que já estejam em B (note a soma não é de números necessariamente distintos, pode ser a soma de um número com ele mesmo).\nNesta tarefa, você deve escrever um programa que, dado o conjunto A e uma sequência B, diga se todas as jogadas foram válidas, ou mostre qual é a primeira jogada inválida em B.\nEntrada\nA entrada consiste de três linhas. A primeira linha contém dois números N e M, respectivamente o tamanho do conjunto A e o tamanho da sequência B. A segunda linha contém os N números inteiros do conjunto A. A terceira linha contém os M números inteiros da sequência B.\nSaída\nSeu programa deve produzir uma única linha. A linha deve conter a palavra “sim” caso todas as jogadas em B sejam válidas; se houver alguma jogada inválida em B, a linha deve conter o primeiro número inválido em B.\nRestrições\n• 1 ≤ N ≤ 103 e 1 ≤ M ≤ 104 • O valor de todos os números em A e em B está entre −109 e 109 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 30 pontos, N ≤ 50 e M ≤ 500.\nExemplos",
    "examples": [
      [
        "6 11\n34 9 -2 77 -11 5\n34 5 -2 32 -11 -6 28 66 -2 -22 33",
        "sim"
      ],
      [
        "6 8\n34 9 -2 77 -11 5\n-11 77 -2 75 9 48 7 5",
        "48"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "blefe"
    },
    "imagesQuant": 0
  },
  {
    "name": "Frequência",
    "description": "frequencia.py Byteland é uma cidade bastante conhecida por propor variados desafios aos seus habitantes. Recentemente, o prefeito de Byteland, Joãozinho, decidiu propor um desafio que ele gosta de chamar de Tabuleiro da Frequência.\nA brincadeira ocorre da seguinte forma. Inicialmente, um tabuleiro com dimensões N × N é dado contendo apenas 0’s. Depois disso, Q operações são propostas, podendo ser de 4 tipos: • 1 X R: Atribuir o valor R a todos os números da linha X; • 2 X R: Atribuir o valor R a todos os números da coluna X; • 3 X: Imprimir o valor mais frequente na linha X; • 4 X: Imprimir o valor mais frequente da coluna X.\nJoãozinho é muito bom com computadores, mas também é bastante preguiçoso. Sabendo que você é um dos melhores programadores do mundo, ele decidiu pedir sua ajuda para resolver este problema.\nEntrada\nA primeira linha da entrada é composta por dois inteiros N e Q, representando, respectivamente, o tamanho do tabuleiro e a quantidade de operações. As próximas Q linhas da entrada vão conter as Q operações. O primeiro inteiro de cada linha vai indicar o tipo da operação. Caso seja 1 ou 2, será seguido por mais dois inteiros X e R. Caso seja 3 ou 4, será seguido por apenas mais um inteiro X.\nSaída\nPara cada operação do tipo 3 ou 4, seu programa deve produzir uma linha, contendo o valor da resposta correspondente. Se uma linha ou coluna tiver dois ou mais valores que se repetem o mesmo número de vezes, você deve imprimir o maior deles. Por exemplo, se uma linha tem os valores [5,7,7,2,5,2,1,3], tanto o 2, 5 e 7 se repetem duas vezes, então a resposta será 7, pois é o maior deles.\nRestrições\n• 1 ≤ N,Q ≤ 105 • 1 ≤ X ≤ N • 0 ≤ R ≤ 50 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 30 pontos, N ≤ 103.\n• Em um conjunto de casos de teste equivalente a 20 pontos, apenas as operações 2 e 3 serão usadas.\nExemplos",
    "examples": [
      [
        "5 9\n3 1\n1 1 2\n1 3 4\n1 4 4\n4 2\n2 2 5\n2 3 5\n2 4 5\n3 3",
        "0\n4\n5"
      ],
      [
        "2 4\n1 1 1\n2 2 2\n3 1\n3 2",
        "2\n2"
      ],
      [
        "3 6\n1 1 2\n1 2 3\n1 3 4\n4 3\n1 3 0\n4 3",
        "4\n3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "frequencia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Mapa",
    "description": "Byteland é uma cidade bastante movimentada, cujo prefeito, Joãozinho, vem lutando recentemente por sua inclusão no grupo das cinco cidades mais importantes de Byteworld. Para uma cidade ser considerada importante em Byteworld, ela precisa seguir alguns critérios. Antes de tudo, vamos definir Byteland, que é uma cidade como qualquer outra, onde esquinas se conectam através de ruas de mão dupla. Sabe-se também que existe um e somente um caminho, sem repetir esquinas, entre qualquer par de esquinas. Além disso, cada rua pode ser considerada importante ou não. Caso ela seja importante, a rua é pintada de branco e caso não seja, é pintada de azul.\nPara saber se uma cidade é importante ou não em Byteworld é necessario calcular um valor E: a quantidade de pares de esquinas (A,B) tal que existe ao menos uma rua importante no caminho entre A e B. Note que (A,B) e (B,A) são o mesmo par! O prefeito de Byteland resolveu pedir sua ajuda para calcular o valor E e saber, assim, se Byteland é ou não uma cidade importante para Byteworld.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando a quantidade de esquinas em Byteland.\nAs próximas N −1 linhas da entrada contêm cada uma três inteiros, A, B e C, indicando que existe uma rua entre as esquinas A e B pintada da cor C. Caso C seja 1, a rua é branca e importante, caso seja 0, a rua é azul e não importante.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o valor E definido acima.\nRestrições\n• 2 ≤ N ≤ 105 • 1 ≤ A,B ≤ N • 0 ≤ C ≤ 1 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 40 pontos, N ≤ 103.\nExemplos",
    "examples": [
      [
        "4\n1 2 0\n2 3 1\n3 4 0",
        "4"
      ],
      [
        "6\n1 2 0\n2 3 1\n3 4 0\n2 5 0\n5 6 1",
        "11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mapa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Notas",
    "description": "O professor Arquimedes precisa da sua ajuda para descobrir qual é a nota mais frequente entre as notas que os alunos dele tiraram na última prova. A turma tem N alunos e seu programa deve imprimir a nota que aparece mais vezes na lista de N notas. Se houver mais de uma nota mais frequente, você deve imprimir a maior delas! Por exemplo, se a turma tiver N = 10 alunos e as notas forem [20,25,85,40,25,90,25,40,55,40], as notas mais frequentes são 25 e 40, ocorrendo três vezes cada. Seu programa, então, deve imprimir 40.\nEntrada\nA entrada consiste de duas linhas. A primeira linha contém um número inteiro N, o número de alunos na turma. A segunda linha contém N inteiros, que é a lista de notas dos alunos.\nSaída\nSeu programa deve imprimir apenas uma linha contendo apenas um número, a nota mais frequente da lista.\nRestrições\n• 1 ≤ N ≤ 200 • O valor de todas as notas é um inteiro entre 0 e 100, inclusive Exemplos",
    "examples": [
      [
        "10\n20 25 85 40 25 90 25 40 55 40",
        "40"
      ],
      [
        "12\n45 0 33 70 12 55 70 70 90 55 70 100",
        "70"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "notas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tapetes",
    "description": "Nlogonia é conhecida por sua indústria de tradicionais tapetes quadrados, que são produzidos apenas com dimensões inteiras, para todos os números inteiros positivos. Quer dizer, os tapetes são de dimensão 1 × 1, 2 × 2, 3 × 3, e assim por diante. João Tapetão, grande empresário do setor, está planejando o próximo carregamento para exportação, que deve ser de exatamente N tapetes. Os tapetes são sempre enrolados e colocados em um tubo, um após o outro. Por exemplo, para um carregamento de N = 4 tapetes de dimensões 2 × 2, 4 × 4, 6 × 6 e 3 × 3, será necessário um tubo de comprimento 2 + 4 + 6 + 3 = 15. A questão é que o preço do tapete é proporcional à sua área, de modo que quanto maior a soma das áreas dos tapetes, maior o lucro do Tapetão. No exemplo anterior, a soma das áreas é 22 + 42 + 62 + 32 = 65. Só que daria para lucrar mais, com o mesmo tubo de comprimento 15, se o carregamento fosse com quatro tapetes de dimensões 1 × 1, 4 × 4, 7 × 7 e 3 × 3, cuja soma das áreas dá 75. Será que daria para lucrar ainda mais? O navio chegou e Tapetão precisa embarcar o carregamento. Há apenas um tubo de comprimento L e o carregamento deve conter exatamente N tapetes. Qual é a maior soma possível das áreas dos N tapetes que poderá ser transportada? Entrada\nA primeira e única linha da entrada contém dois inteiros, L e N, o comprimento do tubo e a quantidade de tapetes que deve transportada, respectivamente.\nSaída\nSeu programa deve produzir uma única linha, contendo apenas um inteiro, a maior soma possível das áreas dos tapetes.\nRestrições\n• N ≤ L • 1 ≤ L ≤ 106 e 1 ≤ N ≤ 105 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 30 pontos, L ≤ 50.\nExemplos",
    "examples": [
      [
        "2 2",
        "2"
      ],
      [
        "10 5",
        "40"
      ],
      [
        "1000000 9",
        "999984000072"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2014,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tapetes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fita Colorida",
    "description": "Roberto tem um conjunto de lápis com 10 tons diferentes de uma mesma cor, numerados de 0 a 9. Numa fita quadriculada, alguns quadrados foram coloridos inicialmente com o tom 0. Roberto precisa determinar, para cada quadrado Q não colorido, qual é a distância dele para o quadrado mais próximo de tom 0. A distância entre dois quadrados é definida com o número mínimo de movimentos para a esquerda, ou para a direita, para ir de um quadrado para o outro. O quadrado Q, então, deve ser colorido com o tom cuja numeração corresponde à distância determinada. Se a distância for maior ou igual a 9, o quadrado deve ser colorido com o tom 9. Seu programa deve colorir e imprimir a fita quadriculada dada na entrada.\nEntrada\nA primeira linha da entrada contém apenas um inteiro N, indicando o número de quadrados da fita. A segunda linha contém N números inteiros: “-1” se o quadrado não está colorido, e “0” se está colorido com o tom 0.\nSaída\nSeu programa deve escrever na saída a fita totalmente colorida, de acordo com a regra definida acima.\nRestrições\n• 3 ≤ N ≤ 10000; • Sempre existe pelo menos um “0” inicialmente na fita.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste somando 80 pontos, N ≤ 1000 Exemplos",
    "examples": [
      [
        "8\n-1 -1 0 -1 -1 -1 0 -1",
        "2 1 0 1 2 1 0 1"
      ],
      [
        "13\n-1 0 -1 -1 -1 -1 -1 -1 -1 -1 0 -1 -1",
        "1 0 1 2 3 4 4 3 2 1 0 1 2"
      ],
      [
        "6\n0 -1 -1 -1 -1 -1",
        "0 1 2 3 4 5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fita"
    },
    "imagesQuant": 0
  },
  {
    "name": "Móbile",
    "description": "O móbile na sala da Maria é composto de três hastes exatamente como na figura abaixo. Para que ele esteja completamente equilibrado, com todas as hastes na horizontal, os pesos das quatro bolas A, B, C e D têm que satisfazer todas as seguintes três condições: 1. A = B + C + D; e 2. B + C = D; e 3. B = C.\nA D B C Nesta tarefa, dados os pesos das quatro bolas, seu programa deve decidir se o móbile está ou não completamente equilibrado.\nEntrada\nA entrada consiste de quatro linhas contendo, cada uma, um número inteiro, indicando os pesos das bolas. Os números são dados na ordem: A, B, C e D.\nSaída\nSeu programa deve escrever uma única linha na saída, contendo o caractere “S” se o móbile estiver equilibrado, ou o caractere “N” se não estiver equilibrado.\nRestrições\n• 1 ≤ A,B,C,D ≤ 1000 Exemplos",
    "examples": [
      [
        "12\n3\n3\n6",
        "S"
      ],
      [
        "2002\n560\n560\n882",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mobile"
    },
    "imagesQuant": 0
  },
  {
    "name": "Prêmio do Milhão",
    "description": "Alice e Bia criaram uma página na Internet com informações sobre o Macaco-prego-de-peitoamarelo, uma espécie em extinção. A página mostra como todos podem ajudar a manter o habitat natural para evitar que a espécie seja extinta.\nUma empresa gostou tanto da iniciativa de Alice e Bia que prometeu doar um prêmio para que as duas amigas possam realizar outras iniciativas semelhantes. A empresa decidiu que o prêmio seria dado quando a soma do número de acessos à página chegasse a 1 milhão.\nDada a lista de acessos diários que ocorreram à página de Alice e Bia, escreva um programa para determinar quantos dias foram necessários para a soma dos acessos chegar a 1 milhão e as amigas ganharem o prêmio.\nEntrada\nA primeira linha da entrada contém um número inteiro N, que indica o número de dias que a lista contém. Cada uma das linhas seguintes contém um único inteiro A, o número de acessos em um dia. O primeiro número dado indica o número de acessos no primeiro dia, o segundo número dado indica o número de acessos no segundo dia, e assim por diante.\nSaída\nSeu programa deve escrever na saída uma única linha, contendo um único número inteiro, o número de dias que foram necessários para a soma dos acessos à pagina de Alice e Bia chegar a 1000000.\nRestrições\n• 1 ≤ N ≤ 103, ou seja, a lista tem no máximo 1000 números • 0 < A ≤ 106, ou seja, cada inteiro A da lista é positivo e menor do que ou igual a 1 milhão.\n• A soma de todos os valores A da lista é maior do que ou igual a 1 milhão (ou seja, Alice e Bia certamente ganham o prêmio).\nExemplos",
    "examples": [
      [
        "5\n100\n99900\n400000\n500000\n600000",
        "4"
      ],
      [
        "1\n1000000",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "premio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Arquivos",
    "description": "arquivos.py Aldo tem N arquivos em seu computador, cada um com um tamanho em bytes. Ele quer dividir estes arquivos em pastas, porém o sistema do computador é velho e só aceita pastas com as duas seguintes limitações: • Uma pasta pode ter no máximo dois arquivos • A soma dos tamanhos dos arquivos na pasta não pode exceder B bytes Como ele tem muitos arquivos ele prefere não criar muitas pastas. Dado o tamanho dos arquivos, calcule o número mínimo possível de pastas.\nVamos supor um exemplo que temos os arquivos de tamanho 1, 2 e 3, e que o limite de bytes seja 3. A solução é colocar os dois primeiros arquivos juntos, totalizando apenas 2 pastas.\nEntrada\nA entrada consiste de duas linhas. A primeira linha contém os números inteiros N e B. A segunda linha contém N inteiros indicando o tamanho de cada arquivo.\nSaída\nSeu programa deve escrever uma única linha na saída, contendo um único número inteiro, a quantidade mínima possível de pastas.\nRestrições\n• 1 ≤ N ≤ 105 • 1 ≤ B ≤ 109 • Os arquivos terão tamanho entre 1 e B, inclusive Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 10 • Em um conjunto de casos de teste somando 50 pontos, N ≤ 1000 Exemplos",
    "examples": [
      [
        "3 3\n1 2 3",
        "2"
      ],
      [
        "5 4\n4 3 1 2 2",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "arquivos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Linhas Cruzadas",
    "description": "Uma das atividades de recreação preferidas de Letícia é compor desenhos com linhas coloridas esticadas entre preguinhos numa base de madeira. Quanto mais cruzamentos entre pares de linhas, mais interessante fica a figura. Neste problema temos N pregos na vertical e N pregos na horizontal, como na figura abaixo. Os pregos na vertical possuem uma numeração fixa, de 1 a N, de baixo para cima. Os pregos na horizontal também são numerados de 1 a N, mas a ordem pode ser qualquer uma. Letícia vai sempre esticar uma linha entre cada par de pregos que tiverem o mesmo número.\nDada a ordem dos pregos horizontais, seu programa deve computar o número total de cruzamentos entre pares de linhas no desenho de Letícia. Por exemplo, os três desenhos da figura possuem, respectivamente, 0, 6 e 15 cruzamentos.\n6 6 6 5 5 5 4 4 4 3 3 3 2 2 2 1 1 1 1 2 3 4 5 6 1 5 3 4 6 2 6 5 4 3 2 1 Entrada\nA primeira linha da entrada contém um número natural N. A segunda linha contém N números naturais distintos de 1 a N, representando a ordem dos pregos na horizontal.\nSaída\nSeu programa deve escrever uma linha na saída, contendo o número de cruzamentos entre pares de linhas, conforme a descrição anterior.\nRestrições\n• 2 ≤ N ≤ 60000 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 60 pontos, N ≤ 30000 Exemplos",
    "examples": [
      [
        "6\n1 5 3 4 6 2",
        "6"
      ],
      [
        "15\n5 8 15 12 2 1 9 7 4 11 14 10 3 6 13",
        "49"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "linhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "O Banco Inteligente",
    "description": "Caixas automáticos nos bancos são uma invenção ótima mas, às vezes, a gente precisa de dinheiro trocado e a máquina entrega notas de R$100,00. Outras vezes, a gente quer sacar um valor um pouco maior e por questões de segurança gostaria de receber tudo em notas de R$100,00, mas a máquina entrega um monte de notas de R$20,00. O Banco Inteligente está tentando minimizar esse problema dando aos clientes a possibilidade de escolher o valor das notas na hora do saque.\nPara isso, eles precisam da sua ajuda para saber, dado o valor S do saque e quantas notas de cada valor a máquina tem, quantas formas distintas existem de entregar o valor S. O banco disponibiliza notas de 2, 5, 10, 20, 50 e 100. Por exemplo, se S = 22 e o número de notas de cada valor é N2 = 5,N5 = 4,N10 = 3,N20 = 10,N50 = 0 e N100 = 10, então há 4 formas distintas da máquina entregar o valor do saque: 20 + 2, 10 + 10 + 2, 10 + 5 + 5 + 2 e 5 + 5 + 5 + 5 + 2.\nEntrada\nA primeira linha da entrada contém um inteiro S, o valor do saque. A segunda linha contém seis inteiros N2,N5,N10,N20,N50 e N100, respectivamente, o número de notas de valores 2,5,10,20,50 e 100, disponíveis na máquina.\nSaída\nSeu programa deve imprimir um inteiro, o número de formas distintas da máquina entregar o saque.\nRestrições\n• 0 ≤ S ≤ 5000 e Ni ≤ 500 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 1000 e Ni ≤ 30 • Em um conjunto de casos de teste somando 40 pontos, N ≤ 1000 e Ni ≤ 50 Exemplos",
    "examples": [
      [
        "22\n5 4 3 10 0 10",
        "4"
      ],
      [
        "1000\n20 20 20 20 20 20",
        "34201"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "banco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caixinha de palitos",
    "description": "caixinha.py A caixinha contém N palitos de picolé, que precisam ser divididos entre os amigos Renato, Gustavo e Bruno, para um trabalho escolar. Cada amigo deve ganhar pelo menos 1 (um) palito. O professor vai determinar um número M máximo de palitos que cada um pode ganhar. Nesta tarefa, dados N e M, seu programa deve calcular quantas maneiras distintas existem de se dividir todos os N palitos entre os três amigos. Por exemplo, para N = 100: se M = 15, então há zero maneiras de se dividir, pois a soma dos números de palitos de Renato, Gustavo e Bruno seria no máximo 45, só que precisa ser sempre N; mas se M = 34, aí veja que haveria 6 maneiras distintas: Renato Gustavo Bruno 1 34 33 33 2 33 34 33 3 33 33 34 4 34 34 32 5 34 32 34 6 32 34 34 Entrada\nA entrada é composta por apenas uma linha com dois números naturais N e M, indicando, respectivamente, o número de palitos na caixinha e o número máximo que cada amigo pode ganhar.\nSaída\nSeu programa deve escrever uma única linha na saída, contendo um único número natural: quantas maneiras distintas existem de se dividir os N palitos entre os três amigos.\nRestrições\n• 3 ≤ N ≤ 100000, 1 ≤ M ≤ N; Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 300 • Em um conjunto de casos de teste somando 50 pontos, N ≤ 30000 Exemplos",
    "examples": [
      [
        "100 34",
        "6"
      ],
      [
        "100 15",
        "0"
      ],
      [
        "100000 98765",
        "4997567718"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caixinha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cobra coral",
    "description": "O professor Rui está desenvolvendo um sistema automático para identificar se uma cobra é uma coral verdadeira ou uma falsa coral. A cobra coral verdadeira é venenosa e os anéis coloridos no seu corpo seguem o padrão ...BVBPBVBPBVBP..., onde B,V e P representam as cores branco, vermelho e preto, respectivamente. Já a falsa coral não é venenosa e os anéis seguem o padrão ...BVPBVPBVPBVP....\nO problema é que os sensores do sistema do professor Rui produzem apenas uma sequência de quatro números representando um pedaço do padrão de cores. Só que ele não sabe qual número representa qual cor. Mas, por exemplo, se a sequência for 5 3 9 3, podemos dizer com certeza que é uma coral verdadeira, mesmo sem saber qual número representa qual cor! Você deve ajudar o professor Rui e escrever um programa que diga se a coral é verdadeira ou falsa.\nEntrada\nA entrada consiste de apenas uma linha, contendo quatro números inteiros.\nSaída\nSeu programa deve imprimir na saída uma linha com a letra “V” se a coral for verdadeira ou com a letra “F”, caso seja falsa.\nRestrições\n• Os quatro números têm valores entre 1 e 9, inclusive, e a sequência sempre representa uma coral verdadeira, ou uma coral falsa.\nExemplos",
    "examples": [
      [
        "5 3 9 3",
        "V"
      ],
      [
        "7 1 4 7",
        "F"
      ],
      [
        "6 2 6 8",
        "V"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "coral"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quebra-cabeça",
    "description": "Jade precisa da sua ajuda para montar o quebra-cabeças que ela ganhou de presente da sua tia Zoraide! As peças são encaixadas lado a lado e contêm, cada uma, uma letra maiúscula. Quando o quebra-cabeças estiver montado, a sequência de letras revelará uma frase secreta. Cada peça possui, além da letra, dois números: um na parte esquerda e outro na parte direita. Uma peça se encaixa depois de outra, na sequência, quando seu número esquerdo for igual ao número direito da outra peça. O número esquerdo da primeira peça é sempre o 0 (zero) e o número direito da última peça é sempre o 1 (um). Cada número aparece no máximo uma vez na parte esquerda de alguma peça, e no máximo uma vez na parte direita. Sempre é possível encaixar todas as peças e em apenas uma única sequência! Veja um exemplo na figura, com quatro peças formando a palavra “TEMA”.\nEntrada\nA primeira linha da entrada contém um número natural N, indicando o número de peças do quebracabeças. As N linhas seguintes contêm, cada uma, a descrição de uma peça na forma E C D, onde: E é o número esquerdo; C é a letra maiúscula; e D é o número direito.\nSaída\nSeu programa deve escrever uma única linha na saída, contendo a sequência de letras formada quando o quebra-cabeças está montado.\nRestrições\n• 3 ≤ N ≤ 100000; 0 ≤ E ≤ 200000; e 0 ≤ D ≤ 200000 • Há exatamente uma maneira de montar o quebra-cabeças utilizando todas as peças dadas.\nExemplos",
    "examples": [
      [
        "4\n5 A 1\n0 T 7\n3 M 5\n7 E 3",
        "TEMA"
      ],
      [
        "3\n197452 I 1\n0 O 39999\n39999 B 197452",
        "OBI"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quebra"
    },
    "imagesQuant": 1
  },
  {
    "name": "Família real",
    "description": "O rei de um reino muito muito distante deu uma grande festa para reunir todas as gerações dos seus descendentes: filhos e filhas, netos e netas, bisnetos e bisnetas, e assim por diante. Ele, que gosta muito de estatísticas, agora quer saber, para cada geração, qual a porcentagem de descendentes daquela geração que compareceu à festa. Você foi contratado para escrever um programa de computador que calcule as porcentagens de todas as gerações! O rei tem N descendentes, identificados com os números de 1 a N. O próprio rei será identificado com o número 0. Será dada apenas a informação, para cada descendente, de quem é o seu pai ou sua mãe, na linha de descendência que começa no rei. Além disso, claro, será dada a lista de todos que compareceram à festa.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, respectivamente, o número de descendentes e o número de participantes da festa. A segunda linha contém N números, representando os pais ou mães dos N descendentes, em ordem crescente: o primeiro número indica o pai ou a mãe do descendente de número 1, o segundo número indica o pai ou a mãe do descendente de número 2, e assim por diante. A terceira linha contém M números, identificando todos os descendentes que compareceram à festa.\nSaída\nSeu programa deve imprimir uma linha com uma lista de números reais, com precisão de duas casas decimais, indicando a porcentagem, para cada geração, dos descendentes daquela geração que compareceram à festa. O primeiro número deve ser a porcentagem dos filhos e filhas, o segundo dos netos e netas, e assim por diante.\nRestrições\n• 1 ≤ M ≤ N ≤ 10000 Exemplos",
    "examples": [
      [
        "9 5\n7 3 0 9 0 3 5 6 7\n3 2 8 1 9",
        "50.00 33.33 100.00 0.00"
      ],
      [
        "16 11\n15 9 2 8 6 11 0 3 0 8 12 0 9 6 16 12\n5 14 9 12 6 2 4 10 3 11 7",
        "100.00 50.00 66.67 50.00 100.00"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "real"
    },
    "imagesQuant": 0
  },
  {
    "name": "Código",
    "description": "Gabriel inventou um código para representar números naturais, usando uma sequência de zeros e uns. Funciona assim, o número natural é representado pela quantidade de vezes que o padrão “100” aparece na sequência. Por exemplo, na sequência 11101001010011110, o padrão aparece duas vezes; e na sequência 11101010111110111010101 ele não aparece nenhuma vez. Você deve ajudar Gabriel e implementar um programa que, dada a sequência de zeros e uns, calcule quantas vezes o padrão “100” aparece nela.\nEntrada\nA primeira linha da entrada contém um inteiro N, o tamanho da sequência. A segunda linha contém a sequência de N zeros e uns, separados por espaço em branco.\nSaída\nSeu programa deve imprimir um inteiro, quantas vezes o padrão “100” aparece na sequência.\nRestrições\n• 3 ≤ N ≤ 104 Exemplos",
    "examples": [
      [
        "17\n1 1 1 0 1 0 0 1 0 1 0 0 1 1 1 1 0",
        "2"
      ],
      [
        "8\n1 1 1 1 0 1 1 1",
        "0"
      ],
      [
        "3\n1 0 0",
        "1"
      ],
      [
        "3\n0 1 0",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "codigo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Impedido!",
    "description": "impedido.py A regra do impedimento no futebol pode parecer estranha, mas sem ela, se a gente pensar bem, o jogo ficaria muito chato! Ela funciona dadas as posições de três jogadores: L o jogador atacante que lança a bola; R o jogador atacante que recebe a bola; e D o último jogador defensor. E a regra vale somente se o jogador R está no seu campo de ataque; se o jogador R está no seu campo de defesa ou na linha divisória do meio campo, ele não está em impedimento. Neste problema o campo tem 100 metros de comprimento. Dadas as posições desses três jogadores, no momento exato do lançamento, haverá impedimento se e somente se a seguinte condição for verdadeira: (R > 50) e (L < R) e (R > D) A regra parece estranha, não é mesmo? Mas a gente nem precisa entender a lógica dela. O seu programa deve apenas determinar, dadas as três posições L,R e D, se há ou não impedimento, implementando exatamente a condição acima. A figura abaixo mostra um exemplo onde não há impedimento:   0 35 50 60 75 100 Entrada\nA entrada é composta de apenas uma linha, contendo os três inteiros L,R e D.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser “S” caso haja impedimento, ou “N” caso contrário.\nRestrições\n• 0 ≤ L ≤ 100 • 0 ≤ R ≤ 100 • 0 ≤ D ≤ 100 Exemplos",
    "examples": [
      [
        "35 60 75",
        "N"
      ],
      [
        "55 68 67",
        "S"
      ],
      [
        "66 80 80",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "impedido"
    },
    "imagesQuant": 0
  },
  {
    "name": "Torre",
    "description": "1 2 3 4 5 6 No jogo de xadrez, a torre é uma peça que pode se mover para qualquer 1 4 1 3 8 4 5 outra posição do tabuleiro na linha ou na coluna da posição que ela 2 9 2 8 9 2 7 ocupa. O professor Paulo está tentando inventar um novo tipo de jogo de xadrez onde todas as peças são torres, o tabuleiro também é 3 5 5 4 3 2 5 quadrado mas pode ter qualquer dimensão e cada posição do tabuleiro 4 8 2 9 1 9 8 é anotada com um número inteiro positivo, como na figura ao lado. 5 7 1 3 2 1 2 6 5 1 2 9 3 8 Ele definiu o peso de uma posição (i,j) como sendo a soma de todos os números que estejam na linha i com todos os números da coluna j, mas sem somar o número que está exatamente na posição (i,j). Quer dizer, se uma torre estiver na posição (i,j), o peso da posição é a soma de todas as posições que essa torre poderia atacar.\nO professor Paulo está solicitando a sua ajuda para implementar um programa que determine qual é o peso máximo entre todas as posições do tabuleiro. No exemplo da figura acima, com um tabuleiro de dimensão seis (ou seja, seis linhas por seis colunas), o peso máximo é 67, referente à posição (4,4).\nEntrada\nA primeira linha da entrada contém um inteiro N, representando a dimensão do tabuleiro. Cada uma das N linhas seguintes contém N inteiros positivos Xi, definindo os números em cada posição do tabuleiro.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o peso máximo entre todas as posições do tabuleiro.\nRestrições\n• 3 ≤ N ≤ 1000 • 0 < Xi ≤ 100 Informações sobre a pontuação\n• Em um conjunto de casos de teste cuja soma é 60 pontos, N ≤ 300.\nExemplos\nEntrada\nSaída\n6 67",
    "examples": [
      [
        "6\n4 1 3 8 4 5\n9 2 8 9 2 7\n5 5 4 3 2 5\n8 2 9 1 9 8\n7 1 3 2 1 2\n5 1 2 9 3 8",
        "67"
      ],
      [
        "3\n5 1 1\n5 2 1\n8 5 5",
        "20"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "torre"
    },
    "imagesQuant": 0
  },
  {
    "name": "Capitais",
    "description": "capitais.py A Linearlândia construiu uma rede de ferrovias de alta velocidade, 12 ligando certos pares de cidades, de modo que: é possível viajar entre qualquer par de cidades usando apenas ferrovias; e há apenas um caminho de ferrovias (sequência de ferrovias) entre qualquer 5 par de cidades. Existe muita disputa entre as capitais dos estados da Linearlândia e, por isso, ficou decidido que cada capital seria ligada por ferrovia a apenas uma outra cidade, e que toda cidade que não é capital seria ligada a outras cidades por duas ou mais ferrovias. Dessa forma, nenhuma viagem entre um par de capitais usando apenas ferrovias passa por uma terceira capital.\nVamos definir como distância-ferrovia entre duas cidades o número de ferrovias que é necessário utilizar para viajar entre essas duas cidades. Dada apenas a informação sobre quais pares de cidades estão ligados por uma ferrovia, você deve escrever um programa para computar a menor distância-ferrovia entre todos os pares de capitais. Na figura acima, há nove capitais e a menor distância-ferrovia entre qualquer par de capitais é 3, entre as capitais 5 e 12.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de cidades. As cidades são identificadas por inteiros de 1 a N. As N−1 linhas seguintes contém, cada uma, dois inteiros U e V , representando um par de cidades ligadas por uma ferrovia.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, a menor distância-ferrovia entre todos os pares capitais.\nRestrições\n• 2 ≤ N ≤ 105 Informações sobre a pontuação\n• Em um conjunto de casos de teste cuja soma é 40 pontos, N ≤ 104; Exemplos",
    "examples": [
      [
        "8\n1 2\n2 3\n3 4\n5 3\n6 5\n6 7\n8 7",
        "3"
      ],
      [
        "2\n1 2",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "capitais"
    },
    "imagesQuant": 0
  },
  {
    "name": "Impedimento!",
    "description": "impedimento.js ou impedimento.py A regra do impedimento no futebol pode parecer estranha, mas sem ela, se a gente pensar bem, o jogo ficaria muito chato! Ela funciona dadas as posições de três jogadores: L o jogador atacante que lança a bola; R o jogador atacante que recebe a bola; e D o último jogador defensor. E a regra vale somente se o jogador R está no seu campo de ataque; se o jogador R está no seu campo de defesa ou na linha divisória do meio campo, ele não está em impedimento. Neste problema o campo tem 100 metros de comprimento. Dadas as posições desses três jogadores, no momento exato do lançamento, haverá impedimento se e somente se a seguinte condição for verdadeira: (R > 50) e (L < R) e (R > D) A regra parece estranha, não é mesmo? Mas a gente nem precisa entender a lógica dela. O seu programa deve apenas determinar, dadas as três posições L,R e D, se há ou não impedimento, implementando exatamente a condição acima. A figura abaixo mostra um exemplo onde não há impedimento:   0 35 50 60 75 100 Entrada\nA entrada é composta de apenas uma linha, contendo os três inteiros L,R e D.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser “S” caso haja impedimento, ou “N” caso contrário.\nRestrições\n• 0 ≤ L ≤ 100 • 0 ≤ R ≤ 100 • 0 ≤ D ≤ 100 Exemplos",
    "examples": [
      [
        "35 60 75",
        "N"
      ],
      [
        "55 68 67",
        "S"
      ],
      [
        "66 80 80",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "impedimento"
    },
    "imagesQuant": 0
  },
  {
    "name": "Letras",
    "description": "Uma cadeia de caracteres é uma sequência de letras do alfabeto. Uma cadeia de caracteres crescente é uma sequência de letras onde a próxima letra (da esquerda para a direita) nunca ocorre antes no alfabeto do que a letra anterior. Por exemplo ABBD é crescente, enquanto ABBAD não é crescente.\nUma subsequência de uma cadeia de caracteres é uma cadeia de caracteres que pode ser obtida a partir da remoção de zero ou mais caracteres da cadeia de caracteres original. Por exemplo ANNA é uma subsequência de BANANAS. Outro exemplo seria ANNS, que é uma subsequência crescente de BANANAS.\nDada uma cadeia de caracteres S, escreva um programa para determinar o tamanho da maior subsequência de S que é uma cadeia de caracteres crescente.\nEntrada\nA entrada consiste em uma única linha, contendo uma cadeia de caracteres S.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o tamanho da maior subsequência de S que é uma cadeia de caracteres crescente.\nRestrições\n• A cadeia de caracteres de entrada contém letras maiúsculas do alfabeto, de A até Z.\n• 1 ≤ comprimento(S) ≤ 3 × 105.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste valendo 20 pontos: comprimento(S) ≤ 20.\n• Em um conjunto de casos de teste valendo 30 pontos: comprimento(S) ≤ 3000.\nExemplos",
    "examples": [
      [
        "BANANAS",
        "4"
      ],
      [
        "AAXBBXZZX",
        "7"
      ],
      [
        "AAA",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "letras"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cálculo",
    "description": "calculo.py Os computadores armazenam todas as informações usando representações binárias, ou seja, representações que utilizam apenas 0’s e 1’s. Há vários padrões para a representação de informação na forma binária, como por exemplo “complemento-de-dois” (usado para números inteiros), “ascii” (usado para caracteres e letras sem acentos), ou “ieee-754” (usado para números reais).\nNeste problema vamos usar a representação “obi-2015” para certos valores positivos e menores do que 1. Na “obi-2015”, o número é representado por uma sequência de 0’s e 1’s de comprimento arbitrário. Lendo a representação da esquerda para a direita, o primeiro dígito binário representa o valor 2−1, o segundo representa 2−2, o terceiro 2−3, e assim por diante. A representação utiliza sempre o menor número de dígitos possível (ou seja, desta forma o dígito mais à direita é sempre 1).\nPor exemplo, a sequência de dígitos binários 0 1 representa o seguinte valor: 0 ∗ 2−1 + 1 ∗ 2−2 = 0.25 Já a sequência de dígitos binários 1 0 1 0 1 1 representa o seguinte valor: 1 ∗ 2−1 + 0 ∗ 2−2 + 1 ∗ 2−3 + 0 ∗ 2−4 + 1 ∗ 2−5 + 1 ∗ 2−6 = 0.671875 Sua tarefa é, dados dois números X e Y , representados no padrão obi-2015, determinar a representação da soma X + Y , também no padrão obi-2015.\nEntrada\nA primeira linha contém os inteiros M e N, representando respectivamente o número de dígitos binários de X e de Y . A segunda linha contém M números Xi, representando X no padrão obi2015. A terceira linha contém N números Yj, representando Y no padrão obi-2015.\nSaída\nSeu programa deve produzir uma única linha, contendo a representação do valor X + Y no padrão obi-2015.\nRestrições\n• 1 ≤ M,N ≤ 103 • 0 < X,Y < 1 • Xi ∈ {0,1}, para 0 ≤ i ≤ M • Yj ∈ {0,1}, para 0 ≤ j ≤ N • X + Y < 1 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 5 e M ≤ 5.\nExemplos",
    "examples": [
      [
        "2 3\n0 1\n0 0 1",
        "0 1 1"
      ],
      [
        "5 4\n1 0 1 1 1\n0 0 0 1",
        "1 1 0 0 1"
      ],
      [
        "4 5\n0 1 1 1\n0 0 1 1 1",
        "1 0 1 0 1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "calculo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chocolate em barra",
    "description": "chocolate.js ou chocolate.py Vô Quico comprou uma barra de chocolate para suas duas netas Lúcia e Beatriz. A barra é composta de N linhas e N colunas de quadrados, onde N é sempre um número par. Em exatamente dois quadrados, que podem estar em qualquer posição na barra, há uma figurinha colada. Vô Quico gostaria de dar dois pedaços de tamanhos iguais, um para cada neta, cada pedaço contendo uma figurinha. Mais precisamente, ele gostaria de dividir a barra bem na metade, com um único corte vertical ou horizontal, deixando uma figurinha em cada pedaço.\n1 2 3 4 5 6 1 1 2 3 4 2 1 3 2 4 3 5 4 6 A figura acima mostra dois exemplos. A barra da esquerda, com N = 4, vô Quico pode dividir na metade com um corte horizontal, e cada metade contém uma figurinha. Mas a barra da direita, com N = 6, ele não consegue dividir em dois pedaços iguais, separando as figurinhas, com um único corte horizontal ou vertical.\nDados N e as posições das duas figurinhas, seu programa deve dizer se é, ou não, possível dividir a barra em dois pedaços de tamanhos iguais, com um único corte horizontal ou vertical, deixando uma figurinha em cada pedaço.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando as dimensões da barra (número de linhas e de colunas). A segunda linha contém dois inteiros X1 e Y1, representando as coordenadas da primeira figurinha. A terceira linha contém dois inteiros X2 e Y2, representando as coordenadas da segunda figurinha.\nSaída\nSeu programa deve imprimir apenas uma linha contendo um único caractere: “S”, caso seja possível dividir a barra em pedaços iguais com um único corte horizontal ou vertical, separando as figurinhas, ou “N” caso não seja possível.\nRestrições\n• 2 ≤ N ≤ 1000, N é sempre par; • 1 ≤ X1,Y1,X2,Y2 ≤ N.\nExemplos",
    "examples": [
      [
        "4\n1 2\n4 2",
        "S"
      ],
      [
        "6\n3 4\n2 6",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chocolate"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fila",
    "description": "Na cerimônia de encerramento da IOI, os competidores formam uma fila à medida que vão chegando ao local. Os competidores são desorganizados e entram na fila perto de seus novos amigos, ou seja, cada competidor escolhe uma posição arbitrária da fila para entrar. Logo na entrada do local há um telão que mostra fotografias e vídeos dos competidores durante a competição. Há uma grande diferença entre as alturas dos competidores, inclusive pelas diferenças de idade, e para que todos possam ver o telão, deve-se evitar que um competidor muito alto fique na frente de um competidor muito baixo, a não ser que esse competidor mais alto esteja longe, mais à frente na fila.\nA organização da IOI está monitorando a fila e pediu que você faça um programa que inicialmente receba a descrição da fila inicial (número N de pessoas e suas alturas A1,A2,...,AN, pela ordem na fila, onde A1 é a altura do primeiro da fila). Em seguida, seu programa deve processar dois tipos de operações: • na operação tipo 0, seu programa recebe a informação que um novo competidor, de altura H, acabou de entrar na fila, exatamente atrás do I-ésimo competidor na fila (para I = 0 o novo competidor entrou no começo da fila) • na operação tipo 1, seu programa recebe dois inteiros, I e D, e deve responder a uma consulta: considere a I-ésima pessoa na fila, digamos, P, e determine a posição na fila da pessoa mais próxima de P que está à frente de P e cuja altura é maior do que HI +D (onde HI é a altura de P).\nEntrada\nA primeira linha da entrada contém um único número inteiro N, indicando o número de pessoas na fila inicial. A segunda linha da entrada contém os N números inteiros A1,A2,...,AN, as alturas de cada pessoa da fila. A terceira linha contém um único inteiro Q indicando o número de operações.\nCada uma das Q linhas seguintes contém três números inteiros números T, I e X, descrevendo uma operação: T indica o tipo da operação, I representa uma posição na fila e X é a altura H do novo competidor (na operação tipo 0) ou o parâmetro D (na operação do tipo 1).\nRestrições\n• 0 ≤ N ≤ 6 × 105 • 1 ≤ Q ≤ 6 × 105 • 1 ≤ Ai ≤ 109 para todo i, 1 ≤ i ≤ N • 1 ≤ X ≤ 109 Informações sobre a pontuação\n• Em um conjunto de casos de testes somando 40 pontos, N ≤ 2 × 105, Q ≤ 2 × 105 e todas as operações são do tipo 1; • Em um conjunto de casos de testes somando 80 pontos, N ≤ 2 × 105 e Q ≤ 2 × 105.\nExemplos",
    "examples": [
      [
        "5\n10 5 7 8 2\n6\n1 5 6\n0 1 11\n1 6 6\n0 0 13\n1 6 4\n1 6 5",
        "1\n2\n1\n0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fila"
    },
    "imagesQuant": 0
  },
  {
    "name": "Macacos me mordam!",
    "description": "macacos.py Em uma floresta há N árvores alinhadas. A i-ésima árvore tem altura Hi e está localizada na posição Xi da floresta. Obi, o macaco camarada, está na primeira árvore da floresta, e deseja ir até a última árvore da floresta, porque ele ouviu dizer que há muitas bananas esperando por ele lá.\nPara ir até a última árvore, Obi vai pular entre as árvores. Obi é um macaco muito ágil, e consegue pular de uma árvore A para outra árvore B sempre que, do topo da árvore A ele consegue enxergar o topo da árvore B, independente das posições das árvores A e B. Mas Obi é também um macaco muito preguiçoso, e quer pular o menor número de vezes possível.\n4 3 2 1 0 1 2 3 4 Na figura acima podemos ver que, do topo da árvore na posicão 2, Obi não consegue enxergar o topo da árvore na posição 4, e portanto ele não pode pular de uma para outra sem passar pela árvore na posição 3. Assim, para o caso da figura acima, para ir da árvore 1 para a árvore 4 ele tem que passar por todas as árvores, dando um total de três pulos.\nDada a descrição da floresta, você deve escrever um programa para determinar o menor número de pulos que Obi deve dar para ir da primeira à última árvore da floresta.\nEntrada\nA primeira linha da entrada contém um número N, indicando a quantidade de árvores na floresta.\nCada uma das N linhas seguintes descreve uma árvore da floresta, e contém dois inteiros Xi e Hi, respectivamente a posição e a altura de uma árvore. Cada árvore ocupa uma posição distinta na floresta (ou seja, não há duas árvores com o mesmo valor Xi).\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, a menor a quantidade de pulos que Obi deve dar para ir da primeira até a última árvore da floresta.\nRestrições\n• 2 ≤ N ≤ 3 × 105 • 1 ≤ Hi,Xi ≤ 109 Informações sobre a pontuação\n• Em um conjunto de casos de teste cuja soma é 40 pontos: 2 ≤ N ≤ 300 Exemplos",
    "examples": [
      [
        "4\n1 3\n2 4\n3 3\n4 1",
        "3"
      ],
      [
        "4\n1 3\n2 4\n3 3\n4 2",
        "2"
      ],
      [
        "10\n3 7\n1 3\n5 6\n6 6\n9 6\n8 15\n12 5\n13 1\n10 9\n14 2",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "macacos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Mina",
    "description": "Nossa mina de ouro será representada por N linhas e N colunas de quadrados. O mineiro está no quadrado inicial (superior esquerdo) e precisa cavar até o quadrado final (inferior direito), onde existe a maior concentração de ouro da mina. Alguns quadrados, porém, estão bloqueados por pedras, o que dificulta o trabalho. Sabendo que o mineiro pode realizar apenas movimentos ortogonais, seu programa deve calcular o número mínimo de quadrados bloqueados pelos quais o mineiro tem que passar para chegar no quadrado inferior direito. Os quadrados inicial e final nunca estão bloqueados. A figura abaixo ilustra três possíveis minas, para N = 8, para as quais os números mínimos de quadrados bloqueados são, respectivamente, três, zero e nove. A figura também mostra três possíveis trajetórias mínimas, como exemplo.\nEntrada\nA primeira linha da entrada contém um inteiro N, 2 ≤ N ≤ 100, representando as dimensões da mina. Cada uma das N linhas seguintes contém N inteiros, definindo os quadrados da mina. O inteiro 0 representa um quadrado livre e o inteiro 1, um quadrado bloqueado.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número mínimo de quadrados bloqueados pelos quais o mineiro tem que passar para chegar no quadrado final.\nExemplos",
    "examples": [
      [
        "6\n0 1 0 0 0 0\n1 1 0 0 1 1\n1 0 1 1 1 1\n0 0 0 1 1 0\n0 0 1 1 1 0\n0 1 0 0 0 0",
        "3"
      ],
      [
        "2\n0 0\n1 0",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2015,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mina"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo de par ou ímpar",
    "description": "Dois amigos, Alice e Bob, estão jogando um jogo muito simples, em que um deles grita ou “par” ou “ímpar” e o outro imediatamente responde ao contrário, respectivamente “ímpar” ou “par”. Em seguida, ambos exibem ao mesmo tempo uma mão cada um, em que alguns dedos estão estendidos e outros dobrados. Então eles contam o número total de dedos estendidos. Se a soma for par, quem gritou “par” ganha. Se a soma for ímpar, quem gritou “ímpar” ganha.\nPor exemplo, suponhamos que a Alice gritou “par” e o Bob respondeu “ímpar”. Em seguida, Alice não deixou nenhum dos seus dedos estendidos, ao passo que Bob deixou três dedos estendidos. A soma então é três, que é ímpar, portanto Bob ganhou.\nSeu programa deve determinar quem ganhou, tendo a informação de quem gritou par e o número de dedos estendidos de cada um.\nEntrada\nA entrada contém três linhas, cada uma com um número inteiro, P, D1 e D2, nesta ordem. Se P = 0 então Alice gritou “par”, ao passo que se P = 1 então Bob gritou “par”. Os números D1 e D2 indicam, respectivamente, o número de dedos estendidos da Alice e do Bob.\nSaída\nSeu programa deverá imprimir uma única linha, contendo um único número inteiro, que deve ser 0 se Alice foi a ganhadora, ou 1 se Bob foi o ganhador.\nRestrições\n• P = 0 ou P = 1 • 0 ≤ D1 ≤ 5 • 0 ≤ D2 ≤ 5 Exemplos",
    "examples": [
      [
        "0\n0\n3",
        "1"
      ],
      [
        "1\n0\n3",
        "0"
      ],
      [
        "0\n1\n5",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Lâmpadas",
    "description": "lampadas.py2 ou lampadas.py3 Você está de volta em seu hotel na Tailândia depois de um dia de mergulhos. O seu quarto tem duas lâmpadas. Vamos chamá-las de A e B. No hotel há dois interruptores, que chamaremos de I1 e I2. Ao apertar I1, a lâmpada A troca de estado, ou seja, acende se estiver apagada e apaga se estiver acesa. Se apertar I2, ambas as lâmpadas A e B trocam de estado.\nAs lâmpadas inicialmente estão ambas apagadas. Seu amigo resolveu bolar um desafio para você.\nEle irá apertar os interruptores em uma certa sequência, e gostaria que você respondesse o estado final das lâmpadas A e B.\nEntrada\nA primeira linha contém um número N que representa quantas vezes seu amigo irá apertar algum interruptor. Na linha seguinte seguirão N números, que pode ser 1, se o interruptor I1 foi apertado, ou 2, se o interruptor I2 foi apertado.\nSaída\nSeu programa deve imprimir dois valores, em linhas separadas.\nNa primeira linha, imprima 1 se a lâmpada A estiver acesa no final das operações e 0 caso contrário.\nNa segunda linha, imprima 1 se a lâmpada B estiver acesa no final das operações e 0 caso contrário.\nRestrições\n• 1 ≤ N ≤ 105 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, N = 3.\nExemplos",
    "examples": [
      [
        "3\n1 2 2",
        "1\n0"
      ],
      [
        "4\n2 1 2 2",
        "0\n1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "lampadas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Plantação de morango",
    "description": "morango.py2 ou morango.py3 Os administradores da Fazenda Fartura planejam criar uma nova plantação de morangos, no formato retangular. Eles têm vários locais possíveis para a nova plantação, com diferentes dimensões de comprimento e largura. Para os administradores, o melhor local é aquele que tem a maior área.\nEles gostariam de ter um programa de computador que, dadas as dimensões de dois locais, determina o que tem maior área. Você pode ajudá-los? Entrada\nA entrada contém quatro linhas, cada uma contendo um número inteiro. As duas primeiras linhas indicam as dimensões (comprimento e largura) de um dos possíveis locais. As duas últimas linhas indicam as dimensões (comprimento e largura) de um outro possível local para a plantação de morangos. As dimensões são dadas em metros.\nSaída\nSeu programa deve escrever uma linha contendo um único inteiro, a área, em metros quadrados, do melhor local para a plantação, entre os dois locais dados na entrada.\nRestrições\n• 1 ≤ comprimento ≤ 100 • 1 ≤ largura ≤ 100 Exemplos",
    "examples": [
      [
        "30\n8\n11\n56",
        "616"
      ],
      [
        "12\n38\n5\n20",
        "456"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "morango"
    },
    "imagesQuant": 0
  },
  {
    "name": "Clube dos Cinco",
    "description": "clube.py3 No Clube dos Cinco são oferecidos três esportes aos associados: tiro com arco, badminton e canoagem. Cada associado pode participar de no máximo dois esportes, mas a administração do clube suspeita que algumas pessoas estejam ultrapassando esse limite. A fim de descobrir a verdade, perguntaram aos treinadores quantas pessoas estavam frequentando suas aulas, resultando nos seguintes dados: • O número A de pessoas que praticam tiro com arco; • O número B de pessoas que praticam badminton; • O número C de pessoas que praticam canoagem.\nAlém disso, perguntaram aos membros quais esportes eles praticam. Obviamente, os associados que praticam três esportes mentiram, mas considere que outros falaram a verdade. Os dados dos associados foram resumidos nas seguintes informações: • O número D de pessoas que praticam tiro com arco e badminton; • O número E de pessoas que praticam tiro com arco e canoagem; • O número F de pessoas que praticam badminton e canoagem; • O número G de pessoas que não praticam nenhum esporte.\nVocê ficou encarregado da a tarefa de descobrir se a suspeita é verdadeira. Dados o número N de associados do clube e os números A,B,C,D,E,F e G descritos acima, descubra se existe alguma pessoa que faz três esportes.\nEntrada\nA primeira linha contém um inteiros N, representando o número de associados. A segunda linha contém sete inteiros A,B,C,D,E,F e G como descritos no enunciado.\nSaída\nSeu programa deve produzir uma única linha, contendo uma única letra, \"S\" se algum associado participa de três esportes e \"N\", caso contrário.\nRestrições\n• 1 ≤ N ≤ 104.\n• 0 ≤ A,B,C,D,E,F,G ≤ N.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 50 pontos, D = 0, E = 0 e F = 0.\nExemplos",
    "examples": [
      [
        "7\n4 4 4 1 1 2 0",
        "S"
      ],
      [
        "8\n4 4 4 1 1 2 0",
        "N"
      ],
      [
        "10\n4 4 4 1 1 1 1",
        "N"
      ],
      [
        "7\n4 4 4 1 1 1 1",
        "S"
      ],
      [
        "10\n4 4 4 0 0 0 1",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "clube"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tacos de bilhar",
    "description": "tacos.py3 Jogos de bilhar, em que tacos são usados para arremessar uma bola contra outras em uma mesa, têm muitas variantes, como sinunca, mata-mata, bilhar francês e outras. São muito antigos, havendo relatos sobre jogos similares desde 1340. O Sr. Jorge é um renomado artesão que fabrica tacos de bilhar sob encomenda. Jogadores de todo o mundo procuram o Sr. Jorge, para confeccionar tacos nos mais diversos comprimentos, pois seus tacos são perfeitos, bem balanceados e muito bonitos.\nCada vez que um cliente pede um taco de um dado comprimento, o Sr. Jorge primeiro verifica se ele tem um taco com esse comprimento no estoque. Se tem, ele envia o taco para o cliente. Se não tem, ele faz duas cópias do taco, envia uma para o cliente e guarda a outra no estoque. Assim, ele nunca tem no estoque mais do que um taco com um determinado comprimento.\nO estoque do Sr. Jorge está muito grande, e ele tem perdido muito tempo procurando por tacos.\nEle pensa em usar um sistema computadorizado para manter o seu estoque de tacos, e precisa de sua ajuda. Dadas as consultas ao estoque calcule o número total de tacos fabricados, supondo que inicialmente o estoque esteja vazio..\nEntrada\nA primeira linha da entrada contém um inteiro C que indica o número de consultas ao estoque.\nA segunda linha contém C números inteiros, indicando as consultas ao estoque. Cada valor de consulta indica o comprimento de um taco desejado. As consultas são dadas na entrada na ordem em que o Sr. Jorge as executa. Assuma que o estoque está vazio inicialmente.\nSaída\nSeu programa deverá imprimir um único número, o número de tacos fabricados.\nRestrições\n• 1 ≤ C ≤ 105 • 1 ≤ comprimento dos tacos ≤ 106 Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 40 pontos, C ≤ 1000.\nExemplos",
    "examples": [
      [
        "4\n80 100 80 50",
        "6"
      ],
      [
        "1\n1000",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tacos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chaves",
    "description": "chaves.py3 Seu amigo Juca está enfrentando problemas com programação. Na linguagem C, algumas partes do código devem ser colocadas entre chaves \"{ }\" e ele frequentemente esquece de colocá-las ou as coloca de forma errada. Porém, como Juca tem dificuldade para entender os erros de compilação, ele nunca sabe exatamente o que procurar. Por isso ele te pediu para fazer um programa que determine se um código está com as chaves balanceadas, ou seja, se é válido. Um código está com as chaves balanceadas se: • Não há chaves (como por exemplo “Bom” ou “Correto”); • O código é composto por uma sequência de códigos válidos (como por exemplo “Bom Correto” ou “{}{}” ou “{}Correto”); ou • O código é formado por um código válido entre chaves (como por exemplo “{{}}” ou “{Bom}”).\nO código de Juca é composto por N linhas de até 100 caracteres cada. Pode haver linhas vazias e espaços consecutivos.\nEntrada\nA primeira linha contém um inteiro N, representando o número de linhas no código. As N linhas seguintes contém até 100 caracteres.\nSaída\nSeu programa deve produzir uma única linha, contendo uma única letra, \"S\" se o código está com as chaves balanceadas e \"N\", caso contrário.\nRestrições\n• 1 ≤ N ≤ 103.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 50 pontos, N = 1 e todos os carateres são \"{\" ou \"}\" (como no terceiro exemplo).\nExemplos",
    "examples": [
      [
        "6\n#include <stdio.h>\nint main(void)\n{\nprintf(\"Hello World\\n\");\n}",
        "S"
      ],
      [
        "5\n{I{N{\n}F{])\n}O}R{\n}M}A{T}I{C@!!{onze}!!}",
        "S"
      ],
      [
        "1\n{{}}{{}}}",
        "N"
      ],
      [
        "1\n{{{3}}}{{{2}}a{{1}}{0}",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chaves"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chuva",
    "description": "chuva.py3 É período de chuva no Reino Quadrado. Nos últimos anos, o Rei Maior Quadrado (RMQ) ordenou a construção de uma enorme piscina para refrescar seus súditos. A piscina é composta por diversas seções de mesma largura e comprimento, mas podem ter alturas diferentes. A altura de cada seção é um número inteiro em metros.\nDurante o período de chuvas fortes, o Rei nem precisa gastar água para encher a piscina - basta deixar que a chuva faça esse trabalho. A chuva cai uniformemente em todas as seções da piscina, enchendo - até que não haja mais capacidade para acumular água.\nO Rei o contratou para calcular quantas seções estarão cobertas com água, durante a estação de chuva. Uma seção da piscina pode ser considerada coberta com água se ela possuír água com pelo menos 1m de profundidade.\nO caso do exemplo 3 pode ser visto na figura abaixo, que apresenta um corte lateral da piscina. As seções 2 a 10 e 13 a 15 ficarão cobertas de água.\nEntrada\nA primeira linha contém um inteiro, N, o número de seções da piscina. Seguem N linhas, cada uma com um inteiro Hi, a altura da i-ésima seção, em metros.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de seções da piscina cobertos por água.\nRestrições\n• 1 ≤ N ≤ 105, 1 ≤ Hi ≤ 109 (1 ≤ i ≤ N) Informações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, N ≤ 103.\nExemplos",
    "examples": [
      [
        "4\n2\n1\n1\n2",
        "2"
      ],
      [
        "6\n5\n2\n6\n1\n3",
        "2"
      ],
      [
        "17\n4\n3\n2\n1\n1\n1\n1\n1\n2\n3\n5\n5\n3\n3\n2\n4\n4",
        "12"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chuva"
    },
    "imagesQuant": 0
  },
  {
    "name": "Lâmpadas do hotel",
    "description": "hotel.py3 Você está de volta em seu hotel na Tailândia depois de um dia de mergulhos. O seu quarto tem duas lâmpadas. Vamos chamá-las de A e B. No hotel há dois interruptores, que chamaremos de C1 e C2. Ao apertar C1, a lâmpada A acende se estiver apagada, e apaga se estiver acesa. Se apertar C2, cada uma das lâmpadas A e a B troca de estado: se estiver apagada, fica acesa e se estiver acesa apaga.\nVocê chegou no hotel e encontrou as lâmpadas em um determinado estado, como foram deixadas por seu amigo. Vamos chamar o estado inicial da lâmpada A de IA e o estado inicial da lâmpada B de IB. Você gostaria de deixar as lâmpadas em uma certa configuração final, que chamaremos de FA e FB, respectivamente, apertando os interruptores a menor quantidade de vezes possível. Por exemplo, se as duas lâmpadas começam apagadas, e você quer que apenas a lâmpada A termine acesa, basta apertar o interruptor C1.\nDados os estados iniciais e desejados das duas lâmpadas (acesa/apagada), determine o número mínimo de vezes que interruptores devem ser apertados.\nEntrada\nA entrada contém quatro inteiros: IA, IB, FA e FB, os estados iniciais das lâmpadas A e B e os estados finais desejados das lâmpadas A e B, respectivamente e nessa ordem. Os valores de IA, IB, FA e FB possíveis são 0, se a lâmpada estiver apagada e 1 caso contrário.\nSaída\nSeu programa deverá imprimir um único número, o número mínimo de interruptores que devem ser apertados.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 25 pontos, as duas lâmpadas começam sempre apagadas (IA = IB = 0).\nExemplos",
    "examples": [
      [
        "0 0 1 1",
        "1"
      ],
      [
        "0 0 0 1",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "hotel"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sanduíche",
    "description": "sanduiche.js, sanduiche.py2 ou sanduiche.py3 Você está na Seletiva para a IOI e depois de um dia cansativo de provas, chegou a hora do jantar.\nHoje, trouxeram um sanduíche muito longo cortado em N pedaços de diversos tamanhos diferentes.\nVocê gostaria de comer uma quantidade total de sanduíche de comprimento D, porém há uma regra: para evitar bagunça, você só pode ou pegar uma sequência contínua de pedaços, ou pegar pedaços das extremidades. Você sabe a sequência C1,C2,... CN dos comprimentos dos pedaços na ordem em que estão posicionados no sanduíche. Agora, para otimizar o seu jantar, quer fazer um programa que com esses dados responda de quantas formas você pode escolher os pedaços do sanduíche que vai comer. Em outras palavras, deve contar quantos pares (i,j), 1 ≤ i ≤ j ≤ N, existem tais que o somatório Ci + Ci+1 + ... + Cj seja igual a D e quantos pares (i,j), 1 ≤ i < j ≤ N, existem tais que o somatório C1 + C2 + ... + Ci + Cj + Cj+1 + ... + CN seja igual a D.\nEntrada\nA primeira linha contém dois inteiros N e D, representando respectivamente o número de pedaços e a quantidade de sanduíche que você quer comer. A segunda linha contém N inteiros C1,C2,... CN, onde Ci é o tamanho do i-ésimo pedaço.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de maneiras de comer pedaços de sanduíche com soma D.\nRestrições\n• 2 ≤ N ≤ 106.\n• 1 ≤ D ≤ 109.\n• 1 ≤ Ci ≤ 103.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, N ≤ 200.\n• Em um conjunto de casos de teste equivalente a 40 pontos, N ≤ 1000.\nExemplos",
    "examples": [
      [
        "5 10\n1 2 3 4 3",
        "3"
      ],
      [
        "5 5\n1 1 1 1 1",
        "5"
      ],
      [
        "9 618\n665 658 248 282 428 562 741 290 457 5",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sanduiche"
    },
    "imagesQuant": 0
  },
  {
    "name": "Toca do Saci",
    "description": "Depois de muito procurar, Emília finalmente conseguiu encontrar a toca do Saci. A toca tem formato retangular, e é formada por um quadriculado de salas quadradas de mesmo tamanho, com N salas em uma dimensão e M salas na outra dimensão. A figura abaixo mostra um exemplo de mapa da toca, com cinco salas na dimensão horizontal e quatro salas na dimensão vertical. Há uma única entrada, pela sala marcada com o número 3 no mapa. As salas da toca são muito parecidas, para confundir quem tenta encontrar o Saci, e têm portas que comunicam-se apenas com salas vizinhas nas direções horizontal e vertical do mapa.\n  Emília entrou na toca seguindo o Saci com o objetivo de pegar o seu chapéu, e só vai devolvê-lo se o Saci prometer não fazer mais diabrites no Sítio. Muito esperta, ela foi deixando estrelinhas coloridas pelas salas que passou (marcadas com o número 1 no mapa), para saber o caminho de volta. Ela pegou o chapéu do Saci enquanto ele dormia, e começou o caminho de volta. Está muito escuro e ela precisa acender um fósforo em cada sala, para ver as estrelinhas que marcam o caminho. No meio do caminho, ela percebeu que seus fósforos estavam acabando e agora está com medo de não ter fósforos suficientes. Ela está na sala marcada com o número 2 no mapa. Você pode ajudá-la? Dado o mapa da toca, como no exemplo acima, escreva um programa para saber por quantas salas Emília deve passar até encontrar a saída.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M que indicam respectivamente os números de salas nas duas dimensões da toca. Cada uma das N linhas seguintes contém M números inteiros entre 0 e 3. O valor 0 indica uma sala sem estrelinhas; o valor 1 indica uma sala com estrelinhas deixadas por Emília; o valor 2 indica uma sala com estrelinhas que é a sala onde Emília está; finalmente, o valor 3 indica uma sala com estrelinhas que é a saída. Considere que, durante o trajeto da entrada até a sala marcada com o valor 2, Emília não passou mais do que uma vez por uma mesma sala, e não existe ambiguidade no caminho de volta (em outras palavras, a cada ponto do trajeto de volta, existe apenas uma sala marcada para Emília voltar).\nSaída\nSeu programa deve imprimir uma única linha, contendo o número de salas que Emília deve passar, seguindo as estrelinhas, até chegar à saída da toca.\nRestrições\nA entrada obedece às seguintes restrições: • 1 ≤ N ≤ 1000 • 1 ≤ M ≤ 1000 • cada sala tem o valor 0, 1, 2 ou 3.\n• apenas uma sala tem o valor 2.\n• apenas uma sala tem o valor 3.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, Emília está em uma sala que só possui uma sala vizinha com estrelinhas (como no exemplo 1).\nExemplos\nEntrada\nSaída\n4 5 12",
    "examples": [
      [
        "4 5\n0 1 1 1 0\n0 2 0 1 1\n0 0 0 0 1\n3 1 1 1 1",
        "12"
      ],
      [
        "4 5\n0 0 0 1 0\n0 0 0 1 1\n0 0 0 0 2\n0 3 1 1 1",
        "5"
      ],
      [
        "4 5\n0 1 2 1 0\n0 1 0 1 1\n0 0 0 0 1\n3 1 1 1 1",
        "10"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "toca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Nova avenida",
    "description": "avenida.py2 ou avenida.py3 O bairro Boa Vista é formado por um conjunto de quadras de mesmo tamanho, dispostas em um quadriculado de N por M quadras, com ruas no sentido Norte-Sul e no sentido Leste-Oeste. Assim, o comprimento de cada rua no sentido Norte-Sul é igual a N quadras e o comprimento de cada rua no sentido Leste-Oeste é igual a M quadras. A atual administração da prefeitura decidiu que é necessário escolher uma rua do bairro, no sentido Norte-Sul, para ser alargada. Para isso, será necessário desapropriar todas as quadras de um dos lados da rua escolhida.\nAs quadras têm construções diferentes, de forma que cada quadra tem um valor diferente no mercado. Para desapropriar as quadras, a prefeitura tem que pagar o valor do mercado aos proprietários.\nA figura abaixo mostra um exemplo dos valores das quadras, em milhões de reais, onde N = 3 e M = 4.\n5 3 12 4 N O L 5 4 7 2 S 5 1 10 5 Sua tarefa é escrever um programa que, dados os valores das quadras, em milhões de reais, determine qual o menor valor que a prefeitura terá que desembolsar.\nEntrada\nA primeira linha da entrada contém dois inteiro N e M que indicam respectivamente o número de quadras no sentido Norte-Sul e no sentido Leste-Oeste. Cada uma das N linhas seguintes corresponde a uma das N fileiras de quadras no sentido Leste-Oeste e contém M inteiros, que são os valores das quadras daquela fileira de quadras, visualizada no sentido Leste-Oeste.\nSaída\nSeu programa deve imprimir uma única linha, contendo um único inteiro, que é o menor valor, em milhões de reais, que a prefeitura vai precisar desembolsar.\nRestrições\nA entrada obedece às seguintes restrições: • 2 ≤ N ≤ 1000 • 2 ≤ M ≤ 1000 • cada quadra tem valor entre 1 e 100 milhões de reais Exemplos",
    "examples": [
      [
        "3 4\n5 3 12 4\n5 4 7 2\n5 1 10 5",
        "8"
      ],
      [
        "4 5\n20 30 10 10 50\n20 30 10 10 50\n20 30 10 10 50\n20 30 10 10 50",
        "40"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "avenida"
    },
    "imagesQuant": 0
  },
  {
    "name": "Direção",
    "description": "direcao.py2 ou direcao.py3 Seu amigo está perdido no deserto e precisa encontrar um oásis. Você sabe que seu amigo está, no momento, virado para um dos pontos cardeais (norte, sul, leste, oeste). Você também sabe que o oásis mais próximo está em uma dessas quatro direções. Dadas essas duas informações, você deve dizer qual o menor ângulo, em graus, que seu amigo deverá virar para ir na direção do oásis mais próximo.\nEntrada\nA entrada contém duas strings, A e B, a direção para onde seu amigo está virado originalmente e a direção do oásis, respectivamente.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o menor ângulo que seu amigo deve virar para continuar na direção correta para o oásis.\nRestrições\nOs valores possíveis para A e B são { norte, leste, oeste, sul }.\nExemplos",
    "examples": [
      [
        "norte sul",
        "180"
      ],
      [
        "oeste sul",
        "90"
      ],
      [
        "leste leste",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "direcao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caverna de Ordinskaya",
    "description": "caverna.py Alguns de seus amigos decidiram viajar até a Russia para explorar Ordinskaya, a caverna subaquática mais comprida do país. Apesar da boa visibilidade das águas da caverna sempre é possível encontrar novas passagens e túneis que levam para longe da gruta principal, o que poderia fazer com que alguém se perdesse e provavelmente congelasse nas frias temperaturas observadas ali. Para evitar que algo assim ocorresse durante os mergulhos, o grupo usou uma fita métrica para marcar o caminho feito e garantir um retorno seguro. Além disso aproveitaram para medir quanto haviam explorado, sempre que retornavam à superfície alguém do grupo anotava num caderno o quão longe haviam ido.\nO único problema com essa estratégia é que a cada mergulho pessoas diferentes ficavam responsáveis por verificar a fita métrica e anotar quanto havia sido explorado. Assim, se o comprimento da fita era 10 metros, após um mergulho em que o grupo explorou 3 metros da caverna, um dos amigos poderia ter desenrolado a fita do começo para o fim e anotar que 3 metros foram explorados, enquanto outro mais desatento, sem perceber que havia desenrolado a fita no sentido contrário, poderia anotar que 7 metros foram explorados.\nApenas no final da viagem seus amigos perceberam a bagunça feita e agora pediram sua ajuda para reconstruir as distâncias de fato exploradas. Você foi informado que antes da viagem o grupo comprou uma fita com M metros e que no total eles fizeram N mergulhos. Outra informação importante é que a cada novo mergulho pelo menos a mesma distância do mergulho anterior era explorada, então se o comprimento da fita fosse de 10 metros e as anotações feitas fossem 3 e 8 metros, nessa ordem, os únicos cenários que realmente poderiam ter acontecido são: • 3 metros no primeiro mergulho e 8 no segundo; • 7 metros no primeiro mergulho e 8 no segundo.\nMas se os valores anotados foram 2 e 8, existem três possibilidades: • 2 metros no primeiro mergulho e 8 no segundo; • 2 metros no primeiro mergulho e 2 no segundo; • 8 metros no primeiro mergulho e 8 no segundo.\nComo pode ter ocorrido algum engano nas anotações, pode ser impossível reconstruir a sequência original, não se preocupe, todos vão entender caso isso aconteça.\nEntrada\nA primeira linha contém dois inteiros N e M, representando respectivamente a quantidade de mergulhos que o grupo fez e o comprimento em metros da fita que levaram para a exploração. A segunda linha contém N inteiros A1, A2, ..., AN representando as medições feitas a cada mergulho, na ordem em que foram anotadas.\nSaída\nSeu programa deve produzir uma única linha, contendo apenas um inteiro, que representa a soma das distâncias exploradas. Caso exista mais de uma sequência possível, imprima a menor soma das sequencias possíveis. Se não existir nenuma sequência compatível com os dados, imprima apenas o inteiro -1.\nRestrições\n• 1 ≤ N ≤ 104.\n• 1 ≤ M ≤ 5 ∗ 105.\n• 0 ≤ Ai ≤ M.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, N ≤ 20 e M ≤ 5 ∗ 103.\n• Em um conjunto de casos de teste equivalente a 60 pontos, N ≤ 103 e M ≤ 5 ∗ 103.\nExemplos",
    "examples": [
      [
        "5 7\n2 5 3 6 0",
        "20"
      ],
      [
        "3 5\n2 1 2",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caverna"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fuga com helicóptero",
    "description": "Um fugitivo, um helicóptero e um policial estão em posições distintas numa pista circular, exatamente como a mostrada na H figura ao lado, com dezesseis posições numeradas de 0 a 15 em 6 5 4 3 direção anti-horária. O helicóptero e o policial ficam sempre pa- F 7 2 rados. O objetivo do fugitivo é chegar no helicóptero sem passar pelo policial antes, claro. Ele pode decidir correr na direção 8 1 horária, ou na direção anti-horária. Neste problema, dadas as 9 0 posições do helicóptero, do policial e do fugitivo, e a direção em 10 15 que o fugitivo decide correr, seu programa deve dizer se ele vai o du iren çã ão oc ho on rs áe rg iu a,ir ef lu eg cir o! nsN ea gufi egu fur ga i, rs ;e seo dfu eg ci it di iv ro cd oe rc reid rir naco drr ire er çn ãa o 11 12 13 14 P anti-horária, ele vai ser preso antes de chegar no helicóptero! Entrada\nA entrada consiste de uma linha com quatro inteiros: H,P,F e D, representando, respectivamente, as posições do helicóptero, do policial e do fugitivo, e a direção em que o fugitivo corre, −1 para horário e 1 para anti-horário.\nSaída\nSeu programa deve imprimir uma linha contendo o caracter “S” se o fugitivo consegue fugir, ou “N” caso contrário.\nRestrições\n• Os inteiros H,P e F são distintos e estão entre 0 e 15, inclusive.\nExemplos",
    "examples": [
      [
        "4 14 7 -1",
        "S"
      ],
      [
        "4 14 7 1",
        "N"
      ],
      [
        "15 9 8 -1",
        "S"
      ],
      [
        "0 14 15 -1",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fuga"
    },
    "imagesQuant": 0
  },
  {
    "name": "Gincana",
    "description": "gincana.py As duas turmas do terceiro ano de sua escola realizam anualmente uma gincana. Nessa gincana, a delegação de cada turma é dividida em grupos de K pessoas, de forma que K seja o maior número possível que divida as duas delegações sem que sobre alguém. Depois, os grupos competem uns com os outros, ganhando pontos para determinar a turma vencedora. Sua turma pode levar qualquer número X de pessoas entre 1 e M, a quantidade de alunos na turma, e você sabe que a turma rival levará exatamente N pessoas para a gincana. Os integrantes da sua turma são muito bons em competições individuais, mas não trabalham bem em equipe. Portanto, é sua tarefa encontrar a maior delegação possível que sua turma pode levar à competição para que a gincana aconteça com grupos de K = 1 pessoa.\nPor exemplo, se N = 9 e M = 6 a sua turma deve levar uma delegação de X = 5 pessoas, já que, para esse valor, a única divisão possível é em grupos de K = 1 pessoa e, para X = 6, os grupos seriam de 3 pessoas.\nEntrada\nA primeira e única linha contém dois inteiros N e M, representando respectivamente o tamanho da delegação rival e o tamanho da sua turma.\nSaída\nSeu programa deve produzir uma única linha, contendo um inteiro X, o maior tamanho possível da delegação da sua turma para o qual a gincana aconteça com grupos de uma pessoa.\nRestrições\n• 1 ≤ N,M ≤ 1018.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 40 pontos, N,M ≤ 103.\n• Em um conjunto de casos de teste equivalente a 60 pontos, N,M ≤ 105.\n• Em um conjunto de casos de teste equivalente a 80 pontos, N,M ≤ 107.\nExemplos",
    "examples": [
      [
        "9 6",
        "5"
      ],
      [
        "6 9",
        "7"
      ],
      [
        "6 3",
        "1"
      ],
      [
        "2310 126",
        "113"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "gincana"
    },
    "imagesQuant": 0
  },
  {
    "name": "Medalhas",
    "description": "medalhas.py A natação foi um dos esportes mais emocionantes das Olimpíadas do Rio.\nHouve até uma prova na qual três atletas chegaram empatados, cada um recebendo uma medalha de prata! Normalmente, porém, os três primei- OURO ros colocados terminam a prova em tempos distintos e, portanto, temos a distribuição mais comum de medalhas: o nadador que terminou no menor tempo recebe medalha de ouro; o nadador que terminou com o segundo mePRATA nor tempo recebe medalha de prata; e o que terminou com o terceiro menor tempo recebe medalha de bronze. Neste problema, dados os três tempos distintos de finalização da prova, dos três nadadores que ganharam medalhas, seu programa deve dizer quem ganhou medalha de ouro, quem ganhou prata BRONZE e quem ganhou bronze.\nEntrada\nA primeira linha da entrada contém um inteiro T1, indicando o tempo em que o nadador 1 terminou a prova. A segunda linha da entrada contém um inteiro T2, indicando o tempo de finalização do nadador 2. Por fim, a terceira linha da entrada contém um inteiro T3, indicando o tempo em que o nadador 3 terminou a prova.\nSaída\nSeu programa deve imprimir três linhas na saída. A primeira linha deve conter o número do nadador que ganhou medalha de ouro; a segunda linha, o número do nadador que ganhou prata; e a terceira linha, o número do nadador que levou bronze.\nRestrições\n• Os tempos T1,T2 e T3 são inteiros distintos, com valores entre 1 e 1000, inclusive.\nExemplos",
    "examples": [
      [
        "230\n183\n234",
        "2\n1\n3"
      ],
      [
        "46\n47\n48",
        "1\n2\n3"
      ],
      [
        "11\n21\n7",
        "3\n1\n2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "medalhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Arco e flecha",
    "description": "O comitê olímpico está testando uma nova forma de pontuar as competições de arco e flecha, baseada em penalidades. O atleta vai atirar N flechas no alvo, em sequência. A penalidade da K-ésima flecha atirada é computada imediatamente após ela atingir o alvo, antes do próximo lançamento, e é igual ao número de flechas que estão no alvo naquele momento cuja distância ao centro do alvo é menor ou igual à distância da K-ésima flecha ao centro, excluindo a própria K-ésima flecha. Quer dizer, a penalidade é o número das K − 1 flechas lançadas antes da Késima flecha que estão mais próximas ou à mesma distância do centro do alvo, comparadas com a K-ésima flecha.\nA penalidade total é a soma das penalidades das N flechas. Ganha o atleta que tiver a menor penalidade total ao final. Veja que a penalidade total pode ser zero, se o atleta for bom o bastante para acertar numa sequência estritamente decrescente de distâncias ao centro do alvo.\nNeste problema, o centro do alvo está na origem (0,0). Dada a sequência de coordenadas dos pontos em que as sucessivas flechas atingiram o alvo, seu programa deve computar a penalidade total final do atleta.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando a quantidade de flechas lançadas.\nCada uma das N linhas seguintes contém dois inteiros, X e Y , indicando as coordenadas do ponto em que cada flecha atingiu o alvo, definindo a sequência de lançamentos.\nSaída\nImprima uma linha contendo um inteiro representando a penalidade total do atleta.\nRestrições\n• 1 ≤ N ≤ 105 • −106 ≤ X,Y ≤ 106 Informações sobre a pontuação\n• Em um conjunto de testes somando 20 pontos, N ≤ 104 Exemplos",
    "examples": [
      [
        "2\n1 3\n5 4",
        "1"
      ],
      [
        "4\n-100 85\n-25 -60\n18 33\n0 0",
        "0"
      ],
      [
        "6\n1 1\n2 2\n2 2\n3 3\n3 3\n3 3",
        "15"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "arco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caminhos do reino",
    "description": "caminhos.py O reino de Daglônia é um lugar estranho. Todas as estradas do reino só podem ser usadas em uma direção e de cada cidade sai exatamente uma estrada. O reino é dividido em duas partes: o ciclo interno e os caminhos periféricos. Cada uma das cidades do reino pertence a uma dessas partes.\nNo ciclo interno, a estrada que sai de cada cidade vai à próxima cidade do ciclo, de forma que é possível percorrer um caminho que sai de uma cidade qualquer e retorna a essa mesma cidade.\nA algumas cidades do ciclo interno pode chegar um dos caminhos periféricos, que são as ligações entre a parte central do reino e o mundo exterior, por onde pessoas podem chegar ao reino (mas não sair). Um caminho periférico começa em uma cidade na qual nenhuma estrada do reino chega e segue pelas estradas de cada cidade até chegar em uma cidade do ciclo interno. A cada cidade pertecente a um caminho periférico chega no máximo uma estrada. A cada cidade do ciclo interno chegam no máximo duas estradas: uma estrada do ciclo interno (que sempre existe) e uma estrada de um caminho periférico (que pode ou não existir).\nA figura abaixo mostra um exemplo das cidades e estradas do reino, com cidades numeradas de 1 a N.\nNa figura, os caminhos periféricos são (3 → 1) e (4) e o ciclo interno é (2 → 6 → 5 → 2).\nHá rumores de que um país vizinho vai declarar guerra contra a Daglônia, e por isso os habitantes do reino querem se encontrar com seus familiares no menor tempo possível. Você foi contratado pelo Rei para ajudá-las. Você receberá Q perguntas da seguinte forma: dadas as cidades A e B onde estão duas pessoas do reino que querem se encontrar, você deve determinar qual o tempo mínimo em que elas podem se encontrar, considerando que cada estrada é percorrida em uma unidade de tempo. O ponto de encontro das duas pessoas pode ser diferente das cidades iniciais e ambas podem se deslocar simultaneamente para chegar ao ponto de encontro.\nConsiderando o exemplo da figura acima, pessoas nas cidades 4 e 3 podem se encontrar na cidade 2 ou 6 em tempo 3. Pessoas nas cidades 1 e 3 podem se encontrar na cidade 1 em tempo 1. Pessoas nas cidades 6 e 3 podem se encontrar na cidade 2 em tempo 2.\nEntrada\nA primeira linha contém um inteiro N, representando o número de cidades. As cidades são identificadas por inteiros de 1 a N. A segunda linha contém N inteiros F1,F2,... FN, onde Fi é o destino da estrada que parte da cidade i. A terceira linha contém um inteiro Q, que representa o número de perguntas. As Q linhas seguintes contém dois inteiros A e B, indicando as cidades para as quais você deve responder a pergunta descrita acima. Existe pelo menos um caminho periférico.\nSaída\nSeu programa deve produzir Q linhas, cada uma contendo um único inteiro, o menor tempo necessário para que as duas pessoas se encontrem em uma cidade qualquer.\nRestrições\n• 3 ≤ N ≤ 105 • 1 ≤ Fi ≤ N • Fi (cid:54)= i • 1 ≤ Q ≤ 105 • 1 ≤ A,B ≤ N • O reino representado respeita as condições do enunciado. Particularmente, existe exatamente um ciclo, existe pelo menos uma cidade que não pertence ao ciclo, a cada cidade do ciclo chegam no máximo duas estradas e a cada cidade que não pertence ao ciclo chega no máximo uma estrada.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 40 pontos, Q = 1.\nExemplos",
    "examples": [
      [
        "6\n2 6 1 6 2 5\n5\n4 3\n1 3\n6 3\n5 2\n2 2",
        "3\n1\n2\n1\n0"
      ],
      [
        "13\n7 3 9 5 3 7 5 2 6 1 10 11 9\n10\n4 10\n10 8\n12 11\n10 4\n7 3\n8 11\n6 11\n3 4\n6 12\n8 5",
        "3\n4\n1\n3\n2\n5\n3\n2\n4\n2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caminhos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ciclovias",
    "description": "ciclovias.js ou ciclovias.py A cidade de Nlogônia é mundialmente conhecida pelas suas iniciativas de preservação ambiental.\nDentre elas, uma das que mais chama atenção é a existência de ciclovias em todas as ruas da cidade. Essa medida teve um sucesso tão grande, que agora a maioria dos moradores usa a bicicleta diariamente. Em Nlogônia, as interseções são numeradas de 1 até N. Cada rua liga duas interseções A e B e possui uma ciclovia entre A e B. Um caminho P de tamanho K é definido como uma sequência de interseções P1,P2,... ,PK, tal que para todo i, 1 ≤ i < K, existe uma ciclovia entre Pi e Pi+1. Arnaldo e Bernardo estavam passeando de bicileta pelas ruas de Nlognônia quando pensaram em um novo jogo. Nesse jogo, os dois partem de alguma interseção C e procuram o caminho P de maior tamanho que satisfaça a seguinte regra: as subsequências P1,P3,P5,...,P2x+1 e P2,P4,P6,...,P2x da sequência P devem ser ambas crescentes. Ganha o jogo aquele que encontrar o maior caminho.\nBernardo te ligou pedindo ajuda para se preparar para o jogo. Com o mapa da cidade você deve encontrar o tamanho do maior caminho possível para todas as interseções iniciais possíveis, seguindo as restrições acima. No exemplo abaixo, o maior caminho possível para início na interseção 1 é P = (1,3,5,4,7) e para início na interseção 5 é P = (5,3,6) ou P = (5,4,7).\nEntrada\nA primeira linha contém dois inteiros N e M, representando respectivamente o número de interseções e o número de ruas. As M linhas seguintes contém dois inteiros A e B indicando que existe uma ciclovia entre A a B.\nSaída\nSeu programa deve produzir uma única linha, contendo N inteiros R1,R2,... RN, onde Ri é o tamanho do maior caminho possível se o jogo começar na interseção i.\nRestrições\n• 1 ≤ N ≤ 105.\nN(N − 1) • 0 ≤ M ≤ .\n2 • 0 ≤ M ≤ 5 × 105.\n• A (cid:54)= B.\n• 1 ≤ A,B ≤ N.\n• Não existem duas ciclovias iguais.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 20 pontos, N ≤ 7.\n• Em um conjunto de casos de teste equivalente a 40 pontos, N ≤ 100.\n• Em um conjunto de casos de teste equivalente a 60 pontos, N ≤ 1000.\nExemplos",
    "examples": [
      [
        "5 5\n1 5\n1 3\n1 2\n2 5\n4 5",
        "4 4 4 2 2"
      ],
      [
        "6 6\n1 3\n2 3\n4 2\n3 4\n3 5\n5 4",
        "7 5 6 4 2 1"
      ],
      [
        "7 6\n1 2\n1 3\n3 5\n3 6\n5 4\n4 7",
        "5 6 4 2 3 2 2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "ciclovias"
    },
    "imagesQuant": 1
  },
  {
    "name": "Falta uma",
    "description": "Carolina tem um jogo de tabuleiro que possui 24 cartas contendo, cada uma, uma permutação dos quatro primeiros números naturais. (Cartas distintas contêm permutações distintas.) Lembre-se de que a quantidade de permutações de quatro números é 4!, que é igual a 24. Só que ela contou e encontrou apenas 23 cartas. Está faltando uma! Dê uma olhada nessa lista embaralhada de 23 cartas. Qual está faltando?   Agora suponha que o jogo tenha um baralho de N! cartas, com todas as permutações possíveis dos N primeiros naturais. Neste problema, dado N e uma lista com N! − 1 cartas, seu programa deve imprimir a carta que está faltando.\nEntrada\nA primeira linha da entrada contém um inteiro N. As N! − 1 linhas seguintes contêm, cada uma, N naturais. Cada linha representa uma permutação distinta dos N primeiros naturais.\nSaída\nSeu programa deve imprimir uma única linha, contendo N naturais representando a permutação que está faltando na entrada.\nRestrições\n• 2 ≤ N ≤ 8.\nExemplos",
    "examples": [
      [
        "3\n3 2 1\n2 1 3\n1 3 2\n3 1 2\n1 2 3",
        "2 3 1"
      ],
      [
        "2\n2 1",
        "1 2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "falta"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jardim de infância",
    "description": "Vívian é uma professora do jardim de infância. Todos os dias, ao final da aula, ela tem que olhar os desenhos que seus alunos fizeram naquele dia e fazer algum comentário. Esta é uma tarefa muito repetitiva, já que as crianças costumam desenhar coisas semelhantes, portanto Vívian decidiu automatizar o processo. Ela fez um programa capaz de processar a imagem e procurar padrões conhecidos para fazer comentários predeterminados. Em particular, ela percebeu que na maioria dos desenhos as crianças incluem um pinheiro. Porém, ela está tendo dificuldades para reconhecê-los e pediu sua ajuda. O programa dela já é capaz de reconhecer uma figura que pode ser um pinheiro e transformá-la em sete pontos P1,P2,... P7. O candidato a pinheiro seria a região interna do polígono P1P2P4P6P7P5P3, como mostra a figura a seguir de um pinheiro válido.\nLogo, dados os sete pontos que formam a imagem, você deve decidir se ela é ou não um pinheiro.\nAo analisar os desenhos das crianças, você decidiu que as condições para que os pontos formem um pinheiro são as seguintes: • O ângulo (cid:54) P2P1P3 é agudo (vértice em P1); • Os segmentos P1P2 e P1P3 têm o mesmo comprimento; • Os pontos P2,P3,P4 e P5 são colineares; • Os pontos médios dos segmentos P2P3 e P4P5 são coincidentes; • O segmento P2P3 tem comprimento maior que o segmento P4P5; • Os segmentos P4P6 e P5P7 são perpendiculares ao segmento P2P3; • Os segmentos P4P6 e P5P7 têm o mesmo comprimento; • Os pontos P1 e P6 devem estar separados pela reta que contém o segmento P2P3. Formalmente, o segmento P1P6 deve interceptar a reta que contém o segmento P2P3 em um único ponto.\nA imagem a seguir mostra os polígonos formados pelos exemplos de entrada.\nEntrada\nA entrada contém sete linhas. A i-ésima da entrada contém dois inteiros Xi e Yi, indicando as coordenadas cartesianas do ponto Pi.\nSaída\nSeu programa deve produzir uma única linha, contendo uma única letra, \"S\" se os pontos formam um pinheiro pelas condições descritas e \"N\", caso contrário.\nRestrições\n• −2 × 104 ≤ Xi,Yi ≤ 2 × 104.\n• Todos os pontos são diferentes.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 50 pontos, o segmento P2P3 será paralelo ao eixo X do plano cartesiano (exemplos 1 e 4).\nExemplos",
    "examples": [
      [
        "2 -4\n5 3\n-1 3\n3 3\n1 3\n3 5\n1 5",
        "S"
      ],
      [
        "2 -1\n5 45\n-43 9\n-11 33\n-27 21\n-20 45\n-36 33",
        "S"
      ],
      [
        "-1 -3\n11 -23\n11 17\n11 -7\n11 1\n19 -7\n19 1",
        "N"
      ],
      [
        "2 4\n18 22\n-14 22\n6 24\n-2 20\n6 26\n-2 22",
        "N"
      ],
      [
        "4 1\n-36 -4\n-12 -36\n-30 -12\n-18 -28\n-39 -25\n-27 -41",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jardim"
    },
    "imagesQuant": 2
  },
  {
    "name": "Pô, que mão",
    "description": "pokemon.py Um novo jogo se tornou popular entre jovens de todas as idades recentemente: o “Pô, que mão”.\nTrata-se de um jogo onde uma mão captura criaturas raras e depois as força a lutarem umas contra as outras. Uma verdadeira barbárie.\nAinda assim, o jogo se tornou bastante popular. As criaturas são chamadas de “pô-que-mãos”. No jogo, você pode dar doces para as pô-que-mãos, para que elas fiquem mais fortes e evoluam. Como há poucos doces, nem sempre é possível evoluir todas as pô-que-mãos que um jogador possui.\nUm jogador tem exatamente 3 pô-que-mãos. Cada um deles necessita de uma quantidade de doces para evoluir. Conhecendo-se a quantidade de doces disponíveis, escreva um programa para determinar qual o maior número de pô-que-mãos que podem evoluir.\nEntrada\nA entrada é composta por quatro linhas, cada uma contendo um inteiro. A primeira linha contém N, o número de doces disponíveis. A segunda linha contém X, o número de doces necessários para a primeira pô-que-mão evoluir. A próxima linha contém Y , o número de doces necessários para a segunda pô-que-mão evoluir. A última linha contém Z, o número de doces necessários para a terceira pô-que-mão evoluir.\nSaída\nSeu programa deve produzir uma única linha, contendo um inteiro, o maior número possível de pô-que-mãos que podem evoluir.\nRestrições\n• 0 ≤ N ≤ 1000 • 1 ≤ X ≤ 1000 • 1 ≤ Y ≤ 1000 • 1 ≤ Z ≤ 1000 Exemplos",
    "examples": [
      [
        "300\n220\n100\n190",
        "2"
      ],
      [
        "1000\n100\n200\n300",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pokemon"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quase primo",
    "description": "O jovem César está aprendendo sobre números primos: um número X > 1 é primo se for divisível apenas por 1 e por X.\nA primeira tarefa de casa de César consiste em dizer, para um dado número N, quantos números menores ou iguais a N são primos. Acontece que os números são muito grandes e César tem preguiça.\nEle suspeita que seu professor é tão preguiçoso quanto ele, e acha que, seu professor, para testar se um número é primo, vai testar só uma pequena quantidade de divisores primos. Com isso em mente, ele compilou uma lista de K números primos que acha que o professor vai usar.\nMesmo assim, César ainda está com preguiça. Dados N e a lista com K números primos, diga quantos números inteiros positivos menores ou iguais a N não são divisíveis por nenhum número primo na lista.\nEntrada\nA primeira linha da entrada contém dois inteiros, N e K. A linha seguinte contém K primos distintos ki, (1 ≤ i ≤ K), que são os primos que César acha que o professor irá considerar.\nSaída\nImprima um único inteiro, a quantidade de números inteiros positivos menores ou iguais a N que não são divisíveis por nenhum número na lista.\nRestrições\n• 1 ≤ N ≤ 109 • 1 ≤ K ≤ 40 • ki é primo e 2 ≤ ki ≤ N Informações sobre a pontuação\n• Em um conjunto de testes valendo 20 pontos, N ≤ 105 e K = 1 • Em um conjunto de testes valendo 40 pontos, N ≤ 105 e K ≤ 20 • Em um conjunto de testes valendo 80 pontos, N ≤ 109 e K ≤ 20 Exemplos",
    "examples": [
      [
        "10 1\n2",
        "5"
      ],
      [
        "10 2\n2 3",
        "3"
      ],
      [
        "20 3\n2 5 7",
        "7"
      ],
      [
        "29 3\n2 5 7",
        "10"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "primo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Times",
    "description": "Chegou a hora da caça ao tesouro na gincana escolar! Para jogar, sua turma de N pessoas deve se dividir em dois times. A divisão será feita com base no número de chamada de cada aluno, um número entre 1 e N. Só que mais importante que fazer uma divisão balanceada é evitar que pessoas que não se gostam fiquem no mesmo time. Você receberá o número N de alunos e, para cada pessoa, você receberá a lista de pessoas que ela não gosta. Se a pessoa A não gosta da pessoa B então a pessoa B também não gosta da pessoa A. O aluno de número 1 sempre ficará no primeiro time.\nVocê deve dividir os outros alunos entre os dois times de forma que dentro de cada time não haja duas pessoas que não se gostam.\nEntrada\nA primeira linha contém um inteiro N, representando o número de alunos na turma. As N linhas seguintes, para 1 ≤ i ≤ N, contém um inteiro Mi, indicando de quantas pessoas o aluno i não gosta, e em seguida Mi inteiros Xj, indicando que a pessoa i não gosta da pessoa Xj.\nSaída\nSeu programa deve produzir duas linhas, a primeira contendo os números dos integrantes do primeiro time e a segunda contendo os números dos integrantes do segundo time, ambas em ordem crescente.\nLembre-se que o aluno 1 sempre estará no primeiro time. Sempre há uma única solução.\nRestrições\n• 2 ≤ N ≤ 105.\n• 1 ≤ Mi ≤ N − 1.\n• 1 ≤ Xj ≤ N.\n• 1 ≤ (cid:88)N Mi ≤ 6 × 105.\ni=1 • Ou seja, a soma de todos os Mi descritos na entrada é no máximo 6 × 105.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste equivalente a 40 pontos, N ≤ 15.\nExemplos",
    "examples": [
      [
        "13\n2 12 9\n1 10\n3 8 12 13\n5 8 10 13 6 5\n2 11 4\n1 4\n1 8\n3 4 3 7\n1 1\n2 2 4\n1 5\n2 3 1\n2 4 3",
        "1 2 3 4 7 11\n5 6 8 9 10 12 13"
      ],
      [
        "15\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n1 13\n14 11 7 1 10 8 6 14 12 3 2 15 5 4 9\n1 13\n1 13",
        "1 2 3 4 5 6 7 8 9 10 11 12 14 15\n13"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2016,
      "phase": 2,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "times"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bondinho",
    "description": "bondinho.py A turma do colégio vai fazer uma excursão na serra e todos os alunos e monitores vão tomar um bondinho para subir até o pico de uma montanha. A cabine do bondinho pode levar 50 pessoas no máximo, contando alunos e monitores, durante uma viagem até o pico. Neste problema, dado como entrada o número de alunos A e o número de monitores M, você deve escrever um programa que diga se é possível ou não levar todos os alunos e monitores em apenas uma viagem! Entrada\nA primeira linha da entrada contém um inteiro A, representando a quantidade de alunos. A segunda linha da entrada contém um inteiro M, representando o número de monitores.\nSaída\nSeu programa deve imprimir uma linha contendo o caractere S se é possível levar todos os alunos e monitores em apenas uma viagem, ou o caractere N caso não seja possível.\nRestrições\n• 1 ≤ A ≤ 50 • 1 ≤ M ≤ 50 Exemplos",
    "examples": [
      [
        "10\n20",
        "S"
      ],
      [
        "12\n39",
        "N"
      ],
      [
        "49\n1",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bondinho"
    },
    "imagesQuant": 0
  },
  {
    "name": "Drone de Entrega",
    "description": "A loja do Pará, especializada em vendas pela internet, está desenvolvendo drones para entrega de caixas com as compras dos clientes. Cada caixa tem a forma de um paralelepípedo reto retângulo (ou seja, no formato de um tijolo).\nO drone entregará uma caixa de cada vez, e colocará a caixa diretamente dentro da casa do cliente, através de uma janela. Todas as janelas dos clientes têm o formato retangular e estão sempre totalmente abertas. O drone tem um aplicativo de visão computacional que calcula exatamente as dimensões H e L da janela. O drone consegue colocar a caixa através da janela somente quando uma das faces da caixa está paralela à janela, mas consegue virar e rotacionar a caixa antes de passá-la pela janela.\nO aplicativo de controle do drone está quase pronto, mas falta um pequeno detalhe: um programa que, dadas as dimensões da maior janela do cliente e as dimensões da caixa que deve ser entregue, determine se o drone vai ser capaz de entregar a compra (pela janela) ou se a compra terá que ser entregue por meios normais.\nEntrada\nA entrada é composta por cinco linhas, cada uma contendo um número inteiro. A três primeiras linhas contêm os valores A, B, C, indicando as três dimensões da caixa, em centímetros. As duas últimas linhas contêm os valores H e L, indicando a altura e a largura da janela, em centímetros.\nSaída\nSeu programa deve escrever uma única linha, contendo apenas a letra S se a caixa passa pela janela e apenas a letra N em caso contrário.\nRestrições\n• 1 ≤ A,B,C ≤ 100 • 1 ≤ H,L ≤ 100 Exemplos",
    "examples": [
      [
        "30\n50\n80\n80\n60",
        "S"
      ],
      [
        "75\n100\n50\n100\n30",
        "N"
      ],
      [
        "20\n22\n5\n20\n10",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "drone"
    },
    "imagesQuant": 0
  },
  {
    "name": "Segredo do Cofre",
    "description": "O sistema de segredo para abrir esse cofre é bastante complexo. Ao invés de girar um botão várias vezes, como a gente vê normalmente nos filmes, o dono do cofre tem que deslizar um controle para a esquerda e para a direita, em cima de uma barra, várias vezes, parando em determinadas posições.\nA barra possui N posições e cada posição contém um número inteiro entre 0 e 9, inclusive. No exemplo da figura, a barra tem 14 posições e o controle está na posição 1.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 O segredo vai depender de quantas vezes cada um dos dez inteiros entre 0 e 9 vai aparecer dentro do controle. Por exemplo, suponha que o dono deslize o controle da posição inicial 1 até a posição 9, depois para a posição 4, depois para a posição 11 e por fim até a posição 13. Veja que o inteiro 1, por exemplo, vai aparecer seis vezes dentro do controle; e o inteiro 9 vai aparecer quatro vezes.\nDada a sequência de inteiros na barra e a sequência de posições entre as quais o dono desliza o controle, começando da posição inicial 1, seu programa deve contar quantas vezes cada inteiro, entre 0 e 9, vai aparecer dentro do controle.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, representando o número de posições na barra do cofre e o número de posições na sequência que o dono vai seguir para deslizar o controle.\nA segunda linha contém N inteiros entre 0 e 9, definindo a barra do cofre. A terceira linha contém M inteiros representando a sequência de posições que o dono vai seguir. A primeira posição nessa sequência é sempre 1 e não há duas posições consecutivas iguais.\nSaída\nSeu programa deve imprimir uma linha contendo 10 inteiros, representando o número de vezes que cada inteiro, entre 0 e 9, vai aparecer no controle da barra.\nRestrições\n• 2 ≤ N ≤ 105 e 2 ≤ M ≤ 105 Informações sobre a pontuação\n• Em um conjunto de testes somando 40 pontos, N ≤ 1000 e M ≤ 1000 Exemplos",
    "examples": [
      [
        "14 5\n9 4 3 9 1 2 4 5 1 1 9 7 0 5\n1 9 4 11 13",
        "1 6 3 1 4 3 0 1 0 4"
      ],
      [
        "5 4\n5 8 0 5 1\n1 4 2 5",
        "3 1 0 0 0 3 0 0 2 0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cofre"
    },
    "imagesQuant": 0
  },
  {
    "name": "Teleférico",
    "description": "teleferico.js ou teleferico.py A turma do colégio vai fazer uma excursão na serra e todos os alunos e monitores vão tomar um teleférico para subir até o pico de uma montanha. A cabine do teleférico pode levar C pessoas no máximo, contando alunos e monitores, durante uma viagem até o pico. Por questão de segurança, tem que ter pelo menos um monitor dentro da cabine junto com os alunos. Por exemplo, se cabem C = 10 pessoas na cabine e a turma tem A = 20 alunos, o colégio poderia fazer três viagens: a primeira com 8 alunos e um monitor; a segunda com 6 alunos e um monitor; e a terceira com 6 alunos e um monitor. Você consegue ver que não seria possível fazer apenas duas viagens? Dados como entrada a capacidade C da cabine e o número total A de alunos, você deve escrever um programa para calcular o número mínimo de viagens do teleférico.\nEntrada\nA primeira linha da entrada contém um inteiro C, representando a capacidade da cabine. A segunda linha da entrada contém um inteiro A, representando o número total de alunos na turma.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro representando o número mínimo de viagens do teleférico para levar todos os alunos até o pico da montanha.\nRestrições\n• 2 ≤ C ≤ 100 e 1 ≤ A ≤ 1000 Exemplos",
    "examples": [
      [
        "10\n20",
        "3"
      ],
      [
        "12\n55",
        "5"
      ],
      [
        "100\n87",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "teleferico"
    },
    "imagesQuant": 0
  },
  {
    "name": "Botas Trocadas",
    "description": "A divisão de Suprimentos de Botas e Calçados do Exército comprou um grande número de pares de botas de vários tamanhos para seus soldados. No entanto, por uma falha de empacotamento da fábrica contratada, nem todas as caixas entregues continham um par de botas correto, com duas botas do mesmo tamanho, uma para cada pé. O sargento mandou que os recrutas retirassem todas as botas de todas as caixas para reembalá-las, desta vez corretamente.\nQuando o sargento descobriu que você sabia programar, ele solicitou com a gentileza habitual que você escrevesse um programa que, dada a lista contendo a descrição de cada bota entregue, determina quantos pares corretos de botas poderão ser formados no total.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de botas individuais entregues.\nCada uma das N linhas seguintes descreve uma bota, contendo um número inteiro M e uma letra L, separados por um espaço em branco. M indica o número do tamanho da bota e L indica o pé da bota: L = ‘D’ indica que a bota é para o pé direito, L = ‘E’ indica que a bota é para o pé esquerdo.\nSaída\nSeu programa deve imprimir uma única linha contendo um único número inteiro indicando o número total de pares corretos de botas que podem ser formados.\nRestrições\n• 2 ≤ N ≤ 104 • N é par • 30 ≤ M ≤ 60 • L é o caractere ‘D’ ou o caractere ‘E’ Exemplos",
    "examples": [
      [
        "4\n40 D\n41 E\n41 D\n40 E",
        "2"
      ],
      [
        "6\n38 E\n39 E\n40 D\n38 D\n40 D\n37 E",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "botas"
    },
    "imagesQuant": 0
  },
  {
    "name": "O Chefe",
    "description": "Todos conhecem Iks, a última moda em redes sociais, que fez tanto sucesso que competidores como Facebook e Google+ estão começando a ter dificuldades financeiras. Assim como muitas companhias “.com”, Iks surgiu em uma pequena garagem, mas hoje emprega milhares de pessoas no mundo todo.\nO sistema de gerência utilizado em Iks é bem diferente do padrão. Por exemplo, não há diretorias ou superintendências. No entanto, como é usual em outras companhias, há uma cadeia (ou melhor, várias cadeias) de comando: uma pessoa pode gerenciar outras pessoas, e pode ser gerenciada por outras pessoas. As figuras abaixo mostram a cadeia de comando para alguns empregados, junto com suas idades.\nAlice, 21 Alice, 21 David, 33 Elaine, 33 George, 18 George, 18 Elaine, 33 David, 33 Bia, 42 Fred, 22 Bia, 42 Fred, 22 Clara, 26 Clara, 26 (a) (b) Uma pessoa P1 pode gerenciar outra pessoa P2 diretamente (quando P1 é o superior imediato de P2) ou indiretamente (quando P1 gerencia diretamente uma pessoa P3 que gerencia P2 direta ou indiretamente). Por exemplo, na figura (a) acima, Alice gerencia David diretamente e Clara indiretamente. Uma pessoa não gerencia a si própria, nem direta nem indiretamente.\nUm folclore que apareceu em Wall Street é que Iks é tão bem sucedido porque em sua rede de comando um(a) gerente é sempre mais jovem do que as pessoas que ele(a) gerencia. Como podemos ver na figura acima, isso não é verdade. Mas esse folclore incentivou Iks a desenvolver uma ferramenta para analisar o seu sistema de gerenciamento, e estudar se tem alguma influência no sucesso da empresa. Você foi contratado para trabalhar nessa ferramenta.\nDadas a descrição da cadeia de comando na Iks e as idades de seus empregados, escreva um programa que execute uma série de instruções. Instruções podem ser de dois tipos: trocas de gerência e perguntas. Uma instrução de troca de gerência faz dois empregados A e B trocarem suas posições na cadeia de comando. Como exemplo, a figura (b) acima mostra a cadeia de comando resultante quando David e George trocam suas respectivas posições na cadeia de comando. Uma instrução de pergunta identifica um empregado A e deseja saber a idade do mais jovem gerente (direto ou indireto) de A na cadeia de comando. Por exemplo, no cenário da figura (a) acima a idade do(a) gerente mais jovem de Clara é 18 anos; já no cenário da figura (b), a idade do(a) gerente mais jovem de Clara é 21 anos.\nEntrada\nA entrada é composta de várias linhas. A primeira linha contém três inteiros N, M e I, indicando respectivamente o número de empregados, o número de relações de gerência direta e o número de instruções. Empregados são identificados por números de 1 a N. A segunda linha contém N inteiros Ki, onde Ki indica a idade do empregado de número i.\nCada uma das M linhas seguintes contém dois inteiros X e Y , indicando que X gerencia Y diretamente. Seguem-se I linhas, cada uma descrevendo uma instrução. Uma instrução de troca de gerência é descrita em uma linha contendo o identificador T seguido de dois inteiros A e B, indicando os dois empregados que devem trocar seus lugares na cadeia de comando. Uma instrução de pergunta é descrita em uma linha contendo o identificador P seguido de um inteiro E , indicando um empregado. A última instrução será sempre do tipo pergunta.\nSaída\nPara cada instrução de pergunta seu programa deve imprimir uma linha contendo um único inteiro, a idade da pessoa mais jovem que gerencia (direta ou indiretamente) o empregado nomeado na pergunta. Se o empregado nomeado não possui um gerente, imprima o caractere ‘*’ (asterisco).\nRestrições\n• 1 ≤ N ≤ 500 • 0 ≤ M ≤ 60 × 103 • 1 ≤ I ≤ 500 • 1 ≤ Ki ≤ 100, para 1 ≤ i ≤ N • 1 ≤ X,Y ≤ N, X (cid:54)= Y • 1 ≤ A,B ≤ N • 1 ≤ E ≤ N Exemplos",
    "examples": [
      [
        "7 8 9\n21 33 33 18 42 22 26\n1 2\n1 3\n2 5\n3 5\n3 6\n4 6\n4 7\n6 7\nP 7\nT 4 2\nP 7\nP 5\nT 1 4\nP 7\nT 4 7\nP 2\nP 6",
        "18\n21\n18\n18\n*\n26"
      ],
      [
        "6 5 6\n10 20 30 40 50 60\n1 5\n1 4\n3 6\n2 5\n4 5\nP 1\nP 5\nP 6\nT 1 6\nP 1\nP 4",
        "*\n10\n30\n30\n60"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chefe"
    },
    "imagesQuant": 0
  },
  {
    "name": "Game-10",
    "description": "No princípio dos anos 1980 surgiram nos colégios os primeiros relógios de pulso digitais com joguinhos. Era uma febre entre os alunos e quem tinha um era muito popular na hora do recreio. Os joguinhos eram bem simples, mas muito legais. Um dos primeiros era o Game-10, no qual 1 1 você controlava um avião que aparecia na parte direita do visor. Na parte esquerda aparecia um disco voador em 2 2 qualquer uma de três posições, aleatoriamente, e lançava um míssil. O objetivo do jogador era movimentar o avião 3 3 verticalmente para que ficasse na frente do disco voador (na mesma linha horizontal, do lado direito) e atirar para interceptar o míssil antes que esse atingisse o avião.\nComo o movimento do avião era feito com apenas um botão, só dava para movimentar em um sentido: ao apertar o botão sucessivas vezes, o avião se movia na sequência de posições ···1 → 2 → 3 → 1 → 2 → 3 → 1··· Veja que, na situação da figura, o jogador deveria apertar o botão apenas uma vez, para ir da posição 1 para a posição 2, e conseguir atirar e interceptar o míssil.\nNeste problema vamos considerar que existem N posições e não apenas três. Dado o número de posições N, a posição D na qual o disco voador aparece, e a posição A onde está o avião, seu programa deve computar o número mínimo de vezes que o jogador precisa apertar o botão para movimentar o avião até a mesma posição do disco voador e poder atirar! Entrada\nA primeira linha da entrada contém um inteiro N, o número de posições. A segunda linha contém um inteiro D, a posição do disco voador. A terceira linha contém um inteiro A, a posição do avião.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro, o número mínimo de vezes que o jogador deve apertar o botão para poder atirar.\nRestrições\n• 3 ≤ N ≤ 100 • 1 ≤ D,A ≤ N Exemplos",
    "examples": [
      [
        "3\n2\n1",
        "1"
      ],
      [
        "20\n8\n13",
        "15"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "game10"
    },
    "imagesQuant": 0
  },
  {
    "name": "Palíndromo",
    "description": "palindromo.js ou palindromo.py Uma cadeia de caracteres é chamada de palíndromo se a sequência de caracteres da esquerda para a direita é igual à sequência de caracteres da direita para a esquerda (uma outra definição é que o primeiro caractere da cadeia deve ser igual ao último caractere da cadeia, o segundo caractere deve ser igual ao penúltimo caractere, o terceiro caractere deve ser igual ao antepenúltimo caractere, e assim por diante).\nPor exemplo, as cadeias de caracteres ‘mim’, ‘axxa’ e ‘ananaganana’ são exemplos de palíndromos.\nSe uma cadeia não é palíndroma, ela pode ser dividida em cadeias menores que são palíndromas.\nPor exemplo, a cadeia ‘aaxyx’ pode ser dividida de quatro maneiras distintas, todas elas contendo apenas cadeias palíndromas: {‘aa’, ‘xyx’}, {‘aa’, ‘x’, ‘y’, ‘x’}, {‘a’, ‘a’, ‘xyx’} e {‘a’, ‘a’, ‘x’, ‘y’, ‘x’}.\nDada uma cadeia de caracteres, escreva um programa que determine qual o menor número de partes em que a dada cadeia deve ser dividida de forma que todas as partes sejam palíndromos.\nEntrada\nA primeira linha contém um número inteiro N que indica o número de caracteres da cadeia. A segunda linha contém a cadeia de caracteres, composta por letras minúsculas, de ‘a’ a ‘z’, sem espaços em branco.\nSaída\nSeu programa deve produzir uma única linha, contendo um número inteiro, o menor número de partes em que a cadeia de entrada deve ser dividida de forma que todas as partes sejam palíndromes.\nRestrições\n• 1 ≤ N ≤ 2000 • A cadeia de caracteres contém apenas letras minúsculas não acentuadas (‘a’ a ‘z’).\nInformações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 8 • Em um conjunto de casos de teste somando 40 pontos, N ≤ 300 Exemplos",
    "examples": [
      [
        "3\naxa",
        "1"
      ],
      [
        "6\nxyzyyx",
        "4"
      ],
      [
        "10\nbbabcbbaab",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "palindromo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cartas",
    "description": "cartas.py3 Um novo game de realidade aumentada tem, dentro dele, um mini-game que aparece em certas situações para aumentar o ganho de pontos do game principal. O mini-game é um joguinho de memória com quatro cartas, formando dois pares de cartas iguais. Quer dizer, duas cartas têm um número inteiro N marcado em uma de suas faces e as outras duas cartas têm um outro número inteiro M, N (cid:54)= M. Neste problema, o jogador já virou três cartas, como mostrado na figura.\n40 11 40 Claro que, dadas as condições, a carta que falta virar vai formar par com uma das três que já foram viradas. No caso da figura, o número marcado na carta que ainda falta virar é 11. Implemente um programa que, dados os números de três cartas, imprima o número da carta que ainda falta virar! Entrada\nA primeira linha da entrada contém um inteiro A, representando a primeira carta aberta. A segunda linha contém o inteiro B, representando a segunda carta. A terceira linha contém o inteiro C, que é a terceira carta.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando o número que está na carta que ainda falta virar.\nRestrições\n• 0 ≤ A,B,C ≤ 100 Exemplos",
    "examples": [
      [
        "40\n11\n40",
        "11"
      ],
      [
        "8\n8\n96",
        "96"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cartas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Montanha",
    "description": "montanha.py2 ou montanha.py3 Um sistema de informações geográficas computadorizado está representando o perfil de uma montanha através de uma sequência de números inteiros, na qual não há dois números consecutivos iguais, como ilustrado na figura abaixo para três montanhas. Os números representam a altura da montanha ao longo de uma certa direção.\n2 3 5 6 7 5 4 2 1 2 3 4 5 6 7 2 3 6 5 4 6 3 2 O gerente do sistema de informações geográficas pesquisou e encontrou uma maneira de identificar se uma sequência de números inteiros representa uma montanha com mais de um pico, ou com apenas um pico. Ele observou que, como não há números consecutivos iguais, se houver três números consecutivos na sequência, tal que o número do meio é menor do que os outros dois números, então a montanha tem mais de um pico. Caso contrário, a montanha tem apenas um pico. De forma mais rigorosa, se a sequência é A = [A1,A2,A3,...,AN−2,AN−1,AN], ele quer saber se há uma posição i, para 2 ≤ i ≤ N − 1, tal que Ai−1 > Ai e Ai < Ai+1.\nPara ajudar o gerente, seu programa deve determinar, dada a sequência de números inteiros representando a montanha, se ela tem mais de um pico, ou se tem um pico apenas.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando o tamanho da sequência. A segunda linha contém N inteiros Ai, 1 ≤ i ≤ N, representando a sequência de alturas da montanha.\nSaída\nSeu programa deve imprimir uma linha contendo o caractere “S” se há mais de um pico, ou o caractere “N” se há apenas um pico.\nRestrições\n• 3 ≤ N ≤ 1000 • 1 ≤ Ai ≤ 1000, para 1 ≤ i ≤ N Exemplos",
    "examples": [
      [
        "8\n2 3 5 6 7 5 4 2",
        "N"
      ],
      [
        "8\n2 3 6 5 4 6 3 2",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "montanha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo de Tabuleiro",
    "description": "tabuleiro.js, tabuleiro.py2 ou tabuleiro.py3 Flavinho não se cansa de bolar joguinhos para passar o tempo. 1 2 3 4 5 6 Ele diz que é uma boa forma de treinar a memória e a capacidade de resolver problemas. Dessa vez ele inventou uma 1 forma de preencher um tabuleiro de N linhas e N colunas 2 com pedras brancas e pretas. Inicialmente ele coloca, aleatoriamente, pedras brancas e pretas em todas as células da 3 (i−1,j−1) (i−1,j) primeira coluna e da primeira linha. A figura ao lado dá um 4 (i,j−1) (i,j) exemplo de tabuleiro com N = 6. Ele chama essas pedras iniciais de sementes. Uma vez colocadas as sementes, as demais 5 células do tabuleiro serão preenchidas com uma pedra branca ou preta de acordo com a seguinte regra. 6 (N,N) Considere a célula na posição (i,j), para i > 1 e j > 1. Para saber a cor da pedra nessa célula, Flavinho precisa saber a cor das pedras nas três células {(i,j −1),(i−1,j −1),(i−1,j)}. A figura também ilustra quais células são usadas para determinar a cor da pedra na célula (i,j). Se houver mais pedras brancas do que pretas nessas três células, a cor da pedra na célula (i,j) será preta. Se houver mais pedras pretas do que brancas, a cor será branca.\nNote que, por essa definição, a primeira célula a ser preenchida será a (2,2), pois será a única vazia para a qual já saberemos a cor das três pedras necessárias. No exemplo da figura, a pedra na célula (2,2) será da cor preta, pois há duas brancas e uma preta entre as células {(2,1),(1,1),(1,2)}.\nNeste problema, dado N e a cor das sementes, seu programa deve computar a cor da pedra que será colocada na célula (N,N).\nEntrada\nA primeira linha da entrada contém um inteiro N, representando o número de linhas e colunas do tabuleiro. As N linhas seguintes contêm, cada uma, N inteiros definindo o tabuleiro inicial. Os inteiros na primeira linha e na primeira coluna do tabuleiro serão sempre 0 ou 1, representando uma pedra branca ou preta, respectivamente. Os demais inteiros serão sempre 9, indicando que a célula correspondente está vazia inicialmente.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando a cor da pedra que será colocada na célula (N,N): 0 se for branca, 1 se for preta.\nRestrições\n• 2 ≤ N ≤ 100 Exemplos",
    "examples": [
      [
        "2\n0 1\n1 9",
        "0"
      ],
      [
        "6\n0 0 1 0 0 0\n1 9 9 9 9 9\n0 9 9 9 9 9\n0 9 9 9 9 9\n1 9 9 9 9 9\n1 9 9 9 9 9",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tabuleiro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Castelos da Nlogônia",
    "description": "cores.py3 O rei da Nlogônia não consegue decidir de que cor ele vai mandar pintar os castelos do reino. Nos últimos tempos ele tem dado ordens bastante extravagantes do tipo: “pintem todos os castelos no caminho entre o castelo A e o castelo B, inclusive eles, da cor C”. Ele pode falar “no” caminho, porque os castelos da Nlogônia estão ligados por estradas entre eles de modo que existe exatamente um caminho entre quaisquer dois castelos, possivelmente passando por outros castelos, sem repetir castelos. De outra forma, sempre é possível ir de qualquer castelo para qualquer outro castelo e por apenas um caminho, sem repetir castelos.\nA Nlogônia tem N castelos, identificados por números de 1 a N. A figura ilustra uma sequência de duas operações de colorir sobre cinco castelos, numerados de 1 a 5, com cores identificadas por inteiros de 0 a 3: • colorir os castelos de 5 até 3 com a cor 1; • colorir os castelos de 2 até 4 com a cor 3.\nAo final, os castelos de 1 a 5 terão as cores 0, 3, 1, 3 e 1, respectivamente.\n1 0 1 0 1 0 2 0 3 0 2 1 3 1 2 3 3 1 5 0 4 0 5 1 4 1 5 1 4 3 Neste problema, considerando que os N castelos na Nlogônia inicialmente estão pintados da cor zero, dados os pares de castelos que estão ligados por uma estrada e uma sequência de M ordens de pintura, seu programa deve imprimir a cor que cada castelo vai ter ao final, depois que todas as ordens de pintura forem executadas em sequência.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, respectivamente o número de castelos e o número de ordens de pintura. Os castelos são indexados de 1 a N. As N −1 linhas seguintes contêm, cada uma, dois inteiros U e V distintos, indicando que existe uma estrada entre os castelos U e V diretamente. Nas M linhas seguintes, cada linha contém três inteiros P, Q e C, representando uma ordem de pintura entre os castelos P e Q, não necessariamente distintos, com a cor C.\nSaída\nSeu programa deve imprimir uma única linha, contendo a sequência de cores dos castelos de 1 a N, após todas as M ordens de pinturas terem sido executadas em sequência.\nRestrições\n• 2 ≤ N ≤ 100 e 1 ≤ M ≤ 100 • 1 ≤ U,V,P,Q ≤ N • 0 ≤ C ≤ 100 Exemplos",
    "examples": [
      [
        "5 2\n1 2\n2 5\n2 4\n4 3\n5 3 1\n2 4 3",
        "0 3 1 3 1"
      ],
      [
        "9 4\n7 1\n1 2\n6 2\n9 6\n2 5\n8 6\n4 5\n3 4\n1 4 2\n7 8 4\n3 4 1\n9 2 8",
        "4 8 1 1 2 8 4 4 8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cores"
    },
    "imagesQuant": 0
  },
  {
    "name": "Frete",
    "description": "frete.py3 O senhor Satoshi passou anos reclamando da empresa de correios do seu país, porque ela sempre transportava suas encomendas usando um caminho que passava pelo número mínimo de cidades entre a cidade onde o senhor Satoshi mora e a cidade destino da encomenda. A empresa alegava que essa estratégia levava ao menor tempo para a entrega final da encomenda. O problema é que ele notou que essa estratégia da empresa nem sempre levava ao menor preço para o frete total. Se ele pudesse escolher o caminho por onde a encomenda deveria passar para ir da sua cidade para a cidade destino, ele poderia economizar bastante com o frete, já que não havia muita urgência para a maioria de suas encomendas.\nDepois de muita reclamação, a empresa finalmente está dando aos clientes a opção de determinar o caminho por onde a encomenda deve passar. O senhor Satoshi, feliz da vida, agora quer a sua ajuda para implementar um programa que, dado o custo de transporte de uma encomenda entre vários pares de cidades pelo país, para os quais a empresa realiza entregas diretas, determine qual é o preço total mínimo para o frete entre a cidade onde ele mora e a cidade destino da encomenda.\ncusto 1 2 4 4 2 cidade 6 1 5 3 3 5 O país tem N cidades, identificadas pelos números de 1 a N. O senhor Satoshi mora na cidade 1 e o destino da encomenda será sempre a cidade N. É garantido que sempre haverá um caminho de 1 até N. No exemplo da figura, para N = 5, o custo mínimo será 7, para o caminho 1 2 4 5.\n! ! ! Entrada\nA primeira linha da entrada contém dois números inteiros N e M, representando o número de cidades e quantos pares de cidades possuem entrega direta de encomenda pela empresa. As M linhas seguintes contêm, cada uma, três inteiros A, B e C, indicando que a empresa realiza a entrega de uma encomenda diretamente entre as cidades A e B, cobrando o preço C.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando o preço mínimo total para o frete entre a cidade onde o senhor Satoshi mora, a cidade 1, e a cidade destino da encomenda, a cidade N.\nRestrições\n2 N 100 e 1 M 1000 • 1  A,B N e A= B • 1  C 1000 6 •   Exemplos",
    "examples": [
      [
        "5 6\n1 2 4\n1 3 3\n4 3 6\n4 5 2\n2 4 1\n3 5 5",
        "7"
      ],
      [
        "7 10\n1 2 5\n3 1 32\n1 4 3\n2 3 4\n2 6 20\n6 3 1\n6 4 9\n6 5 6\n3 7 18\n5 7 2",
        "18"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "frete"
    },
    "imagesQuant": 0
  },
  {
    "name": "Mapa",
    "description": "Harry ganhou um mapa mágico no qual ele pode visualizar o trajeto realizado por seus amigos.\nEle agora precisa de sua colaboração para, com a ajuda do mapa, determinar onde Hermione se encontra.\nO mapa tem L linhas e C colunas de caracteres, que podem ser ‘.’ (ponto), a letra ‘o’ ( minúscula) ou a letra ‘H’ (maiúscula). A posição inicial de Hermione no mapa é indicada pela letra ‘o’, que aparece exatamente uma vez no mapa. A letra ‘H’ indica uma posição em que Hermione pode ter passado – o mapa é impreciso, e nem toda letra ‘H’ no mapa representa realmente uma posição pela qual Hermione passou. Mas todas as posições pelas quais Hermione passou são representadas pela letra ‘H’ no mapa.\nA partir da posição inicial de Hermione, Harry sabe determinar a posição atual de sua amiga, apesar da imprecisão do mapa, porque eles combinaram que Hermione somente se moveria de forma que seu movimento apareceria no mapa como estritamente horizontal ou estritamente vertical (nunca diagonal). Além disso, Hermione combinou que não se moveria de forma a deixar que Harry tivesse dúvidas sobre seu caminho (por exemplo, Hermione não passa duas vezes pela mesma posição).\nConsidere o mapa abaixo, com 6 linhas e 7 colunas: 1 2 3 4 5 6 7 1 . . . H H H .\n2 H H H . . . H 3 H . H H H . .\n4 H . . . H H .\n5 H . o . . . .\n6 H H H . . H H A posição inicial de Hermione no mapa é (5,3), e sua posição atual é (4,6). As posições marcadas em negrito (‘H’) são erros no mapa.\nDado um mapa e a posição inicial de Herminone, você deve escrever um programa para determinar a posição atual de Herminone.\nEntrada\nA primeira linha contém dois números inteiros L e C, indicando respectivamente o número de linhas e o número de colunas. Cada uma das seguintes L linhas contém C caracteres.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo dois números inteiros: o número da linha e o número da coluna da posição atual de Hermione.\nRestrições\n2 L 100 • 2  C  100 •   Apenas os caracteres ‘.’, ‘o’ e ‘H’ aparecem no mapa.\n• A letra ‘o’ aparece exatamente uma vez no mapa.\n• A letra ‘H’ aparece ao menos uma vez no mapa.\n• O caminho de Hermione está totalmente contido no mapa.\n• Na posição da letra ‘o’ no mapa, há apenas uma letra ‘H’ como vizinho imediato na vertical • ou horizontal.\nNa posição atual de Hermione no mapa, há apenas uma letra ‘H’ como vizinho imediato na • vertical ou horizontal.\nEm cada uma das posições intermediárias do caminho de Hermione, há exatamente duas letras • ‘H’ como vizinhas imediatas na vertical ou horizontal.\nInformações sobre a pontuação\nEm um conjunto de casos de teste somando 20 pontos, N 8 •  Exemplos",
    "examples": [
      [
        "3 4\nHHHH\nH...\no.HH",
        "1 4"
      ],
      [
        "6 7\n...HHH.\nHHH....\nH.HHH..\nH...HH.\nH.o....\nHHH.HH.",
        "4 6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mapa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cortando o Papel",
    "description": "papel.py3 Uma folha de papel é composta de uma sequência de retângulos com diferentes alturas mas com larguras fixas, tal que as bases dos retângulos estão assentadas em uma linha horizontal. A figura ilustra uma folha exemplo com 33 retângulos. Nós gostaríamos de fazer um único corte horizontal, com a ajuda de um estilete e uma régua, que maximize o número resultante de pedaços separados pelo corte. A figura mostra quatro diferentes cortes que resultariam, respectivamente, em 4,11,10 e 3 pedaços.\n3 10 11 4 1 33 Entrada\nA primeira linha da entrada contém um inteiro N, representando o número de retângulos na folha de papel. A segunda linha contém N inteiros Ai, 1  i  N, representando a sequência de alturas dos retângulos.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando o número máximo de pedaços possível, com um único corte horizontal.\nRestrições\n1 N 105 • • 1   Ai  109, para 1  i  N Informações sobre a pontuação\nEm um conjunto de casos de teste somando 40 pontos, N 1000 •  Exemplos",
    "examples": [
      [
        "10\n20 5 10 5 15 15 15 5 6 22",
        "5"
      ],
      [
        "5\n10 20 30 40 50",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "papel"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dario e Xerxes",
    "description": "xerxes.py3 A brincadeira da Pedra, Papel e Tesoura, muita gente co- 0 1 nhece. Mas dá para fazer uma mais legal com cinco opções e não só três! Dois jogadores, dario e xerxes, jogam uma partida com N rodadas. Em cada rodada os jogadores escolhem uma “mão” entre cinco opções, que vamos representar aqui com os números 0, 1, 2, 3 e 4. A figura define 4 2 exatamente quem ganha a rodada. Por exemplo, se dario escolheu 0 e xerxes escolheu 3, então xerxes ganha a rodada, pois existe uma seta na figura indo de 3 para 0. 3 Depois de N rodadas, o vencedor da partida é o jogador que ganhou mais rodadas. O número N será sempre ímpar, para não haver empate na partida. Vamos também considerar que os jogadores nunca escolhem a mesma mão numa rodada, para não haver empate na rodada. Você deve escrever um programa que determine quem venceu a partida, se foi dario ou xerxes.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de rodadas na partida. Cada uma das N linhas seguintes contém dois inteiros D e X, representando a mão que os jogadores dario e xerxes, respectivamente, jogaram em uma rodada.\nSaída\nSeu programa deve imprimir uma linha contendo o nome do jogador que venceu a partida: dario ou xerxes. Todas as letras devem ser minúsculas, sem nenhum acento! Restrições\n1 N 999, N é impar • 0  D,X 4 e D = X •   6 Exemplos",
    "examples": [
      [
        "3\n1 3\n4 2\n0 2",
        "dario"
      ],
      [
        "1\n3 1",
        "xerxes"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "xerxes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Gomoku",
    "description": "gomoku.py3 Gomoku é um jogo japonês milenar, jogado em um tabuleiro de 15x15 células e pedras pretas e brancas. Um jogador joga com as pedras brancas, o outro joga com as pedras pretas. O objetivo do jogo, como o nome sugere – go-moku em japonês quer dizer cinco pedras – é colocar cinco pedras da mesma cor consecutivamente ou numa mesma linha, ou numa mesma coluna, ou numa diagonal do tabuleiro.\nAs figuras abaixo ilustram algumas configurações do jogo (apenas uma parte do tabuleiro é mostrada): pretas ganham brancas ganham ninguém ganha pretas ganham Entrada\nA entrada é composta por quinze linhas, cada uma contendo quinze inteiros. Cada inteiro representa o conteúdo de uma célula do tabuleiro. O número 1 indica uma pedra preta, o número 2 indica uma pedra branca e o número 0 indica que não há pedra na célula.\nSaída\nSeu programa deve produzir uma única linha, contendo o inteiro 1 se o jogador com as pedras pretas venceu, o inteiro 2 se o jogador com as pedras brancas venceu, ou o número 0 se ainda não há vencedor na configuração da entrada.\nRestrições\n• Cada célula tem o valor 0, 1 ou 2.\n• Em todos os testes, há apenas um vencedor, ou não há vencedor.\nExemplo",
    "examples": [
      [
        "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 2 0 0 2 2 2 1 0 0 0 0 0 0\n0 0 1 2 0 0 0 0 1 0 0 0 0 0 0\n0 0 0 1 2 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 2 2 0 0 0 0 0 0 0 0\n0 0 1 1 0 1 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 2 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0",
        "1"
      ],
      [
        "0 0 0 0 0 0 0 0 0 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 2 0 1 0 0 0\n0 0 0 0 0 2 1 1 1 2 0 2 2 1 0\n0 0 0 0 0 0 0 0 0 2 0 1 0 0 0\n0 0 0 0 0 0 2 0 2 2 1 1 0 0 0\n0 0 0 0 0 2 1 1 1 1 2 2 1 0 0\n0 0 0 0 0 0 1 0 1 0 0 1 0 2 0\n0 0 0 0 0 0 0 2 1 0 2 0 0 0 0\n0 0 0 0 0 0 0 0 2 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "gomoku"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ônibus",
    "description": "onibus.py3 A Linearlândia é composta de N cidades, numeradas de 1 até N. Para alguns pares de cidades existe uma linha de ônibus que faz o trajeto de ida e volta diretamente entre as duas cidades do par. Os pares de cidades ligados diretamente por uma linha de ônibus são escolhidos de forma que sempre é possí- 12 vel ir de qualquer cidade para qualquer outra cidade por um, e somente um, caminho (um caminho é uma sequência de linhas de ônibus, sem repetição).\nDada a lista de pares de cidades ligados diretamente por linhas de ônibus, uma cidade origem e uma ci2 dade destino, seu programa deve computar quantos ônibus é preciso pegar para ir da origem ao destino.\nPor exemplo, na figura, para ir da cidade 2 para a cidade 12 é preciso pegar 4 ônibus.\nEntrada\nA primeira linha da entrada contém três inteiros N, A e B, representando o número de cidades na Linearlândia, a cidade origem e a cidade destino, respectivamente. As N−1 linhas seguintes contém, cada uma, dois inteiros P e Q, indicando que existe uma linha de ônibus ligando diretamente as cidades P e Q.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando quantos ônibus é preciso pegar para ir de A até B.\nRestrições\n• 2 ≤ N ≤ 10000 • 1 ≤ A ≤ N, 1 ≤ B ≤ N, A (cid:54)= B • 1 ≤ P ≤ N, 1 ≤ Q ≤ N Exemplos",
    "examples": [
      [
        "4 2 4\n1 2\n2 3\n3 4",
        "2"
      ],
      [
        "16 2 12\n3 5\n12 3\n5 1\n2 1\n4 1\n6 1\n7 1\n12 8\n12 9\n12 10\n12 11\n3 13\n13 14\n15 13\n15 16",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "onibus"
    },
    "imagesQuant": 0
  },
  {
    "name": "Zip",
    "description": "Um jogo de cartas que faz muito sucesso no reino da Nlogônia é chamado zip. Nesse jogo, apenas os valores das cartas são utilizados (ás a rei), os naipes das cartas são ignorados. Para simplificar, neste problema vamos considerar os valores das cartas como inteiros de 1 a 13.\nEm cada partida do jogo cada jogador recebe duas cartas. Cada jogador então mostra uma de suas cartas, e os jogadores fazem suas apostas (na Nlogônia só é permitido apostar grãos de feijão). Após as apostas, os jogadores mostram a sua segunda carta.\nAs regras para determinar quem ganha a partida são simples, baseadas nos valores das cartas de cada jogador: • se as duas cartas têm o mesmo valor, o jogador recebe como pontuação na partida duas vezes a soma dos valores das cartas.\n• se os valores das duas cartas são números consecutivos (por exemplo, 2 e 3, ou 13 e 12), o jogador recebe como pontuação na partida três vezes a soma dos valores das cartas.\n• caso contrário, o jogador recebe como pontuação na partida a soma dos valores das cartas.\nGanha a partida o jogador que tiver recebido a maior pontuação. Se houver empate, a aposta acumula para a próxima partida.\nLia e Carolina estão jogando zip, e querem que você escreva um programa para conferir quem ganhou cada partida.\nEntrada\nA entrada é composta por quatro linhas, cada uma contendo um inteiro. As duas primeiras linhas indicam as cartas de Lia, as duas últimas linhas indicam as cartas de Carolina.\nSaída\nSeu programa deve produzir uma única linha, contendo o nome da jogadora que venceu a partida.\nSe houve empate, a linha deve conter a palavra empate (em minúsculas).\nRestrições\n• As cartas que cada jogadora recebe têm o valor entre 1 e 13.\nExemplos",
    "examples": [
      [
        "3\n3\n7\n4",
        "Lia"
      ],
      [
        "2\n3\n11\n4",
        "empate"
      ],
      [
        "5\n5\n4\n3",
        "Carolina"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "zip"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bits",
    "description": "Duas sequências de N bits são distintas se, para alguma posição i, 1 ≤ i ≤ N, o bit na posição i de uma sequência é distinto do bit na posição i da outra sequência. As duas sequências de N = 10 bits abaixo são distintas pois, por exemplo, os bits na posição 7, da esquerda para a direita, são distintos: 0 1 0 0 0 1 1 0 1 0 1 0 0 1 0 1 0 0 1 0 Mas veja que as duas sequências acima, apesar de distintas, têm uma característica em comum: não há três bits 1 consecutivos nelas. Neste problema, dado o número de bits N e um K, seu programa deve computar quantas sequências distintas de N bits existem, nas quais não há K bits 1 consecutivos.\nEntrada\nA entrada consiste de uma linha contendo os dois inteiros N e K.\nSaída\nImprima uma linha contendo um inteiro, representando o número de sequências distintas de N bits, nas quais não há K bits 1 consecutivos. Porque esse número pode ser muito grande, você deve imprimir o resto da divisão dele por 109 + 7.\nRestrições\n• 1 ≤ N ≤ 1000 • 1 ≤ K ≤ N + 1 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 20 Exemplos",
    "examples": [
      [
        "4 2",
        "8"
      ],
      [
        "10 3",
        "504"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bits"
    },
    "imagesQuant": 0
  },
  {
    "name": "Visita entre cidades",
    "description": "visita.py3 A Linearlândia é composta de N cidades, numeradas de 1 até N. Para alguns pares de cidades existe exatamente uma estrada bidirecional entre as duas cidades do par. Os pares de cidades ligados diretamente por uma estrada são escolhidos de forma que 9 10 sempre é possível ir de qualquer cidade para qual- 8 3 3 3 quer outra cidade por um, e somente um, caminho (um caminho é uma sequência de estradas, sem re- 2 12 3 11 p D p dee oa st rd ,iç a e uã sao mt) rl a. ais dt caa is d,d ae das epa d or rie s is gtâ ed n me cc ia eid s ua e md ne ats rel ci ig doa asd do p es ar dd e ei sr se tdt ina em oc ,e i sdn et a ue 4 310 15 5 5 8 33 6 programa deve computar qual a distância entre a 6 7 13 7 cidade de origem e a cidade destino, usando as es- 7 6 10 16 tradas. Por exemplo, na figura, a distância para ir 14 15 da cidade 12 para a cidade 7 é 23; a distância da cidade 15 para a cidade 12 é 16; e a distância da cidade 7 para a cidade 15 é 33.\nEntrada\nA primeira linha da entrada contém três inteiros N, A e B, representando o número de cidades na Linearlândia, a cidade origem e a cidade destino, respectivamente. As cidades são identificadas por inteiros de 1 a N. As N − 1 linhas seguintes contém, cada uma, três inteiros P, Q e D, indicando que existe uma estrada ligando diretamente as cidades P e Q, com distância D.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando a distância para ir de A até B pelas estradas de Linearlândia.\nRestrições\n• 2 ≤ N ≤ 10000 • 1 ≤ A ≤ N, 1 ≤ B ≤ N, A (cid:54)= B • 1 ≤ P ≤ N, 1 ≤ Q ≤ N • 1 ≤ D ≤ 100 Exemplos",
    "examples": [
      [
        "4 2 4\n1 2 10\n2 3 11\n3 4 12",
        "23"
      ],
      [
        "16 15 7\n3 5 8\n12 3 3\n5 1 5\n2 1 5\n4 1 10\n6 1 3\n7 1 7\n12 8 3\n12 9 3\n12 10 3\n12 11 3\n3 13 6\n13 14 6\n15 13 7\n15 16 10",
        "33"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "visita"
    },
    "imagesQuant": 0
  },
  {
    "name": "Arranha-céu",
    "description": "arranhaceu.js, arranhaceu.py2 ou arranhaceu.py3 Um arranha-céu residencial possui N andares, numerados de 1 a N. O síndico do arranha-céu está tendo muito trabalho com uma nova regra do corpo de bombeiros. Ele não sabe o porquê, mas os bombeiros apontam um andar k e exigem que o síndico informe o total de pessoas que moram no arranha-céu do andar 1 até o andar k, inclusive. Talvez seja alguma medida de segurança dos bombeiros! O problema é que o prédio tem muitos andares e toda hora tem gente se mudando, passando a morar no arranha-céu, ou indo embora. O síndico precisa cuidar de dois eventos: • Mudança: alterar o número de pessoas que moram num determinado andar; • Bombeiro: informar o total de pessoas que moram do andar 1 até um determinado andar, inclusive.\nDados o número de pessoas que moram em cada andar do arranha-céu inicialmente, e uma sequência de eventos (do tipo Mudança ou Bombeiro), seu programa deve imprimir, para cada evento do tipo Bombeiro, o total de pessoas exigido, no momento do evento! Entrada\nA primeira linha da entrada contém dois inteiros N e Q, representando, respectivamente, o número de andares e o número de eventos. A segunda linha contém N inteiros Ai, 1 ≤ i ≤ N, indicando o número de pessoas que moram no i-ésimo andar inicialmente. Cada uma das Q linhas seguintes representa um evento e tem uma de duas formas: • “0 K P”, Mudança, alterar o número de pessoas que moram no K-ésimo andar para P pessoas; • “1 K”, Bombeiro, informar o total de pessoas que moram do andar 1 até o andar K, inclusive.\nSaída\nPara cada evento do tipo Bombeiro, seu programa deve imprimir uma linha contendo um inteiro representando o total de pessoas correspondente aquele evento.\nRestrições\n• 1 ≤ N ≤ 105 e 1 ≤ Q ≤ N • Há pelo menos um evento do tipo Bombeiro • 1 ≤ K ≤ N • 0 ≤ Ai ≤ 1000 e 0 ≤ P ≤ 1000 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 20000 Exemplos",
    "examples": [
      [
        "8 4\n30 2 0 42 10 11 11 9\n1 5\n0 4 12\n1 5\n1 1",
        "84\n54\n30"
      ],
      [
        "1 1\n0\n1 1",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "arranhaceu"
    },
    "imagesQuant": 0
  },
  {
    "name": "Código",
    "description": "codigo.py3 A professora Maryam está tentando construir um código constituído de uma sequência de N strings de 10 letras minúsculas, S1,S2,S3,...,SN. Essas strings da sequência serão, no futuro, concatenadas de diversas maneiras para formar strings maiores. Mas, para que o código seja válido, a sequência de strings tem que satifazer uma propriedade bastante específica: nenhuma string da sequência pode ser substring de uma concatenação de duas strings anteriores na sequência. De forma mais rigorosa, o código será inválido se existirem três inteiros a,b e k, tais que: • 1 ≤ a < k ≤ N, 1 ≤ b < k ≤ N (a pode ser igual a b); e • Sk é substring da concatenação SaSb.\nPor exemplo, o código S = {aaaaaaabbb,yyuudiwwkl,kkfidaaooa} é válido. Mas se adicionarmos a string aooaaaaaaa no final da sequência, o código resultante, S(cid:48) = {aaaaaaabbb,yyuudiwwkl, kkfidaaooa,aooaaaaaaa}, será inválido, pois S4(cid:48) é substring da concatenação S3(cid:48)S1(cid:48).\nDada a sequência de strings, seu programa deve determinar se o código é válido, ou não.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando o número de strings na sequência.\nAs N linhas seguintes contêm, cada uma, uma string de 10 letras minúsculas, definindo a sequência de strings do código.\nSaída\nSeu programa deve imprimir uma linha contendo a string “ok” caso o código seja válido, ou contendo a primeira string na sequência que invalida o código. Quer dizer, contendo Sk onde k é o menor possível tal que Sk seja substring de uma concatenação de duas strings anteriores na sequência.\nRestrições\n• 1 ≤ N ≤ 10000 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 40 pontos, N ≤ 100 Exemplos",
    "examples": [
      [
        "3\naaaaaaabbb\nyyuudiwwkl\nkkfidaaooa",
        "ok"
      ],
      [
        "4\naaaaaaabbb\nyyuudiwwkl\nkkfidaaooa\naooaaaaaaa",
        "aooaaaaaaa"
      ],
      [
        "1\njfjshiddds",
        "ok"
      ],
      [
        "2\nabcdefghij\nabcdefghij",
        "abcdefghij"
      ],
      [
        "8\nxfwvijuydq\nhcprvezofg\nhwykagqawu\ngivfzndqpy\nyvfiqgadfc\nwuhcprvezo\nqaswiksscl\nuchskpkcit",
        "wuhcprvezo"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "codigo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dividindo o império",
    "description": "imperio.py2 ou imperio.py3 Um grande Império é composto por N cidades, numeradas de 1 até N. Alguns pares de cidades estão ligados diretamente por estradas bidirecionais e, por uma antiga tradição, esses pares são escolhidos de maneira que sempre é possível ir de qualquer cidade para qualquer outra cidade por exatamente um ca- 12 minho (um caminho é uma sequência de estradas).\nO imperador quer dividir seu império em dois para 3 deixar de herança para seus dois filhos. Ele percebeu 5 que basta destruir exatamente uma estrada, qualquer estrada, para dividir seu império em dois menores que, separadamente, preservam a antiga tradição. Ele agora precisa da sua ajuda para computar a menor diferença possível no número de cidades entre os dois impérios resultantes.\nPor exemplo, na figura, se o imperador destruir a estrada entre as cidades 3 e 12, os impérios resultantes terão 5 e 11 cidades, uma diferença de 6 cidades. Porém, se ele destruir a estrada entre as cidades 3 e 5, a diferença será de apenas 4 cidades. Você consegue ver que essa é a menor diferença possível para esse exemplo da figura? Entrada\nA primeira linha da entrada contém um inteiro N, representando o número de cidades no império.\nAs N −1 linhas seguintes contém, cada uma, dois inteiros A e B, indicando que existe uma estrada bidirecional ligando diretamente as cidades A e B.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando a menor diferença possível no número de cidades entre os dois impérios resultantes.\nRestrições\n• 2 ≤ N ≤ 105 • 1 ≤ A ≤ N, 1 ≤ B ≤ N Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 40 pontos, N ≤ 10000 Exemplos",
    "examples": [
      [
        "4\n1 2\n2 3\n3 4",
        "0"
      ],
      [
        "16\n3 5\n12 3\n5 1\n2 1\n4 1\n6 1\n7 1\n12 8\n12 9\n12 10\n12 11\n3 13\n13 14\n15 13\n15 16",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "imperio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Postes",
    "description": "postes.py3 Seu João é proprietário de uma enorme fazenda, protegida por uma cerca formada por postes de madeira e arame farpado. Cada poste da cerca tem 1 metro de altura. Os postes são colocados separados dois metros um dos outros, ao redor de toda a fazendo, e portanto muitos postes são utilizados.\nInfelizmente um incêndio destruiu uma grande parte dos postes da cerca. Alguns postes, mesmo um pouco queimados, ainda podem ser utilizados, desde que sejam reforçados. Outros estão irremediavelmente inutilizados e devem ser substituídos por postes novos.\nO engenheiro que trabalha para o Seu João percorreu toda a cerca e fez uma lista dos tamanhos de cada poste depois do incêndio. O engenheiro determinou que, se o poste tem menos do que 50 cm, ele deve ser substituído. Se o poste tem ao menos 50 cm, mas menos do que 85 cm, ele deve ser consertado. Se o poste tem 85 cm ou mais, ele não necessita conserto e pode ser usado normalmente.\nDada a lista com os tamanhos de cada poste, você deve escrever um programa para determinar o número de postes que devem ser substituídos e o número de postes que devem ser reforçados para consertar a cerca da fazenda do Seu João.\nEntrada\nA primeira linha da entrada contém um inteiro N, indicando o número de postes da cerca. A segunda linha contém N números inteiros Xi, indicando os tamanhos dos postes após o incêndio.\nSaída\nSeu programa deve produzir uma única linha, contendo dois inteiros: o número de postes que devem ser substituídos, seguido do número de postes que devem ser consertados.\nRestrições\n• 3 ≤ N ≤ 1000 • 0 ≤ Xi ≤ 100 Exemplos",
    "examples": [
      [
        "5\n85 49 50 84 50",
        "1 3"
      ],
      [
        "4\n48 49 30 47",
        "4 0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "postes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Taxa",
    "description": "Uma empresa está construindo um condomínio de casas ao redor de um lago. As casas serão construídas em lotes de terra de diferentes tamanhos, mas todos os lotes serão às margens do lago.\nAlém disso, cada lote de terra terá exatamente dois vizinhos no condomínio, um vizinho à direita e um vizinho à esquerda.\n100 300 Lago 500 200 100 100 A empresa é dona de todo o terreno do condomínio e necessita dividir o terreno em lotes, de acordo com o projeto do condomínio. No entanto, a Prefeitura tem uma lei curiosa de imposto sobre divisão de terra, criada para inibir a criação de lotes de terra muito pequenos: 1. um terreno pode ser dividido apenas usando uma sequência de divisões de terreno; 2. uma divisão de terreno é uma operação que divide um terreno em duas partes; e 3. para cada divisão de terreno deve ser pago um imposto.\nChamando de A a área da maior parte de terreno resultante da divisão, o valor do imposto sobre a divisão de terra é A × F, onde F é o fator de divisão, definido anualmente pela Prefeitura. Note que devido a (2), para dividir um terreno em N lotes, são necessárias N − 1 divisões de terra, e portanto N − 1 pagamentos devem ser feitos à Prefeitura.\nPor exemplo, considerando a figura acima, se o fator de divisão é 2.5 e a primeira divisão de terreno separa o lote com 500 unidades de área dos outros lotes, o imposto a ser pago nesta primeira divisão é 2.5×(300+200+100+100+100). Se a próxima divisão de terreno separa dos lotes restantes o lote de 300 unidades junto com seu lote vizinho de 100 unidades, um imposto adicional de 2.5×(300+100) deve ser pago; e assim por diante. Note também que algumas divisões de terra não são possíveis, devido a (2). Por exemplo, após a primeira divisão de terreno mencionada anteriormente não é possível fazer uma divisão para separar a área formada pelo lote de 300 unidades e o lote de 200 unidades da área formada pelos três lotes restantes, porque mais do que duas partes resultariam dessa operação.\nDadas as áreas de todos os lotes ao redor do lago e o valor corrente do fator de divisão, escreva um programa para determinar o menor valor de imposto total que deve ser pago para dividir a terra de acordo com o projeto de condomínio.\nEntrada\nA primeira linha contém um número inteiro N e um número real F, indicando respectivamente o número de lotes no condomínio e o fator de divisão (com precisão de dois dígitos). A segunda linha contém N números inteiros Xi, representando as áreas de lotes vizinhos no projeto do condomínio, para 1 ≤ i ≤ N, sendo que Xk é vizinho de Xk+1 para 1 ≤ k ≤ N − 1, e XN é vizinho de X1.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo o valor mínimo do imposto a ser pago, como um número real com precisão de dois dígitos decimais.\nRestrições\n• 1 ≤ N ≤ 200 • 0 ≤ F ≤ 5.00 • 0 < Xi ≤ 500, para 1 ≤ i ≤ N Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 8 Exemplos",
    "examples": [
      [
        "4 1.50\n2 1 4 1",
        "13.50"
      ],
      [
        "6 2.50\n300 100 500 100 100 200",
        "4500.00"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "taxa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Carrinho",
    "description": "carrinho.py2 ou carrinho.py3 Um carrinho elétrico, que usa apenas uma bateria com carga inicial de C coulombs, tem uma característica incrível: ele só pode ir à velocidade constante mas pode escolher qualquer velocidade constante, maior do que zero, de V metros por segundo. Só que quanto maior a velocidade, menor a autonomia. Quer dizer, de maneira mais rigorosa, a distância máxima dmax metros que ele pode percorrer é diretamente proporcional à carga inicial da bateria e inversamente proporcional à velocidade: dmax = VC. É incrível mas veja que, mesmo que a carga seja muito pequena, o carrinho sempre pode percorrer qualquer distância, desde que vá a uma velocidade suficientemente pequena! O carrinho está na posição zero de uma pista reta com comprimento D metros. Há N baterias, com diferentes cargas, colocadas em posições distintas ao longo da pista, uma delas na posição zero.\nConsidere que nosso carrinho ideal consegue fazer um pit-stop instantâneo, trocando de bateria sem perder tempo algum. Ao passar por uma nova bateria ele pode decidir ou não fazer a troca; e ele pode alterar sua velocidade apenas num instante em que troca de bateria. Qual é o tempo mínimo possível para o carrinho chegar ao final da pista? Entrada\nA primeira linha da entrada contém um inteiro N e um real D, respectivamente, o número de baterias e o comprimento da pista. As N linhas seguintes contêm, cada uma, dois reais P e C definindo, respectivamente, a posição e a carga das baterias. Sempre existe uma bateria na posição 0.0 e as baterias são dadas em ordem estritamente crescente de posição.\nSaída\nImprima uma linha contendo um real, com exatamente três casas decimais, o tempo mínimo possível em segundos para o carrinho chegar ao final da pista.\nRestrições\n• 1 ≤ N ≤ 1000 e 1.0 ≤ D ≤ 10000.0 • 0.0 ≤ P < D e 0.0 < C < 100.0 Exemplos",
    "examples": [
      [
        "4 10.000\n0.000 1.000\n1.200 0.100\n3.000 10.000\n7.700 1.000",
        "13.900"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2017,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "carrinho"
    },
    "imagesQuant": 0
  },
  {
    "name": "Álbum da copa",
    "description": "Em ano de Copa do Mundo de Futebol, o álbum de figurinhas oficial é sempre um grande sucesso entre crianças e também entre adultos. Para quem não conhece, o álbum contém espaços numerados de 1 a N para colar as figurinhas; cada figurinha, também numerada de 1 a N, é uma pequena foto de um jogador de uma das seleções que jogará a Copa do Mundo. O objetivo é colar todas as figurinhas nos respectivos espaços no álbum, de modo a completar o álbum (ou seja, não deixar nenhum espaço sem a correspondente figurinha).\nAs figurinhas são vendidas em envelopes fechados, de forma que o comprador não sabe quais figurinhas está comprando, e pode ocorrer de comprar uma figurinha que ele já tenha colado no álbum.\nPara ajudar os usuários, a empresa responsável pela venda do álbum e das figurinhas quer criar um aplicativo que permita gerenciar facilmente as figurinhas que faltam para completar o álbum e está solicitando a sua ajuda.\nDados o número total de espaços e figurinhas do álbum, e uma lista das figurinhas já compradas (que pode conter figurinhas repetidas), sua tarefa é determinar quantas figurinhas faltam para completar o álbum.\nEntrada\nA primeira linha contém um inteiro N indicando o número total de figurinhas e espaços no álbum.\nA segunda linha contém um inteiro M indicando o número de figurinhas já compradas. Cada uma das M linhas seguintes contém um número inteiro X indicando uma figurinha já comprada.\nSaída\nSeu programa deve produzir uma única linha contendo um inteiro representando o número de figurinhas que falta para completar o álbum.\nRestrições\n• 1 ≤ N ≤ 100 • 1 ≤ M ≤ 300 • 1 ≤ X ≤ N",
    "examples": [
      [
        "10\n3\n5\n8\n3",
        "7"
      ],
      [
        "5\n6\n3\n3\n2\n3\n3\n3",
        "3"
      ],
      [
        "3\n4\n2\n1\n3\n3",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "album"
    },
    "imagesQuant": 0
  },
  {
    "name": "Basquete de robôs",
    "description": "A organização da OIBR, Olimpíada Internacional de 1 pt 2 pts 3 pts Basquete de Robô, está começando a ter problemas com dois times: os Bit Warriors e os Byte Bulls. É que os robôs desses times acertam quase todos os lançamentos, de qualquer posição na quadra! Pensando bem, o jogo de basquete ficaria mesmo sem graça se jogadores conseguissem acertar qualquer lançamento, não é mesmo? Uma das medidas que a OIBR está implantando é uma nova pontuação para os lançamentos, de acordo com a distância do robô para o início da quadra. A quadra tem 2000 centímetros de comprimento, como na figura. 0 800 1400 2000 Dada a distância D do robô até o início da quadra, onde está a cesta, a regra é a seguinte: • Se D ≤ 800, a cesta vale 1 ponto; • Se 800 < D ≤ 1400, a cesta vale 2 pontos; • Se 1400 < D ≤ 2000, a cesta vale 3 pontos.\nA organização da OIBR precisa de ajuda para automatizar o placar do jogo. Dado o valor da distância D, você deve escrever um programa para calcular o número de pontos do lançamento.\nEntrada\nA primeira e única linha da entrada contém um inteiro D indicando a distância do robô para o início da quadra, em centímetros, no momento do lançamento.\nSaída\nSeu programa deve produzir uma única linha, contendo um inteiro, 1, 2 ou 3, indicando a pontuação do lançamento.\nRestrições\n• 0 ≤ D ≤ 2000",
    "examples": [
      [
        "1720",
        "3"
      ],
      [
        "250",
        "1"
      ],
      [
        "1400",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "basquete"
    },
    "imagesQuant": 0
  },
  {
    "name": "Escadinha",
    "description": "Dizemos que uma sequência de números é uma escadinha, se a diferença entre números consecutivos é sempre a mesma. Por exemplo, “2, 3, 4, 5” e “10, 7, 4” são escadinhas. Note que qualquer sequência com apenas um ou dois números também é uma escadinha! Neste problema estamos procurando escadinhas em uma sequência maior de números. Dada uma sequência de números, queremos determinar quantas escadinhas existem. Mas só estamos interessados em escadinhas tão longas quanto possível. Por isso, se uma escadinha é um pedaço de outra, consideramos somente a maior. Por exemplo, na sequência “1, 1, 1, 3, 5, 4, 8, 12” temos 4 escadinhas diferentes: “1, 1, 1”, “1, 3, 5”, “5, 4” e “4, 8, 12”.\nEntrada\nA primeira linha da entra contém um inteiro N indicando o tamanho da sequência de números. A segunda linha contém N inteiros definindo a sequência.\nSaída\nImprima uma linha contendo um inteiro representando quantas escadinhas existem na sequência Restrições\n• 1 ≤ N ≤ 1000 • O valor dos números da sequência está entre −106 e 106 inclusive.",
    "examples": [
      [
        "8\n1 1 1 3 5 4 8 12",
        "4"
      ],
      [
        "1\n112",
        "1"
      ],
      [
        "5\n11 -106 -223 -340 -457",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "escadinha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pirâmide",
    "description": "No depósito da fábrica, encostada numa parede, existe uma matriz de N linhas por N colunas de caixas empilhadas. Cada caixa possui um peso inteiro positivo associado. O inspetor da fábrica precisa retirar algumas caixas da matriz de modo a deixar uma espécie de pirâmide de caixas satisfazendo as seguintes restrições: • Se uma caixa está na pirâmide, a caixa imediatamente abaixo dela também deve estar na pirâmide; • Na i-ésima linha de caixas (a linha 1 é a do topo da matriz), a pirâmide deve ter exatamente i caixas consecutivas.\nDados os pesos de todas as caixas na matriz, seu programa deve calcular o peso total mínimo que uma pirâmide poderá ter, se o inspetor retirar algumas caixas segundo as restrições acima.\nEntrada\nA primeira linha da entrada contém um inteiro N, indicando a dimensão da matriz. As N linhas seguintes contêm, cada uma, N inteiros representando os pesos das caixas em cada linha da matriz de caixas.\nSaída\nSeu programa deve produzir uma única linha, contendo um inteiro, indicando o peso total mínimo que a pirâmide poderá ter.\nRestrições\n• 1 ≤ N ≤ 100 • Os valor dos elementos da matriz está entre 1 e 100, inclusive.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 20.",
    "examples": [
      [
        "3\n5 2 4\n3 6 7\n10 5 10",
        "36"
      ],
      [
        "4\n45 8 3 1\n1 10 5 67\n4 4 3 18\n10 4 7 12",
        "62"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "piramide"
    },
    "imagesQuant": 0
  },
  {
    "name": "Xadrez",
    "description": "No tabuleiro de xadrez, a casa na linha 1, coluna 1 (canto superior esquerdo) é sempre branca e as cores das casas 1 2 3 4 5 6 7 8 9 se alternam entre branca e preta, de acordo com o padrão 1 conhecido como... xadrez! Dessa forma, como o tabuleiro 2 tradicional tem oito linhas e oito colunas, a casa na linha 8, 3 coluna 8 (canto inferior direito) será também branca. Neste problema, entretanto, queremos saber a cor da casa no canto 4 inferior direito de um tabuleiro com dimensões quaisquer: 5 L linhas e C colunas. No exemplo da figura, para L = 6 e 6 C = 9, a casa no canto inferior direito será preta! Entrada\nA primeira linha da entrada contém um inteiro L indicando o número de linhas do tabuleiro. A segunda linha da entrada contém um inteiro C representando o número de colunas.\nSaída\nImprima uma linha na saída. A linha deve conter um inteiro, representando a cor da casa no canto inferior direito do tabuleiro: 1, se for branca; e 0, se for preta.\nRestrições\n• 1 ≤ L,C ≤ 1000",
    "examples": [
      [
        "6\n9",
        "0"
      ],
      [
        "8\n8",
        "1"
      ],
      [
        "5\n91",
        "1"
      ],
      [
        "401\n322",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "xadrez"
    },
    "imagesQuant": 0
  },
  {
    "name": "Câmara de Compensação",
    "description": "Em uma cidade, muitas pessoas emprestam dinheiro para outras pessoas. A coisa chegou a um tal ponto que tem gente que é ao mesmo tempo devedor e credor. As pessoas resolveram então pagar suas dívidas e cada uma emitiu os cheques para pagar suas dívidas. Por exemplo, na figura, item (a), a pessoa C emitiu um cheque de 5 dinheiros para a pessoa A, e a pessoa D emitiu um cheque de 3 dinheiros para a pessoa C. Ou seja, a pessoa C recebeu da pessoa D e pagou a pessoa A. Pior ainda, existe um ciclo vicioso, em que a pessoa D emitiu um cheque de 3 dinheiros para a pessoa C, que por sua vez emitiu um cheque de 2 dinheiros para a pessoa B, que por sua vez emitiu um cheque de 1 dinheiro para a pessoa D. A situação mostrada no item (a) da Figura abaixo é descrita através de uma lista de cheques, com quatro triplas da forma (X,V,Y ), para indicar que X emitiu um cheque de V dinheiros para Y . Na mesma Figura, no item (b), a situação é descrita com uma lista de apenas três cheques.\nA B A B 2 5 1 3 2 1 C D C D 3 (a) (b) Entretanto, as duas listas são equivalentes: o saldo na conta bancária de uma pessoa é o mesmo em ambas as listas de cheques. Em ambos os casos, completada a compensação de todos os cheques, a pessoa A terminará com 5 dinheiros a mais na sua conta, a pessoa B terminará com 1 dinheiro a mais na sua conta, a pessoa C terminará com 4 dinheiros a menos na sua conta e a pessoa D terminará com 2 dinheiros a menos na sua conta.\nVamos então definir equivalência de listas de cheques emitidos: duas listas de cheques são equivalentes se, ao final do processo de compensação de todos os cheques, o seguinte vale para cada pessoa: seu saldo bancário ao final da compensação de uma lista é o mesmo que o saldo bancário da pessoa ao final da compensação da outra lista.\nO total de valores compensados no item (a) da figura é igual a 11 dinheiros ao passo que no item (b) o total é de apenas 6 dinheiros! Este problema tem duas subtarefas: • Subtarefa A: determinar, dada uma lista de cheques, se é possível ou não diminuir o total de valores compensados utilizando uma outra lista de cheques equivalente.\n• Subtarefa B: determinar o total mínimo de valores compensados em uma lista de cheques equivalente.\nVocê deve escrever um programa que resolva apenas a Subtarefa A ou que resolva as duas subtarefas.\nEntrada\nA primeira linha contém dois inteiros, M e N, onde M é o número de cheques emitidos e N é o número de habitantes da cidade. Os habitantes são identificados por números inteiros de 1 a N.\nCada uma das M linhas seguintes descreve um cheque da lista e contém três inteiros X,V e Y , que indica que X emitiu um cheque de V dinheiros a favor de Y . É possível que haja mais de um cheque de X a Y . Também é possivel que haja cheques de X a Y e de Y a X, mas não de X a X.\nSaída\nSeu programa deve produzir duas linhas na saída. A primeira linha descreve a resposta para a Subtarefa A e deve conter um único caractere. O caractere deve ser S para indicar que é possível diminuir o total dos cheques compensados com uma lista de cheques equivalente, ou N para indicar que não é possível diminuir o total de cheques compensados.\nSe o seu programa resolve também a Subtarefa B, a segunda linha descreve a resposta para essa subtarefa e deve conter um número inteiro, o valor mínimo do total de cheques compensados, em uma lista equivalente. Se o seu programa não resolve a Subtarefa B, você pode deixar a linha em branco ou colocar um valor inteiro arbitrário.\nRestrições\n• 1 ≤ M ≤ 106 • 2 ≤ N ≤ 103 • 1 ≤ X ≤ N, 1 ≤ Y ≤ N, X (cid:54)= Y • 1 ≤ V ≤ 102 Informações sobre a pontuação\n• Subtarefa A: 20 pontos.\n• Subtarefa B: em um conjunto de casos de testes que vale 20 pontos 1 ≤ N ≤ 10.",
    "examples": [
      [
        "4 4\n2 1 4\n3 5 1\n3 2 2\n4 3 3",
        "S\n6"
      ],
      [
        "5 4\n4 50 3\n2 25 1\n3 10 2\n2 100 1\n4 50 3",
        "S\n215"
      ],
      [
        "4 4\n3 10 1\n2 40 1\n2 30 4\n2 20 4",
        "N\n100"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "compensacao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Figurinhas da copa",
    "description": "Em ano de Copa do Mundo de Futebol, o álbum de figurinhas oficial é sempre um grande sucesso entre crianças e também entre adultos. Para quem não conhece, o álbum contém espaços numerados de 1 a N para colar as figurinhas; cada figurinha, também numerada de 1 a N, é uma pequena foto de um jogador de uma das seleções que jogará a Copa do Mundo. O objetivo é colar todas as figurinhas nos respectivos espaços no álbum, de modo a completar o álbum (ou seja, não deixar nenhum espaço sem a correspondente figurinha).\nAlgumas figurinhas são carimbadas (efetivamente têm um carimbo impresso sobre a fotografia do jogador) e são mais raras, mais difíceis de conseguir.\nAs figurinhas são vendidas em envelopes fechados, de forma que o comprador não sabe quais figurinhas está comprando, e pode ocorrer de comprar uma figurinha que ele já tenha colado no álbum.\nPara ajudar os usuários, a empresa responsável pela venda do álbum e das figurinhas quer criar um aplicativo que permita gerenciar facilmente as figurinhas que faltam para completar o álbum.\nDados o número total de espaços e figurinhas do álbum (N), a lista das figurinhas carimbadas e uma lista das figurinhas já compradas (que pode conter figurinhas repetidas), sua tarefa é determinar quantas figurinhas carimbadas faltam para completar o álbum.\nEntrada\nA primeira linha contém três números inteiros N, C e M indicando respectivamente o número de figurinhas (e espaços) do álbum, o número de figurinhas carimbadas do álbum e o número de figurinhas já compradas. A segunda linha contém C números inteiros distintos Xi indicando as figurinhas carimbadas do álbum. A terceira linha contém M números inteiros Yi indicando as figurinhas já compradas.\nSaída\nSeu programa deve produzir um inteiro representando o número de figurinhas carimbadas que falta para completar o álbum.\nRestrições\n• 1 ≤ N ≤ 100 • 1 ≤ C ≤ N/2 • 1 ≤ M ≤ 300 • 1 ≤ Xi,Yi ≤ N",
    "examples": [
      [
        "10 2 5\n4 7\n7 1 2 8 3",
        "1"
      ],
      [
        "10 2 6\n4 7\n7 1 8 4 9 3",
        "0"
      ],
      [
        "8 4 10\n2 4 6 8\n3 1 1 5 9 1 7 7 1 1",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "figurinhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Piso da escola",
    "description": "O colégio pretende trocar o piso de uma sala de aula e a diretora aproveitou a oportunidade para passar uma tarefa aos alunos. A sala tem o formato de um retângulo de largura L metros e comprimento C metros, onde L e C são números inteiros. A diretora precisa comprar lajotas de cerâmica para cobrir todo o piso da sala. Seria fácil calcular quantas lajotas seriam necessárias se cada lajota fosse um quadrado de 1 metro de lado. O problema é que a lajota que a diretora quer comprar é um quadrado que possui 1 metro de diagonal, não de lado. Além disso, ela quer preencher o piso da sala com as diagonais das lajotas alinhadas aos lados da sala, como na figura.\nA loja vai fornecer lajotas do tipo 1: in- 5 teiras; do tipo 2, que correspondem à 1 metade das do tipo 1, cortadas ao longo 11 da diagonal; e lajotas do tipo 3, que cor- 3 respondem à metade do tipo 2. Veja os 1 2 3 três tipos de lajotas na figura. tipos de lajotas Está muito claro que sempre serão necessárias 4 lajotas do tipo 3 para os cantos da sala. A tarefa que a diretora passou para os alunos é calcular o número de lajotas dos tipos 1 e 2 que serão necessárias. Na figura, para L = 3 e C = 5, foram necessárias 23 do tipo 1 e 12 do tipo 2.\nSeu programa precisa computar, dados os valores de L e C, a quantidade de lajotas do tipo 1 e do tipo 2 necessárias.\nEntrada\nA primeira linha da entrada contém um inteiro L indicando a largura da sala. A segunda linha contém um inteiro C representando o comprimento da sala.\nSaída\nImprima duas linhas na saída. A primeira deve conter um inteiro, representando o número de lajotas do tipo 1 necessárias. A segunda deve conter um inteiro, indicando o número de lajotas do tipo 2.\nRestrições\n• 1 ≤ L,C ≤ 100",
    "examples": [
      [
        "3\n5",
        "23\n12"
      ],
      [
        "1\n1",
        "1\n0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "piso"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ilhas",
    "description": "Os moradores das Ilhas Brasileiras Ocidentais (IBO) são assíduos jogadores do mais recente jogo online, Magos e Guerreiros. Tão competitivas se tornaram as partidas de Magos e Guerreiros na IBO, que a empresa criadora do jogo decidiu instalar em uma das ilhas um servidor dedicado apenas aos jogadores da IBO.\nEntretanto, a empresa sabe que, se os jogadores acharem que o novo servidor é injusto, eles irão parar de jogar Magos e Guerreiros, gerando incontáveis perdas. Para avaliar se o novo servidor é justo, os jogadores vão comparar o desempenho do jogo na ilha que tem a conexão mais rápida e o desempenho na ilha que tem a conexão mais lenta com o novo servidor. Se a diferença de desempenho for muito grande, os residentes da ilha mais distante se sentirão injustiçados e abandonarão o jogo.\nA conexão de internet da IBO funciona através de um sistema de cabos de fibra ótica. Pares de ilhas são conectados por cabos, e cada cabo toma um certo tempo (chamado de ping) para comunicar informação entre as duas partes. Quando duas ilhas se comunicam através de uma série de cabos (portanto, através de ilhas intermediárias), o ping entre elas é a soma dos pings de cada cabo no caminho. A rede da IBO foi implementada por ótimos programadores e, portanto, um par de ilhas sempre se comunica através do caminho com menor ping possível.\nDada a configuração da rede da IBO e a ilha em que a empresa deseja instalar o novo servidor, determine a diferença entre os pings da ilha com menor e maior pings até o servidor.\nEntrada\nA primeira linha contém N e M, o número de ilhas e o número de cabos de fibra ótica, respectivamente. As ilhas são numeradas de 1 a N. Cada uma das M linhas seguintes contém três inteiros Ui, Vi e Pi e descreve um cabo entre as ilhas Ui e Vi com ping Pi (note que cabos transmitem informação em ambas as direções). Finalmente, a última linha contém um inteiro S, o número da ilha em que o servidor será instalado.\nCada par de ilhas é conectado por no máximo um cabo de fibra ótica, e nenhum cabo conecta uma ilha a si mesma. É garantido que qualquer ilha consegue se comunicar com qualquer outra através de algum caminho de cabos de fibra ótica.\nSaída\nSeu programa deve produzir um inteiro representando a diferença entre o ping da ilha com maior ping até o servidor, e o da ilha com menor ping até o servidor. Note que a ilha em que o servidor se encontra não é considerada no cálculo do menor ping.\nRestrições\n• 2 ≤ N ≤ 1000 • N − 1 ≤ M ≤ 105 • 1 ≤ Ui ≤ N • 1 ≤ Vi ≤ N • 1 ≤ S ≤ N • 1 ≤ Pi ≤ 1000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 30 pontos, 2 ≤ N ≤ 100 e N − 1 ≤ M ≤ 1000.",
    "examples": [
      [
        "4 5\n2 1 5\n1 3 4\n2 3 6\n4 2 8\n3 4 12\n1",
        "9"
      ],
      [
        "6 11\n1 2 3\n6 1 9\n2 6 10\n2 3 8\n5 3 3\n4 3 2\n2 4 12\n6 4 1\n4 5 9\n1 5 16\n5 6 5\n5",
        "11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "ilhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cápsulas",
    "description": "O discípulo Fan Chi’ih retornou recentemente da China com algumas cápsulas mágicas, que são capazes de produzir moedas de ouro! Uma cápsula possui um certo ciclo de produção, que é um número C de dias. A cada C dias a cápsula produz uma nova moeda; a moeda é sempre produzida no último dia do ciclo. Fan Chi’ih vai ativar todas as cápsulas ao mesmo tempo e quer acumular uma fortuna de pelo menos F moedas. Ele precisa da sua ajuda para computar o número mínimo de dias para que as cápsulas produzam, no total, pelo menos F moedas. Na tabela abaixo, por exemplo, existem três cápsulas com ciclos de 3, 7 e 2 dias. Se Fan Chi’ih quiser acumular pelo menos 12 moedas, ele vai ter que esperar pelo menos 14 dias.\n  Entrada\nA primeira linha da entrada contém dois inteiros N e F, indicando o número de cápsulas e o número de moedas que Fan Chi’ih quer produzir, respectivamente. A segunda linha contém N inteiros Ci, para 1 ≤ i ≤ N, representando os ciclos de cada cápsula.\nSaída\nImprima um inteiro, representando o número mínimo de dias para que as cápsulas produzam, no total, pelo menos F moedas.\nRestrições\n• 1 ≤ N ≤ 105; 1 ≤ F ≤ 109 • 1 ≤ Ci ≤ 106 • Em todos os casos de teste, a resposta é sempre menor ou igual a 108 dias; • Em todos os casos de teste, o número de moedas produzido, no total, após 108 dias, é sempre menor ou igual a 109.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, os ciclos Ci são todos iguais (ou seja Ci = Cj para todo 1 ≤ i ≤ N e 1 ≤ j ≤ N).\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 103, F ≤ 103 e Ci ≤ 103",
    "examples": [
      [
        "3 12\n3 7 2",
        "14"
      ],
      [
        "10 100\n17 13 20 10 12 16 10 13 13 10",
        "130"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "capsulas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Copa",
    "description": "O sorteio das posições dos jogadores na chave decisiva da copa do mundo de ping-pong está deixando a todos nervosos. É que ninguém quer pegar o jogador mais bem ranqueado, o Mestre Kung, logo nas oitavas de final, ou nas quartas de final. Melhor que só seja possível enfrentar Mestre Kung na semifinal ou na final! A chave possui 16 posições numeradas de 1 a 16, como na figura abaixo. A organização da copa vai fazer um sorteio para definir em qual posição cada jogador vai iniciar a chave decisiva. Nas oitavas de final, o jogador na posição 1 enfrenta o jogador na posição 2; o da posição 3 enfrenta o da posição 4; e assim por diante, como na figura.\nfinal semifinal quartas oitavas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 posições na chave O objetivo deste problema é, dadas as posições de Mestre Kung e Mestre Lu na chave, decidir em que fase da competição Mestre Kung e Mestre Lu vão se enfrentar, caso vençam todas as suas respectivas partidas antes de se enfrentarem. Por exemplo, se o sorteio da chave determinar que Mestre Kung ocupará a posição 1 e Mestre Lu a posição 2 da chave, eles se encontrarão nas oitavas de final; se Mestre Kung ocupar a posição 6 e Mestre Kung ocupar a posição 9 da chave, eles se encontrarão somente na final.\nEntrada\nA entrada consiste de duas linhas. A primeira linha da entrada contém um inteiro K que indica a posição de Mestre Kung na chave. A segunda linha da entrada contém um inteiro L que indica a posição de Mestre Lu na chave.\nSaída\nSeu programa deve produzir uma linha contendo uma das palavras seguintes, decidindo a fase em que vão se enfrentar os jogadores Mestre Kung e Mestre Lu, se eles chegarem a se enfrentar: oitavas, quartas, semifinal ou final.\nRestrições\n• 1 ≤ K ≤ 16 • 1 ≤ L ≤ 16 • K (cid:54)= L Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 30 pontos, K = 1.",
    "examples": [
      [
        "10\n14",
        "semifinal"
      ],
      [
        "7\n8",
        "oitavas"
      ],
      [
        "3\n13",
        "final"
      ],
      [
        "5\n8",
        "quartas"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "copa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pesos",
    "description": "Uma fábrica instalou um elevador composto de duas cabines ligadas por uma roldana, como na figura. Quando uma cabine sobe, a outra desce. No primeiro andar da fábrica existem algumas caixas de pesos diversos e precisamos levar todas as caixas para o segundo andar, usando o elevador. Apenas uma caixa pode ser colocada por vez dentro de uma cabine. Além disso, existe uma restrição de segurança importante: durante uma viagem do elevador, a diferença de peso entre as cabines pode ser no máximo de 8 unidades. De forma mais rigorosa, P − Q ≤ 8, onde P é o peso da cabine mais pesada e Q, o peso da cabine mais leve. O gerente da fábrica não está preocupado com o número de viagens que o elevador vai fazer.\nEle apenas precisa saber se é possível ou não levar todas as caixas para o segundo andar. No exemplo da figura, podemos levar todas as 15 4 10 três caixas usando a seguinte sequência de seis viagens do elevador: 1. Sobe a caixa de peso 4, desce a outra cabine vazia; (diferença de 4) 2. Sobe a caixa de peso 10, desce a caixa de peso 4; (diferença de 6) 3. Sobe a caixa de peso 15, desce a caixa de peso 10; (diferença de 5) 4. Sobe a caixa de peso 4, desce a outra cabine vazia; (diferença de 4) 5. Sobe a caixa de peso 10, desce a caixa de peso 4; (diferença de 6) 6. Sobe a caixa de peso 4, desce a outra cabine vazia. (diferença de 4) Dados os pesos de N caixas no primeiro andar, em ordem crescente, seu programa deve determinar se é possível ou não levar todas as N caixas para o segundo andar.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de caixas. A segunda linha da entrada contém N inteiros representando os pesos das caixas, em ordem crescente.\nSaída\nImprima uma linha na saída. A linha deve conter o caracter S caso seja possível, ou N caso não seja possível levar todas as caixas até o segundo andar da fábrica.\nRestrições\n• 1 ≤ N ≤ 104 • O peso das caixas está entre 1 e 105, inclusive.",
    "examples": [
      [
        "3\n4 10 15",
        "S"
      ],
      [
        "8\n2 6 15 20 25 35 35 40",
        "N"
      ],
      [
        "4\n10 14 20 23",
        "N"
      ],
      [
        "1\n8",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pesos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Campeonato",
    "description": "O sorteio das posições dos jogadores na chave decisiva da copa do mundo de ping-pong está deixando a todos nervosos. É que ninguém quer pegar o jogador mais bem ranqueado, o Master Kung, logo nas oitavas de final, ou nas quartas de final. Melhor que só seja possível enfrentar Master Kung na semifinal ou na final! Os jogadores são identificados por números inteiros de 1 a 16, sendo que Master Kung é o jogador de número 1. O jogador para o qual nós estamos torcendo, Master Lu, tem o número 9.\nA chave possui 16 posições também numeradas de 1 a 16, como na figura abaixo. A organização da copa vai fazer um sorteio para definir em qual posição cada jogador vai iniciar a chave decisiva.\nNas oitavas de final, o jogador na posição 1 enfrenta o jogador na posição 2; o da posição 3 enfrenta o da posição 4; e assim por diante, como na figura.\nfinal semifinal quartas oitavas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 posições na chave O objetivo deste problema é decidir em que fase da chave os jogadores Master Kung e Master Lu vão se enfrentar, caso vençam todas as suas respectivas partidas antes de se enfrentarem. Por exemplo, se o sorteio da chave determinar a seguinte ordem de jogadores da posição 1 até a 16: [4, 11, 3, 2, 8, 13, 14, 5, 16, 9, 12, 6, 10, 7, 1, 15], eles vão se enfrentar na semifinal.\nEntrada\nA primeira e única linha da entrada contém 16 números Xi inteiros distintos, de valores entre 1 e 16. Ou seja, uma permutação dos inteiros entre 1 e 16. A permutação define a ordem dos jogadores nas posições da chave decisiva da copa.\nSaída\nSeu programa deve produzir uma única linha contendo uma das palavras seguintes, decidindo a fase em que vão se enfrentar os jogadores Master Kung e Master Lu, se eles vencerem todas as suas partidas antes de se enfrentarem: oitavas, quartas, semifinal ou final.\nRestrições\n• 1 ≤ Xi ≤ 16 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, Master Kung (o jogador 1) está na posição 1 da chave.",
    "examples": [
      [
        "4 11 3 2 8 13 14 5 16 9 12 6 10 7 1 15",
        "semifinal"
      ],
      [
        "4 11 8 13 14 5 1 9 16 2 12 6 3 7 10 15",
        "oitavas"
      ],
      [
        "4 11 1 13 14 5 3 8 16 2 12 6 9 7 10 15",
        "final"
      ],
      [
        "4 11 8 13 9 5 3 1 16 2 12 6 7 14 10 15",
        "quartas"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "campeonato"
    },
    "imagesQuant": 0
  },
  {
    "name": "Relógios",
    "description": "É poc ro dm iao . s Qe ud ei rz d: im zee rs ,m seo uu mm rer le ól gó ig oio esp táar pa ad ro ade ost cá oc mer st eo usdu pa os ntv ee iz roes s 5 0 1 5 0 1 marcando, digamos, 7:32, e você olhar para ele exatamente às 4 3 2 4 3 2 7:32 da manhã, ou da noite, o relógio vai lhe mostrar a hora 5 0 1 5 0 1 5 0 1 c c jehe ir e tt g oa a n! r eO nao hc uo s me el uh , o mdb e asr sta i dn n ec oo jeoe its m otá a na i est nr r ha á us pa mid do mo, epm so mu si s ot ío ,v pea l at ,r sma sas aa rsd po n o. rãoE uml pe op rd er ee ló,c gi ds ioa e 54 3 0 2 1 4 3 2 5 0 1 4 3 2 que não esteja lhe mostrando a hora certa. 4 3 2 4 3 2 O coelho branco está na sala do canto superior esquerdo de um palácio que é um quadriculado de salas iguais, cada uma delas contendo um relógio cujo marcador está dividido em K unidades de tempo, de 0 a K − 1, e que possuem apenas um ponteiro. Alguns relógios estão parados, enquanto os demais funcionam perfeitamente sincronizados. O coelho precisa chegar na sala do canto inferior direito, pode se mover ortogonalmente apenas e leva exatamente uma unidade de tempo para ir de uma sala para outra. Ele pode ficar esperando parado, por uma quantidade inteira de unidades de tempo, numa sala cujo relógio esteja funcionando. Mas ele não pode entrar, nem ficar esperando parado, em uma sala cujo relógio lhe esteja mostrando a hora errada! No exemplo da figura, K = 6 e os relógios mostrados estão parados. Nas salas onde a figura não mostra o relógio, é porque ele está funcionando. Você consegue ver que, para esse exemplo, o tempo mínimo para o coelho branco chegar na sala inferior direita é 8 unidades de tempo? Seu programa precisa computar a quantidade mínima de unidades de tempo para o coelho branco chegar ao destino, se for possível chegar ao destino! Entrada\nA primeira linha da entrada contém três inteiros L, C e K, indicando, respectivamente, o número de linhas, o número de colunas e a quantidade de unidades de tempo na qual o marcador dos relógios está dividido. As L linhas seguintes contêm, cada uma, C inteiros P, representando o estado dos relógios em cada sala: P = −1, se o relógio estiver funcionando corretamente; e 0 ≤ P ≤ K − 1, se estiver parado com o ponteiro na posição P. O relógio na sala inicial, primeira linha e primeira coluna, está sempre parado na posição 0.\nSaída\nImprima um inteiro, representando a quantidade mínima de unidades de tempo para o coelho branco chegar ao destino. Se não for possível, imprima −1.\nRestrições\n• 2 ≤ L,C ≤ 100 • 2 ≤ K ≤ 105 • −1 ≤ P ≤ K − 1 Informações sobre a pontuação\n• Para um conjunto de casos de teste valendo 25 pontos, L ≤ 20, C ≤ 20 e K ≤ 10;",
    "examples": [
      [
        "3 4 6\n0 -1 3 -1\n4 1 -1 1\n4 -1 2 -1",
        "8"
      ],
      [
        "5 4 10\n0 -1 -1 -1\n-1 9 9 9\n4 9 -1 8\n-1 -1 9 7\n-1 7 9 -1",
        "-1"
      ],
      [
        "5 4 10\n0 -1 -1 -1\n-1 9 9 9\n4 9 -1 8\n-1 2 9 9\n-1 7 9 -1",
        "20"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "relogios"
    },
    "imagesQuant": 0
  },
  {
    "name": "Elevador",
    "description": "Uma fábrica instalou um elevador composto de duas cabines ligadas por uma roldana, como na figura. Quando uma cabine sobe, a outra desce. No primeiro andar da fábrica existem algumas caixas de pesos diversos e precisamos levar todas as caixas para o segundo andar, usando o elevador. Apenas uma caixa pode ser colocada por vez dentro de uma cabine. Além disso, existe uma restrição de segurança importante: durante uma viagem do elevador, a diferença de peso entre as cabines pode ser no máximo de 8 unidades. De forma mais rigorosa, P − Q ≤ 8, onde P é o peso da cabine mais pesada e Q, o peso da cabine mais leve. O gerente da fábrica não está preocupado com o número de viagens que o elevador vai fazer.\nEle apenas precisa saber se é possível ou não levar todas as caixas para o segundo andar. No exemplo da figura, podemos levar todas as 15 4 10 três caixas usando a seguinte sequência de seis viagens do elevador: 1. Sobe a caixa de peso 4, desce a outra cabine vazia; (diferença de 4) 2. Sobe a caixa de peso 10, desce a caixa de peso 4; (diferença de 6) 3. Sobe a caixa de peso 15, desce a caixa de peso 10; (diferença de 5) 4. Sobe a caixa de peso 4, desce a outra cabine vazia; (diferença de 4) 5. Sobe a caixa de peso 10, desce a caixa de peso 4; (diferença de 6) 6. Sobe a caixa de peso 4, desce a outra cabine vazia. (diferença de 4) Dados os pesos de N caixas no primeiro andar, seu programa deve dizer se é possível ou não levar todas as N caixas para o segundo andar.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de caixas. A segunda linha da entrada contém N inteiros representando os pesos das caixas.\nSaída\nImprima uma linha na saída. A linha deve conter o caracter S caso seja possível, ou N caso não seja possível levar todas as caixas até o segundo andar da fábrica.\nRestrições\n• 1 ≤ N ≤ 104 • O peso das caixas está entre 1 e 105, inclusive.",
    "examples": [
      [
        "3\n15 4 10",
        "S"
      ],
      [
        "8\n25 2 6 15 40 35 35 20",
        "N"
      ],
      [
        "4\n14 10 23 20",
        "N"
      ],
      [
        "1\n8",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "elevador"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fuga",
    "description": "Os irmãos Violet e Klaus estão fugindo pelas suas vidas do Conde Olaf, que corre atrás deles dentro de um prédio abandonado. Violet e Klaus acabam de entrar em uma sala retangular de largura N e comprimento M, dividida em N · M células (i,j) de área 1 (1 ≤ i ≤ N e 1 ≤ j ≤ M). Em algumas células dessa sala, existem armários. Toda célula (i,j) onde i e j são pares contém um armário.\nA sala tem uma entrada na célula (Xe,Ye) e uma saída na célula (Xs,Ys), que ficam em posições diferentes nas bordas da sala. A entrada e a saída nunca são adjacentes a um armário.\nA figura a seguir mostra a uma possível configuração da sala, onde N = M = 7, a entrada fica na posição (3,7) (marcada com uma estrela) e a saída fica na posição (5,1) (marcada com um círculo).\nOs armários estão indicados em quadrados cinzas.\n  Para atrasar Conde Olaf, que os está perseguindo e entrará na sala em alguns momentos, os irmãos decidiram derrubar armários da sala, de forma a aumentar o tamanho do percurso necessário para ir da entrada até a saída. As células ocupadas por armários caídos ou em pé não podem ser percorridas.\nUm armário pode ser derrubado em qualquer uma das direções paralelas aos lados da sala e ocupa duas células após cair. Ou seja, um armário na posição (i,j) da sala, ao cair irá ocupar uma das seguintes opções: • As células (i,j) e (i,j + 1); • As células (i,j) e (i,j − 1); • As células (i,j) e (i + 1,j); ou • As células (i,j) e (i − 1,j).\nDadas as dimensões da sala e as posições de entrada e de saída, você deve encontrar uma forma de derrubar os armários tal que a distância entre a entrada e a saída da sala seja a maior possível dentre todas as formas de derrubar os armários.\nPara o exemplo acima, a figura abaixo é uma solução possível. Os retângulos cinzas representam os armários derrubados e a linha representa o caminho entre a entrada e a saída (que passa por 29 células). Nesse caso, não é possível derrubar os armários de forma que a distância entre a entrada e a saída seja maior que 29.\nEntrada\nA primeira linha contém dois inteiros N e M, a largura e o comprimento da sala, respectivamente.\nA segunda linha contém dois inteiros Xe e Ye, identificando a célula de entrada da sala (Xe,Ye). A terceira linha contém dois inteiros Xs e Ys, identificando a célula de saída da sala (Xs,Ys).\nSaída\nSeu programa deve produzir um inteiro representando o tamanho do menor caminho (em número de células) da entrada até a saída da sala após derrubar os armários de forma ótima.\n  Restrições\n• 3 ≤ N,M ≤ 11 • 3 ≤ Xe,Xs ≤ N • 3 ≤ Ye,Ys ≤ M • N,M,Xe,Xs,Ye,Ys são ímpares.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 40 pontos, 1 ≤ N,M ≤ 7.",
    "examples": [
      [
        "7 7\n3 7\n5 1",
        "29"
      ],
      [
        "11 11\n11 1\n1 11",
        "69"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fuga"
    },
    "imagesQuant": 2
  },
  {
    "name": "Wifi",
    "description": "A arquitetura do novo museu de ciências é bastante peculiar. O prédio do museu é uma grande sala retangular. Dentro dessa sala existem outras salas retangulares, e dentro delas existem outras salas retangulares, e assim recursivamente, como se fossem caixas dentro de caixas... As paredes das salas não se tocam. Veja um exemplo na parte esquerda da figura, com oito salas.\nO diretor quer instalar uma rede wifi que funcione em todo o museu. Para economizar, ele quer comprar o número mínimo possível de antenas. O problema é que, pela forma como foram construídas as paredes das salas, ocorre uma coisa interessante: o sinal wifi é capaz de atravessar as paredes quando vem de dentro para fora, mas estranhamente não atravessa as paredes quando vem de fora para dentro das salas! A figura mostra duas posições possíveis para uma antena, mostrada como um círculo, e a área que o respectivo sinal wifi da antena alcançaria.\nNeste problema, dados N retângulos cujos lados são paralelos aos eixos cartesianos, que descrevem as salas do museu, seu programa deve computar o número mínimo possível de antenas que o diretor deve comprar para que a rede wifi funcione em todo o museu.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de salas. Cada uma das N linhas seguintes contém quatro inteiros, X1,Y1,X2 e Y2, definindo as coordenadas do canto superior esquerdo (X1,Y1) e inferior direito (X2,Y2) de uma sala. Não há nenhum tipo de interseção entre os retângulos que definem as salas. Um dos retângulos contém todos os demais e representa a sala mais externa (as paredes externas do prédio do museu).\nSaída\nImprima um inteiro, representando o número mínimo possível de antenas de wifi para que a rede funcione em todo o museu.\nRestrições\n• 1 ≤ N ≤ 105 • −109 ≤ X1,Y1,X2,Y2 ≤ 109; X1 < X2 e Y2 < Y1 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ N ≤ 104.",
    "examples": [
      [
        "4\n5 19 8 17\n5 15 15 5\n0 20 20 0\n8 10 10 8",
        "2"
      ],
      [
        "1\n-10000000 10000000 10000000 -10000000",
        "1"
      ],
      [
        "7\n50 80 90 75\n45 30 50 20\n5 98 6 97\n0 100 100 0\n20 60 98 5\n25 50 70 10\n30 45 65 15",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "wifi"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sequência",
    "description": "O professor da importante disciplina de Indução Matemática está tentando resolver uma versão generalizada de um problema muito tradicional: encontrar o valor máximo possível para a soma dos elementos de uma subsequência contígua de uma sequência de números inteiros quaisquer. Mais rigorosamente, dado uma sequência S = [s1,s2,...,sN], onde si é um número inteiro qualquer, para 1 ≤ i ≤ N, maximizar soma(i,j) = si + si+1 + ··· + sj entre todos os possíveis pares (i,j), onde 1 ≤ i ≤ j ≤ N.\nNa versão do professor, entretanto, alguns elementos da sequência são especiais e estão marcados.\nAlém da sequência marcada, são dadas como entrada duas cotas: L e H, com L ≤ H. O objetivo agora é encontrar o valor máximo possível para a soma dos elementos de uma subsequência contígua, que contenha pelo menos L e no máximo H elementos marcados.\nPor definição, uma subsequência vazia (de zero elementos) tem soma igual a zero. Mas note que, como podemos ter uma cota inferior para o número de elementos marcados, a subsequência contígua de soma máxima pode ter soma negativa! Entrada\nA primeira linha da entrada contém três inteiros N, L e H, indicando respectivamente o número de elementos na sequência, a cota inferior L e a cota superior H. A segunda linha contém N inteiros si, para 1 ≤ i ≤ N, definindo os elementos da sequência. A terceira linha contém N inteiros mi, para 1 ≤ i ≤ N, indicando as marcas. Se o i-ésimo elemento está marcado, o valor é mi = 1. Se não estiver marcado, mi = 0.\nSaída\nImprima um inteiro, representando o valor máximo possível para a soma dos elementos de uma subsequência contígua, que contenha pelo menos L e no máximo H elementos marcados.\nRestrições\n• 1 ≤ N ≤ 105 • 0 ≤ L ≤ H ≤ 20 • −103 ≤ si ≤ 103, para 1 ≤ i ≤ N • O número de elementos marcados na sequência é maior ou igual a L; portanto sempre existe solução.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 15 pontos, N ≤ 102 • Para um conjunto de casos de testes valendo 30 pontos, N ≤ 104",
    "examples": [
      [
        "14 3 4\n9 0 -23 -12 7 1 -13 2 -1 9 -16 -1 14 12\n1 0 0 1 0 1 0 0 1 1 0 0 1 1",
        "19"
      ],
      [
        "14 7 20\n9 0 -23 -12 7 1 -13 2 -1 9 -16 -1 14 12\n1 0 0 1 0 1 0 0 1 1 0 0 1 1",
        "-12"
      ],
      [
        "14 5 5\n9 0 -23 -12 7 1 -13 2 -1 9 -16 -1 14 12\n1 0 0 1 0 1 0 0 1 1 0 0 1 1",
        "14"
      ],
      [
        "14 0 20\n9 0 -23 -12 7 1 -13 2 -1 9 -16 -1 14 12\n1 0 0 1 0 1 0 0 1 1 0 0 1 1",
        "26"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 2,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sequencia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Batalha",
    "description": "Todo mundo está jogando um novo game de realidade aumentada no celular, com batalhas entre monstrinhos! Nas primeiras fases do jogo as batalhas são bem simples, mas ainda assim bastante divertidas. Dois jogadores vão escolher um monstrinho cada, na sua coleção de monstrinhos. Cada monstrinho tem um tipo de ataque e um tipo de defesa, que são identificados por números naturais.\nA regra da batalha, que consiste em cada monstrinho usar seu respectivo ataque ao mesmo tempo, é que se o número da defesa de um monstrinho é igual ao número do ataque do seu oponente, então ele não sofre nenhum dano; caso contrário, se o número da defesa dele é diferente do ataque do oponente, então ele sofre dano total e desmaia! Por exemplo, o monstrinho do primeiro jogador tem o ataque 21 e a defesa 7; enquanto que o monstrinho do segundo jogador tem o ataque 7 e a defesa 12. Nesse caso, o primeiro jogador vence, pois não desmaiou, enquanto que o segundo jogador desmaiou.\nAssim, o resultado da batalha, que seu programa deve determinar, pode ser: • Jogador 1 vence: se o jogador 1 não desmaia e o jogador 2 desmaia; • Jogador 2 vence: se o jogador 2 não desmaia e o jogador 1 desmaia; • Empate: em qualquer caso contrário; quer dizer, os dois desmaiam, ou nenhum desmaia.\nEntrada\nA primeira linha da entrada contém um inteiro A1 indicando o ataque do primeiro jogador. A segunda linha contém um inteiro D1 indicando a defesa do primeiro jogador. A terceira linha contém um inteiro A2 representando o ataque do segundo jogador. A quarta, e última linha, contém um inteiro D2 representando a defesa do segundo jogador.\nSaída\nImprima uma linha contendo um inteiro, 1 ou 2, indicando qual jogador ganhou a batalha. Se a batalha resultou em empate, imprima −1.\nRestrições\n• 1 ≤ A1 ≤ 100 • 1 ≤ D1 ≤ 100 • 1 ≤ A2 ≤ 100 • 1 ≤ D2 ≤ 100",
    "examples": [
      [
        "21\n7\n7\n12",
        "1"
      ],
      [
        "2\n5\n71\n18",
        "-1"
      ],
      [
        "14\n8\n8\n14",
        "-1"
      ],
      [
        "1\n19\n32\n1",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "batalha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pulo do Gato",
    "description": "O gato Obinho gosta de brincar no pátio do colégio, no qual há uma sequência de C lajotas, que podem ser brancas ou pretas. Obinho está na lajota inicial da sequência (a mais à esquerda), e quer ir pulando até a lajota final da sequência (a mais à direita). Mas ele só gosta de pular de uma lajota preta para outra lajota preta, nunca pisando numa lajota branca. Além disso, ele não consegue pular muito longe. A parte esquerda da figura mostra as lajotas que o Obinho pode alcançar com um pulo: uma distância máxima de duas lajotas.\nObinho quer chegar na lajota final com o número mínimo de pulos possível. Por exemplo, na parte direita da figura, para C = 14, o menor número de pulos possível é 8. Seu programa deve computar o número mínimo de pulos para o Obinho chegar na lajota final.\nEntrada\nA primeira linha da entrada contém um inteiro C, representando o número de lajotas do pátio. A segunda linha contém C inteiros indicando a cor das lajotas, da inicial (mais à esquerda) à final (mais à direita): o valor 1 indica uma lajota preta, o valor 0 indica uma lajota branca.\nSaída\nImprima uma linha contendo o número mínimo de pulos que o gato Obinho precisa dar para ir da lajota inicial até a lajota final. Se não for possível pular até a lajota final, imprima −1.\nRestrições\n• 1 ≤ C ≤ 104; • As lajotas inicial e final são sempre pretas.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 10 pontos, todas as lajotas são pretas; • Para um conjunto de casos de teste valendo 20 pontos, C ≤ 1000.",
    "examples": [
      [
        "14\n1 1 0 1 1 1 0 1 1 0 1 0 1 1",
        "8"
      ],
      [
        "14\n1 0 0 1 1 1 0 0 1 0 1 1 0 1",
        "-1"
      ],
      [
        "12\n1 1 1 1 1 1 1 1 1 1 1 1",
        "6"
      ],
      [
        "9\n1 0 1 1 0 1 1 0 1",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pulo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Troca",
    "description": "Um cientista especializado em bioinformática está estudando formas de simular alguns fenômenos, que ocorrem dentro das células, relacionados ao funcionamento de proteínas. Parece muito complicado, não? Só que o problema computacional básico que ele precisa resolver eficientemente é fácil de entender. Existe uma sequência de N cartas, indexadas de 1 a N, e cada carta contém dois números impressos, um de cada lado. As cartas são colocadas na mesa, na sequência, com um dos lados virado para cima. Dados dois inteiros i e j, com i ≤ j, a operação troca(i,j) consiste em virar todas as cartas da posição i até a posição j, inclusive. Por exemplo, considere a sequência de cartas abaixo.\n  A operação de troca(5,11) resultaria na seguinte sequência de cartas:   O problema do cientista é que a sequência de cartas pode ser muito grande e podem ser feitas muitas operações de troca. Ele precisa saber a sequência dos números que estarão virados para cima ao final de todas as operações. Você pode ajudá-lo? Entrada\nA primeira linha da entrada contém dois inteiros N e T, indicando respectivamente a quantidade de cartas e a quantidade de operações de troca. A segunda linha contém N inteiros, indicando os números virados para cima inicialmente. A terceira linha contém N números, indicando os virados para baixo inicialmente. As T linhas seguintes contém, cada uma, dois inteiros I e J, indicando os limites de uma operação de troca.\nSaída\nImprima uma linha contendo N inteiros representando os números que estarão virados para cima após todas as operações.\nRestrições\n• 1 ≤ N ≤ 105 • 1 ≤ T ≤ 105 • 1 ≤ I ≤ J ≤ N • O valor dos elementos dos vetores está entre 0 e 109, inclusive.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 10 pontos, I = J para todas as operações; • Para um conjunto de casos de teste valendo 20 pontos, N ≤ 104 e T ≤ 104.",
    "examples": [
      [
        "16 1\n31 2 45 3 8 1 32 10 4 27 12 7 7 9 63 47\n1 12 6 4 97 2 87 10 3 9 55 56 11 90 3 8\n5 11",
        "31 2 45 3 97 2 87 10 3 9 55 7 7 9 63 47"
      ],
      [
        "10 5\n7 88 23 44 1 67 73 2 9 11\n4 55 1 1 3 74 82 9 8 37\n1 3\n5 10\n2 6\n5 9\n1 7",
        "7 55 1 44 1 67 82 2 9 37"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "troca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pulo do Gato",
    "description": "O gato Obinho gosta de brincar no pátio do colégio, que tem a forma de um quadriculado de L linhas por C colunas de lajotas, que podem ser brancas ou pretas. Obinho está na lajota inicial, na linha 1, coluna 1 (canto superior esquerdo), e quer ir pulando até a lajota final, na linha L, coluna C (canto inferior direito). Mas ele só gosta de pular de uma lajota preta para outra lajota preta, nunca pisando numa lajota branca. Além disso, ele não consegue pular muito longe. A parte esquerda da figura mostra as lajotas que o Obinho pode alcançar com um pulo: qualquer lajota dentro do quadrado de 5 × 5 lajotas centrado na posição atual dele.\nObinho quer chegar na lajota final com o número mínimo de pulos possível. Por exemplo, na parte direita da figura, para L = 10 e C = 14, o menor número de pulos possível é 11. Seu programa deve computar o número mínimo de pulos para o Obinho chegar na lajota final! Entrada\nA primeira linha da entrada contém dois inteiros L e C, representando o número de linhas e colunas do pátio. As L linhas seguintes contêm, cada uma, C inteiros indicando a cor das lajotas: 1 para preta; 0 para branca.\nSaída\nImprima uma linha contendo o número mínimo de pulos que o gato Obinho precisa dar para ir da lajota inicial até a lajota final. Se não for possível pular até a lajota final, imprima −1.\nRestrições\n• 1 ≤ L,C ≤ 500; • As lajotas inicial e final são sempre pretas.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 10 pontos, L = 1 e todas as lajotas são pretas; • Para um conjunto de casos de teste valendo 10 pontos, L = 1; • Para um conjunto de casos de teste valendo 10 pontos, L > 1, C > 1 e todas as lajotas são pretas; • Para um conjunto de casos de teste valendo 20 pontos, L ≤ 100 e C ≤ 100.",
    "examples": [
      [
        "10 14\n1 0 0 0 1 1 0 0 1 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 0 1 0 1 0\n0 0 0 0 0 0 1 0 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 1 0 0 0 0\n1 0 0 0 1 0 0 0 0 0 0 0 0 0\n1 1 0 0 0 0 0 0 0 0 0 0 0 1\n0 0 0 0 1 0 0 0 1 0 1 0 1 1\n0 0 1 0 0 1 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 0 1 0\n1 0 0 0 0 0 0 1 0 0 0 0 0 1",
        "11"
      ],
      [
        "10 14\n1 0 0 0 1 1 0 0 1 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 0 1 0 1 0\n0 0 0 0 0 0 1 0 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 1 0 0 0 0\n1 0 0 0 1 0 0 0 0 0 0 0 0 0\n1 1 0 0 0 0 0 0 0 0 0 0 0 1\n0 0 0 0 1 0 0 0 0 0 1 0 1 1\n0 0 1 0 0 1 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 0 1 0\n1 0 0 0 0 0 0 1 0 0 0 0 0 1",
        "-1"
      ],
      [
        "1 12\n1 1 1 1 1 1 1 1 1 1 1 1",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "gato"
    },
    "imagesQuant": 0
  },
  {
    "name": "Recibo de Compra",
    "description": "Flavinho acabou de chegar do supermercado com K produtos na sacola, mas perdeu o recibo da compra. Ele está tentando lembrar dos preços de cada um dos produtos e precisa da sua ajuda.\nPor enquanto ele consegue se lembrar das seguintes informações: • O valor total da compra foi de R reais; • Os valores dos produtos eram números inteiros distintos.\nPor exemplo, se R = 12 e K = 3, temos as seguintes possíveis combinações de preços para os três produtos: {1,2,9}, {1,3,8}, {1,4,7}, {1,5,6}, {2,3,7}, {2,4,6} ou {3,4,5}.\nSeu programa deve computar a quantidade de possíveis combinações de preços para os K produtos.\nEntrada\nA primeira linha da entrada contém dois inteiros R e K, indicando respectivamente o valor total do recibo e o número de produtos comprados.\nSaída\nImprima uma linha contendo um inteiro representando a quantidade de possíveis combinações de preços para os K produtos.\nRestrições\n• 1 ≤ R ≤ 100 • 1 ≤ K ≤ 20 Informações sobre a pontuação\n• Para um conjunto de casos de teste valendo 10 pontos, R ≤ 6 • Para um conjunto de casos de teste valendo 20 pontos, R ≤ 16",
    "examples": [
      [
        "12 3",
        "7"
      ],
      [
        "10 5",
        "0"
      ],
      [
        "100 8",
        "116263"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "recibo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Baldes",
    "description": "Temos uma sequência de N baldes, identificados de 1 até N, cada balde contendo inicialmente uma bola de peso inteiro positivo. Queremos realizar uma sequência de M operações de dois tipos possíveis: 1. Adicionar uma bola de peso p ao balde i; 2. Dados a e b, com 1 ≤ a < b ≤ N, imprimir a maior diferença absoluta possível entre o peso de duas bolas, de baldes distintos, dentro do intervalo de baldes [a,b].\nPor exemplo, na figura abaixo, para N = 6, o resultado da operação do tipo 2 para o intervalo [2,5] é 11, correspondente às bolas 4 e 15, dos baldes 2 e 3 respectivamente. Existe uma diferença absoluta maior para as bolas 15 e 2, mas elas estão no mesmo balde, portanto, essa diferença não conta.\n6 9 4 2 8 9 3 10 15 9 7 101 1 2 3 4 5 6 [2,5] Entrada\nA primeira linha da entrada contém dois inteiros, N e M, respectivamente, o número de baldes e o número de operações. A segunda linha da entrada contém N inteiros indicando o peso da bola contida em cada balde inicialmente. As M linhas seguintes descrevem, cada uma, uma operação. Se a operação é do primeiro tipo, a linha contém o número 1 seguido de dois inteiros, P e I, indicando o peso da bola a ser adicionada e o identificador do balde. Se a operação é do segundo tipo, a linha contém o número 2 seguido de dois inteiros, A e B, representando o intervalo [A,B] de baldes.\nSaída\nPara cada operação do segundo tipo, imprima uma linha contendo a maior diferença absoluta possível entre o peso de duas bolas, de baldes distintos, dentro do intervalo em questão.\nRestrições\n• 2 ≤ N ≤ 105; • 1 ≤ M ≤ 105; • 1 ≤ A < B ≤ N; • O peso das bolas está entre 1 e 106; • A entrada contém pelo menos uma operação do segundo tipo.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 10 pontos, N ≤ 100 e M ≤ 100; • Para um conjunto de casos de teste valendo 40 pontos, N ≤ 104 e M ≤ 104.",
    "examples": [
      [
        "10 5\n3 9 12 4 20 5 7 15 9 10\n1 1 5\n1 33 8\n2 6 9\n1 15 2\n2 1 7",
        "28\n17"
      ],
      [
        "2 3\n100 200\n2 1 2\n1 55 1\n2 1 2",
        "100\n145"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "baldes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bolas",
    "description": "Temos oito bolas, colocadas lado a lado em uma sequência. Cada bola tem um número impresso, que pode ter valor de 0 até 9. Queremos trocar algumas 3 7 3 3 5 5 5 9 bolas de posição na sequência de modo que nenhum par de bolas vizinhas na sequência tenha o mesmo número. Quer dizer, não pode haver duas bolas, uma ao lado da outra, com o mesmo número. A figura ao lado mostra um exemplo para o qual isso foi possível. Mas será que sempre é possível? Seu programa deve decidir 3 5 9 3 5 7 5 3 se é ou não possível obter uma sequência em que não haja bolas vizinhas com o mesmo número.\nEntrada\nA única linha da entrada contém uma sequência de oito inteiros Bi, para 1 ≤ i ≤ 8, representando os números impressos em cada bola da sequência.\nSaída\nImprima uma linha contendo o caractere “S” se for possível trocar bolas de posição e obter a sequência sem bolas vizinhas com o mesmo número; ou o caracter “N” se não for possível.\nRestrições\n• Bi é um inteiro entre 0 e 9, inclusive.",
    "examples": [
      [
        "3 7 3 3 5 5 5 9",
        "S"
      ],
      [
        "8 3 8 8 8 8 8 0",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bolas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cinco",
    "description": "Considere um número decimal não divisível por 5. Que- 7 3 0 1 0 5 6 9 7 5 4 2 remos fazer exatamente uma operação de troca entre os dígitos de duas posições distintas para obter um número que seja divisível por 5. Quer dizer, precisamos 7 3 0 1 0 5 6 9 7 5 4 2 escolher duas posições distintas e trocar os dígitos dessas duas posições. Mas queremos que o número resultante após a troca seja o maior número divisível por 5 7 3 0 1 0 5 6 9 7 5 4 2 possível.\nVeja o exemplo da figura, 730105697542, que não é divisível por 5. Podemos fazer a primeira troca ilustrada e obter 730102697545, que é divisível por 5. Mas, se fizermos a segunda troca ilustrada na figura, vamos obter um número divisível por 5 ainda maior, 732105697540.\nDados os dígitos decimais de um número na entrada, não divisível por 5, seu programa deve imprimir os dígitos decimais do maior número divisível por 5 que pode ser obtido com exatamente uma troca de dígitos entre duas posições distintas. Caso não seja possível obter um número divisível por 5, imprima apenas −1.\nEntrada\nA primeira linha da entrada contém um inteiro N, indicando quantos dígitos decimais tem o número não divisível por 5. A segunda linha contém N inteiros Di, 1 ≤ i ≤ N, representando os dígitos decimais do número em questão.\nSaída\nImprima uma linha contendo N inteiros representando os dígitos decimais do maior número divisível por 5 que pode ser obtido com exatamente uma troca de dígitos entre duas posições distintas. Caso não seja possível obter um número divisível por 5, imprima apenas −1.\nRestrições\n• 2 ≤ N ≤ 1000 • Di é um inteiro entre 0 e 9, inclusive.",
    "examples": [
      [
        "12\n7 3 0 1 0 5 6 9 7 5 4 2",
        "7 3 2 1 0 5 6 9 7 5 4 0"
      ],
      [
        "5\n7 4 1 2 9",
        "-1"
      ],
      [
        "8\n0 0 7 8 4 5 3 1",
        "1 0 7 8 4 5 3 0"
      ],
      [
        "10\n6 5 0 5 0 4 5 3 4 4",
        "6 5 4 5 0 4 5 3 4 0"
      ],
      [
        "7\n9 7 4 5 3 5 2",
        "9 7 4 5 3 2 5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cinco"
    },
    "imagesQuant": 0
  },
  {
    "name": "Mancha",
    "description": "Juninho está participando de um projeto de iniciação científica sobre identificação de doenças de pele através de análises de imagens digitais. Muitas vezes o formato de uma lesão de pele, ou mancha, pode indicar as possibilidades de diagnóstico. O professor orientador tem algumas imagens digitalizadas de manchas e precisa identificar aquelas que são “regulares” segundo uma definição bastante precisa, que será dada abaixo. Juninho precisa da sua ajuda para processar a imagem da mancha e decidir se ela é ou não regular.\nA imagem é um reticulado de N ×N pixels. Os pixels escuros representam a mancha, que é sempre conexa, ou seja, é composta de apenas uma componente. De forma mais precisa, dado qualquer par de pixels pertencentes à mancha, sempre existe um caminho, uma sequência de pixels escuros entre eles seguindo somente por direções ortogonais, totalmente contido dentro da mancha. A figura acima ilustra três possíveis manchas, para N = 10.\nDados dois pixels P e Q, a distância de Manhattan entre eles é definida como: dmanhattan(P,Q) = |Pl − Ql| + |Pc − Qc|, onde Pl é o índice da linha do pixel P e Pc é o índice da coluna do pixel P, na imagem digitalizada. O mesmo vale para Ql e Qc. Ou seja, a distância de Manhattan é a soma da diferença absoluta entre a linha de P e a linha de Q com a diferença absoluta entre as colunas de P e Q. Dados dois pixels P e Q que pertencem à mancha, definiremos d(P,Q) como sendo o comprimento do menor caminho existente entre P e Q, que esteja totalmente contido dentro da mancha.\nNo exemplo da figura mais à esquerda, onde P e Q estão representados por um pequeno círculo, d(P,Q) = 9 e dmanhattan(P,Q) = 9. Na figura do meio, d(P,Q) = 10 e dmanhattan(P,Q) = 6; e na figura mais à direita, d(P,Q) = 5 e dmanhattan(P,Q) = 3.\nFinalmente, uma mancha será regular se, para qualquer par de pixels P e Q pertencentes à mancha, tivermos d(P,Q) = dmanhattan(P,Q). Dessa forma, verifique que a figura mais à esquerda ilustra uma mancha regular, enquanto que as outras duas são irregulares.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando as dimensões da imagem. As N linhas seguintes contêm, cada uma, uma cadeia de N caracteres definindo uma linha de pixels da imagem. Os caracteres podem ser: “.” para pixels fora da mancha; e “*” para pixels que pertencem à mancha.\nSaída\nImprima uma linha contendo o caractere “S”, se a mancha for regular; ou “N”, se for irregular.\nRestrições\n• 2 ≤ N ≤ 1000; • A mancha possui pelo menos dois pixels.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 20 pontos, N ≤ 20; • Para um conjunto de casos de teste valendo 40 pontos, N ≤ 100.",
    "examples": [
      [
        "10\n..........\n.....*....\n...***....\n..*****...\n..*****...\n..*******.\n.********.\n...*****..\n......**..\n..........",
        "S"
      ],
      [
        "10\n..........\n....*.***.\n....*.***.\n..******..\n..****....\n....**....\n....****..\n...*****..\n.......*..\n..........",
        "N"
      ],
      [
        "2\n.*\n**",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mancha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Muro",
    "description": "Nós temos dois tipos de tijolos, como mostrado na parte esquerda da figura abaixo. A ideia é construir uma mureta de altura 2 e comprimento N. A parte direita da figura ilustra uma forma de usar os dois tipos de tijolos para construir uma mureta de comprimento N = 12.\nTipos de tijolos N=12 2 1 Precisamos saber quantas formas distintas existem de construir a mureta com esses dois tipos de tijolos. Para isso, já temos duas observações: qualquer mureta de comprimento N vai terminar de uma das sete maneiras ilustradas abaixo e; o número de formas distintas de construir uma mureta de comprimento 2, 1 e 0 é, respectivamente, 5, 1 e 1 (Sim! Existe uma forma de construir a mureta de comprimento 0: usar nenhum tijolo).\nN N-1 N N N N-3 N-2 N-2 N N N N-3 N-2 N-2 Dado N, seu programa deve computar o número de formas distintas de construir uma mureta de comprimento N. Como esse número pode ser muito grande, seu programa deve imprimir o resto da divisão dele por 109 + 7.\nEntrada\nA única linha da entrada contém um inteiro N, representando o comprimento da mureta.\nSaída\nImprima uma linha contendo um inteiro, o número de formas distintas de construir a mureta com os dois tipos de tijolos. Imprima o resto da divisão desse número por 109 + 7.\nRestrições\n• 0 ≤ N ≤ 104.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 20 pontos, N ≤ 16.",
    "examples": [
      [
        "2",
        "5"
      ],
      [
        "11",
        "36543"
      ],
      [
        "6",
        "241"
      ],
      [
        "0",
        "1"
      ],
      [
        "8712",
        "844673301"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "muro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Maximin",
    "description": "Maximin é uma pessoa muito pessimista. Sempre que ele avalia um conjunto de possibilidades, assume que o pior cenário é aquele que irá se concretizar. E assim, se ele deve tomar alguma decisão, certamente escolhe a alternativa que tem o melhor dos piores resultados.\nMaximin e seus amigos inventaram um jogo que funciona da seguinte maneira: • No começo de cada rodada, cada um dos participantes ganha um pedaço de papel e deve escrever um número inteiro no mesmo; • Assim que todos terminam de escrever em seu papel, os números de cada participante são ditos em voz alta, de modo que todos sabem quais números foram escritos, e os papéis são colocados em uma caixa; • Os jogadores discutem e definem um limite inferior L e um limite superior R; • Cada participante deve então escolher um número maior ou igual a L e menor ou igual a R; • Por fim, um dos papéis colocados na caixa é sorteado e a pontuação de cada jogador na rodada é a diferença entre o número escrito no papel sorteado e o número escolhido pelo jogador.\nComo é de se esperar, por ser pessimista Maximin assume que independente de sua escolha o número sorteado será aquele com a menor diferença em relação ao número escolhido por ele. Sua estratégia então é escolher o número que tem a maior das menores diferenças.\nPor exemplo, considere que há três participantes (incluindo Maximin), que numa rodada escreveram os números 10, 28 e 17 nos papéis, e os limites foram definidos como L = 7 e R = 37. Então Maximin escolhe o número 37, prevendo, pessimisticamente, que o papel que será sorteado terá o número 28. Assim, se sua previsão se concretizar, sua pontuação seria 9 nessa rodada (e se ela não se concretizar, sua pontuação será maior do que 9!). Note que qualquer outro número que Maximim escolhesse, e sua previsão pessimista se concretizasse, sua pontuação seria menor do que 9.\nQuando a quantidade de participantes aumenta ou os limites escolhidos são muito distantes um do outro fica bem difícil avaliar todas as possibilidades e por isso Maximin precisa de sua ajuda.\nNeste problema, seu programa deve computar qual a pontuação esperada de Maximin.\nEntrada\nA primeira linha contém três inteiros N, L e R representando respectivamente, a quantidade de participantes (incluindo Maximin), o menor e o maior número que pode ser escolhido na rodada. A linha seguinte contém N inteiros ai representando os números escritos nos papéis.\nSaída\nSeu programa deve produzir um inteiro representando a pontuação esperada por Maximin.\nRestrições\n• 2 ≤ N ≤ 105.\n• −109 ≤ L ≤ R ≤ 109.\n• −109 ≤ ai ≤ 109.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos: • 2 ≤ N ≤ 102.\n• −1000 ≤ L ≤ R ≤ 1000.\n• −1000 ≤ ai ≤ 1000.\n• Para um conjunto de casos de testes valendo 30 pontos: • 2 ≤ N ≤ 104.\n• −105 ≤ L ≤ R ≤ 105.\n• −105 ≤ ai ≤ 105.",
    "examples": [
      [
        "3 7 37\n10 17 28",
        "9"
      ],
      [
        "5 -6 6\n8 -4 -3 6 12",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2018,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "maximin"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dominó",
    "description": "O jogo de dominó tradicional, conhecido como duplo-6, possui 28 peças. Cada peça está dividida em dois quadrados e dentro de cada quadrado há entre 0 e 6 círculos. O jogo é chamado de duplo-6 justamente porque esse é o maior número de círculos que aparece num quadrado de uma peça. A figura ao lado mostra uma forma de organizar as 28 peças do jogo duplo-6 em 7 linhas. Essa figura permite ver claramente quantas peças haveria num jogo de dominó, por exemplo, do tipo duplo-4: seriam todas as peças das 5 primeiras linhas, 15 peças no total. Também poderíamos ver, seguindo o padrão da figura, quantas peças possui o jogo de dominó conhecido como mexicano, que é o duplo-12. Seriam 91 peças, correspondendo a 13 linhas.\nPara a nossa sorte, existe uma fórmula com a qual podemos calcular facilmente o número de peças de um jogo do tipo duplo-N, para um número N natural qualquer: ((N+1)*(N+2))/2. Neste problema, estamos precisando da sua ajuda para escrever um programa que, dado o valor N, use esta fórmula para calcular e imprimir quantas peças existem num jogo de dominó do tipo duplo-N.\nEntrada\nA primeira linha da entrada contém um número natural N representando o tipo do jogo de dominó: duplo-N.\nSaída\nSeu programa deve imprimir uma linha contendo um número natural representando quantas peças existem num jogo de dominó do tipo duplo-N.\nRestrições\n• 0 ≤ N ≤ 10000 Exemplos",
    "examples": [
      [
        "6",
        "28"
      ],
      [
        "12",
        "91"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "domino"
    },
    "imagesQuant": 0
  },
  {
    "name": "A idade de Dona Mônica",
    "description": "Dona Mônica é mãe de três filhos que têm idades diferentes. Ela notou que, neste ano, a soma das idades dos seus três filhos é igual à idade dela. Neste problema, dada a idade de dona Mônica e as idades de dois dos filhos, seu programa deve computar e imprimir a idade do filho mais velho.\nPor exemplo, se sabemos que dona Mônica tem 52 anos e as idades conhecidas de dois dos filhos são 14 e 18 anos, então a idade do outro filho, que não era conhecida, tem que ser 20 anos, pois a soma das três idades tem que ser 52. Portanto, a idade do filho mais velho é 20. Em mais um exemplo, se dona Mônica tem 47 anos e as idades de dois dos filhos são 21 e 9 anos, então o outro filho tem que ter 17 anos e, portanto, a idade do filho mais velho é 21.\nEntrada\nA primeira linha da entrada contém um inteiro M representando a idade de dona Mônica. A segunda linha da entrada contém um inteiro A representando a idade de um dos filhos. A terceira linha da entrada contém um inteiro B representando a idade de outro filho.\nSaída\nSeu programa deve imprimir uma linha, contendo um número inteiro, representando a idade do filho mais velho de dona Mônica.\nRestrições\n• 40 ≤ M ≤ 110 • 1 ≤ A < M • 1 ≤ B < M • A (cid:54)= B Exemplos",
    "examples": [
      [
        "52\n14\n18",
        "20"
      ],
      [
        "47\n21\n9",
        "21"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "idade"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sequência Secreta",
    "description": "Na calçada em frente ao Palácio Imperial, não se sabe a razão, existe uma sequência de N números desenhados no chão. A sequência tem 1 1 1 a seguinte forma: ela começa e termina com o número 1; apenas os 2 2 2 números 1 e 2 aparecem nela; e o número 2 aparece pelo menos uma 1 1 1 vez. Veja um exemplo na coluna (a) da figura ao lado. 2 2 2 Ninguém sabe o significado da sequência e, justamente por isso, várias 2 2 2 teorias malucas surgiram. Uma delas diz que a sequência representa, 2 2 2 na verdade, apenas um valor que estaria relacionado a um segredo 1 1 1 dos imperadores. Esse valor é a quantidade máxima de números da 1 1 1 sequência que poderiam ser marcados com um círculo, de modo que 2 2 2 a sequência de números marcados não contenha dois números iguais 2 2 2 consecutivos. 1 1 1 A coluna (b) da figura ao lado ilustra uma sequência de 4 números 1 1 1 marcados que obedece a restrição acima. Só que é possível marcar 7 números, como mostra a coluna (c) da figura. (a) (b) (c) Neste problema, dada a sequência original de números desenhados no chão da calçada, seu programa deve computar e imprimir a quantidade máxima de números da sequência que poderiam ser marcados com um círculo sem que haja dois números iguais consecutivos na sequência marcada.\nEntrada\nA primeira linha da entrada contém um inteiro N representando o tamanho da sequência. As N linhas seguintes contêm, cada uma, um inteiro Vi, para 1 ≤ i ≤ N, definindo a sequência de números desenhados no chão da calçada imperial.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro representando a quantidade máxima de números da sequência que poderiam ser marcados com um círculo sem que haja dois números iguais consecutivos na sequência marcada.\nRestrições\n• 3 ≤ N ≤ 500 • Vi é igual a 1 ou 2, para 1 ≤ i ≤ N Exemplos",
    "examples": [
      [
        "5\n1\n1\n1\n2\n1",
        "3"
      ],
      [
        "12\n1\n2\n1\n2\n2\n2\n1\n1\n2\n2\n1\n1",
        "7"
      ],
      [
        "3\n1\n2\n1",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "secreta"
    },
    "imagesQuant": 0
  },
  {
    "name": "Distância entre amigos",
    "description": "Ao longo da rua existem N prédios de largura igual, mas com número de andares diferentes. Quase toda a turma do colégio mora em algum apartamento desses prédios e eles resolveram definir a distância entre dois apartamentos quaisquer da rua para saber, ao final, qual par de colegas da turma mora mais longe um do outro.\nFunciona assim: para um colega A visitar um colega B, que mora num prédio diferente, ele deve descer a andares até o térreo do seu prédio; depois andar para a esquerda ou direita, dependendo do lado para o qual seu colega mora, por p prédios; depois subir b andares até o apartamento do colega B. A distância entre A e B, então, será a+p+b. A figura mostra um exemplo, para N = 14, onde estão marcados dois andares de prédios diferentes para os quais a distância é 12.\nDado um número de andares de cada prédio ao longo da rua, seu programa deve computar a distância máxima possível entre dois apartamentos quaisquer na rua.\nEntrada\nA primeira linha da entrada contém um inteiro N representando o número de prédios na rua. A segunda linha contém N inteiros Ai,1 ≤ i ≤ N, representando o número de andares de cada prédio, sem contar o térreo. Quer dizer, por exemplo, se Ai = 19, então quem mora no último andar precisa descer 19 andares até o térreo. Veja a figura, que corresponde ao primeiro exemplo de entrada abaixo.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro representando a distância máxima possível entre dois apartamentos na rua.\nRestrições\n• 2 ≤ N ≤ 200000(2 × 105); • 1 ≤ Ai ≤ 109 para todo 1 ≤ i ≤ N.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste somando 25 pontos, N ≤ 104 e Ai ≤ 104 • Em um conjunto de casos de teste somando 25 pontos, Ai ≤ 100 • Em um conjunto de casos de teste somando 50 pontos, nenhuma restrição adicional Exemplos",
    "examples": [
      [
        "14\n2 3 1 6 4 3 7 5 6 4 5 3 1 1",
        "18"
      ],
      [
        "6\n1 1 4 3 1 2",
        "9"
      ],
      [
        "2\n1 1",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "amigos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo de Dominós",
    "description": "O jogo de dominó tradicional, conhecido como duplo-6, possui 28 peças. Cada peça está dividida em dois quadrados e dentro de cada quadrado há entre 0 e 6 círculos. O jogo é chamado de duplo-6 justamente porque esse é o maior número de círculos que aparece num quadrado de uma peça. A figura ao lado mostra uma forma de organizar as 28 peças do jogo duplo-6 em 7 linhas. Essa figura permite ver claramente quantas peças haveria num jogo de dominó, por exemplo, do tipo duplo-4: seriam todas as peças das 5 primeiras linhas, 15 peças no total. Também poderíamos ver, seguindo o padrão da figura, quantas peças possui o jogo de dominó conhecido como mexicano, que é o duplo-12. Seriam 91 peças, correspondendo a 13 linhas.\nNeste problema, estamos precisando da sua ajuda para escrever um programa que, dado o valor N, calcule e imprima quantas peças existem num jogo de dominó do tipo duplo-N.\nEntrada\nA primeira linha da entrada contém um número natural N representando o tipo do jogo de dominó: duplo-N.\nSaída\nSeu programa deve imprimir uma linha contendo um número natural representando quantas peças existem num jogo de dominó do tipo duplo-N.\nRestrições\n• 0 ≤ N ≤ 10000 Exemplos",
    "examples": [
      [
        "6",
        "28"
      ],
      [
        "12",
        "91"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Nota cortada",
    "description": "Se pegarmos uma nota de 100 reais e a cortarmos, usando uma tesoura, em dois pedaços, quanto vale cada um dos pedaços? A regra é simples: se um dos pedaços possuir estritamente mais da metade da área da nota original, então ele vale 100 reais; e o outro pedaço não vale nada. Veja que se cada pedaço possuir exatamente metade da área original, então nenhum dos dois tem valor.\nFelix e Marzia decidiram fazer um corte, em linha reta, que comece no lado inferior da nota, a base, e termine no lado superior, o topo. A nota é um retângulo de comprimento 160 centímetros e altura 70 centímetros, como mostrado na parte esquerda da figura abaixo. Felix sempre vai ficar com o pedaço mais à esquerda da nota e Marzia com o pedaço mais à direita. A parte direita da figura ilustra dois possíveis cortes. No de cima, Marzia ficaria claramente com o maior pedaço, que vale 100 reais; e no de baixo, dá para ver que Felix é quem ficaria com o maior pedaço.\nT 70 B T 0 160 B O corte reto vai começar na base a uma distância de B centímetros a partir do lado esquerdo da nota; e terminar no topo a uma distância de T centímetros também a partir do lado esquerdo da nota. Veja a indicação na parte direita da figura.\nNeste problema, dados os valores B e T, seu programa deve computar quem vai ficar com o pedaço que vale 100 reais, ou se o valor da nota se perdeu.\nEntrada\nA primeira linha da entrada contém um inteiro B representando a distância do ponto inicial do corte, na base, para o lado esquerdo da nota. A segunda linha da entrada contém um inteiro T representando a distância do ponto final do corte, no topo, para o lado esquerdo da nota.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro: 1, se Felix ficou com o pedaço que vale 100 reais; 2, se Marzia ficou com o pedaço que vale 100 reais; ou 0, se o valor da nota se perdeu.\nRestrições\n• 0 < B < 160 • 0 < T < 160 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 25 pontos, B = T Exemplos",
    "examples": [
      [
        "50\n86",
        "2"
      ],
      [
        "70\n90",
        "0"
      ],
      [
        "130\n138",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "nota"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chuva",
    "description": "Está chovendo tanto na Obilândia que começaram a aparecer goteiras dentro da casa do prefeito.\nUma dessas goteiras está fazendo escorrer água verticalmente, a partir de um ponto no teto, numa parede onde há várias prateleiras horizontais. Quando a água bate em uma prateleira, ela começa a escorrer horizontalmente para os dois lados, direita e esquerda, até as extremidades da prateleira, quando volta a escorrer verticalmente.\n.......o......\n.###...####.#.\nVamos representar a parede por uma matriz de N linhas e M colunas ..............\nde caracteres, como mostrado ao lado. As prateleiras serão represen- ..######......\ntadas por “#” e a parede por “.”. Só existem prateleiras nas linhas ..............\npares e elas nunca encostam na borda da parede. Há apenas um ponto .#.####....##.\nde vazamento representado pelo caractere “o” na primeira linha. ..............\n.....####.....\n..............\nPara deixar mais rigorosa a forma como a água vai escorrer, seja c(i,j) ......oooooo..\no caractere na linha i coluna j. Se c(i,j)= “.”, então ele deve virar .###..o####o#.\n“o” sempre que: .oooooooo..o..\n.o######o..o..\n• c(i − 1,j)= “o”; ou ooo.....o.oooo o#o####.o.o##o • c(i,j − 1)= “o” e c(i + 1,j − 1)= “#”; ou o.o.ooooooo..o o.o.o####oo..o • c(i,j + 1)= “o” e c(i + 1,j + 1)= “#”. o.o.o....oo..o Neste problema, dada a matriz representando a parede no início do vazamento, seu programa deve imprimir na saída uma matriz representando a parede usando o caractere “o” exatamente nas posições que serão molhadas pelo vazamento, como ilustrado acima.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, respectivamente o número de linhas e colunas da matriz. As N linhas seguintes da entrada contêm, cada uma, uma sequência de M caracteres entre três possíveis: “.”, “#” ou “o”.\nSaída\nSeu programa deve imprimir N linhas, cada uma contendo uma sequência de M caracteres, representando a matriz da entrada usando o caractere “o” exatamente nas posições que serão molhadas pelo vazamento.\nRestrições\n• 3 ≤ N ≤ 500 e 3 ≤ M ≤ 500; • O número de linhas N é ímpar; • Há exatamente um caractere “o” na primeira linha; • As linhas ímpares, a primeira coluna e a última coluna não possuem o caractere “#”.\nExemplos",
    "examples": [
      [
        "9 14\n.......o......\n.###...####.#.\n..............\n..######......\n..............\n.#.####....##.\n..............\n.....####.....\n..............",
        "......oooooo..\n.###..o####o#.\n.oooooooo..o..\n.o######o..o..\nooo.....o.oooo\no#o####.o.o##o\no.o.ooooooo..o\no.o.o####oo..o\no.o.o....oo..o"
      ],
      [
        "7 5\n.o...\n.#...\n.....\n.....\n.....\n..#..\n.....",
        "ooo..\no#o..\no.o..\no.o..\noooo.\noo#o.\noo.o."
      ],
      [
        "3 3\n..o\n.#.\n...",
        "..o\n.#o\n..o"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chuva"
    },
    "imagesQuant": 0
  },
  {
    "name": "Calçada Imperial",
    "description": "Na calçada em frente ao Palácio Imperial, não se sabe a razão, existe uma sequência de N números desenhados no chão. A sequência é 3 3 composta apenas pelos números de 1 a N. Veja um exemplo na coluna 2 2 (a) da figura ao lado, para N = 12. 5 5 Ninguém sabe o significado da sequência e, justamente por isso, várias 2 2 teorias malucas surgiram. Uma delas diz que a sequência representa, 10 10 na verdade, apenas um valor que estaria relacionado a um grande se- 4 4 gredo dos imperadores. Esse valor é a quantidade máxima de números 4 4 da sequência que poderiam ser marcados com um círculo, de modo que 7 7 a sequência de números marcados não contenha dois números iguais 12 12 consecutivos e seja composta de no máximo dois números distintos. 2 2 A coluna (b) da figura ilustra uma sequência de 4 números marcados 8 8 que obedece a restrição acima. Você consegue verificar que essa é, 10 10 de fato, a quantidade máxima possível de números numa sequência marcada? (a) (b) Neste problema, dada a sequência original de números desenhados no chão da calçada, seu programa deve computar e imprimir a quantidade máxima de números da sequência que poderiam ser marcados com um círculo sem que haja dois números iguais consecutivos na sequência marcada e tal que ela seja composta de no máximo dois números distintos.\nEntrada\nA primeira linha da entrada contém um inteiro N representando o tamanho da sequência. As N linhas seguintes contêm, cada uma, um inteiro Vi, para 1 ≤ i ≤ N, definindo a sequência de números desenhados no chão da calçada imperial.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro representando a quantidade máxima de números da sequência que poderiam ser marcados com um círculo sem que haja dois números iguais consecutivos na sequência marcada e tal que ela seja composta de no máximo dois números distintos.\nRestrições\n• 1 ≤ N ≤ 500 • 1 ≤ Vi ≤ N, para 1 ≤ i ≤ N Exemplos",
    "examples": [
      [
        "1\n1",
        "1"
      ],
      [
        "12\n3\n2\n5\n2\n10\n4\n4\n7\n12\n2\n8\n10",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "imperial"
    },
    "imagesQuant": 0
  },
  {
    "name": "Soma",
    "description": "Temos uma sequência de N quadrados desenhados lado a lado. Cada quadrado possui um número natural anotado   dentro dele. Dados a sequência dos N quadrados e um va-   lor K, quantos retângulos distintos existem cuja soma dos números dentro do retângulo é exatamente igual a K? Por   exemplo, a figura mostra uma sequência de N = 10 quadra-   dos para a qual existem 5 retângulos cuja soma dos números   é igual a K = 4.\nEntrada\nA primeira linha da entrada contém dois inteiros N e K representando o número de quadrados na sequência e o valor da soma desejada. A segunda linha da entrada contém N números naturais Xi, para 1 ≤ i ≤ N, indicando a sequência de números anotados dentro dos quadrados.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro representando quantos retângulos existem na sequência cuja soma é igual a K.\nRestrições\n• 1 ≤ N ≤ 500000 (5 × 105) • 0 ≤ K ≤ 106 • 0 ≤ Xi ≤ 100 para 1 ≤ i ≤ N Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 10 pontos, N ≤ 500 • Em um conjunto de casos de teste somando 20 pontos, N ≤ 104 • Em um conjunto de casos de teste somando 30 pontos, K > 0 e Xi > 0 para 1 ≤ i ≤ N • Em um conjunto de casos de teste somando 40 pontos, nenhuma restrição adicional (note que para esta subtarefa o inteiro da saída pode não caber em 32 bits.) Exemplos\nExemplo de entrada 1 Exemplo de saída 1 10 4 5",
    "examples": [
      [
        "10 4\n2 0 1 1 0 0 8 4 1 3",
        "5"
      ],
      [
        "15 0\n0 0 0 0 0 5 12 0 1 0 0 0 51 0 0",
        "25"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "soma"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo dos copos",
    "description": "Uma brincadeira muito comum e divertida entre dois jogadores usa uma moeda e três copos opacos (ou seja, não é possível ver o que está dentro do copo olhando pela lateral do copo). Os três copos são colocados com a boca para baixo, em uma linha, um ao lado do outro, em posições que vamos chamar de A, B e C. Uma moeda é colocada embaixo de um dos copos.\nNa brincadeira, um jogador chamado banca realiza um movimento para trocar a posição de dois copos, arrastando os copos de tal modo que se a moeda está em baixo de um dos copos envolvidos no movimento, ela continua embaixo do mesmo copo após a troca de posição. O jogador banca pode realizar três tipos de movimento, ilustrados na figura abaixo: 1. Trocar o copo na posição A com o copo na posição B.\n2. Trocar o copo na posição B com o copo na posição C.\n3. Trocar o copo na posição A com o copo na posição C.\nA B C A B C A B C Movimento de tipo 1: Movimento de tipo 2: Movimento de tipo 3: troca os copos nas posições A e B troca os copos nas posições B e C troca os copos nas posições A e C O jogador banca realiza vários movimentos de troca tentando confundir o outro jogador, chamado espectador. Ao final o jogador espectador deve dizer em qual posição está a moeda.\nPor exemplo, considere que inicialmente a moeda está embaixo do copo na posição A e que o jogador banca realiza uma sequência de apenas três trocas, executando um movimento do tipo 1, após o qual moeda termina embaixo do copo na posição B, seguido de um movimento do tipo 2, após o qual a moeda termina embaixo do copo na posição C, seguido de um movimento do tipo 3, após o qual a moeda termina embaixo do copo na posição A.\nNesta tarefa, dadas a descrição da sequência de movimentos e a posição inicial da moeda, você deve escrever um programa que determine a posição final da moeda após todos os movimentos.\nEntrada\nA primeira linha contém um inteiro N, o número de movimentos que o jogador banca realiza. A segunda linha contém um caractere, entre A, B e C, indicando a posição inicial da moeda. Cada uma das N linhas seguintes contém um inteiro, indicando o tipo de movimento efetuado pelo jogador banca na sequência.\nSaída\nSeu programa deve produzir uma única linha, com um único caractere entre A, B e C, a posição em que a moeda se encontra ao final da sequência de movimentos.\nRestrições\n• 1 ≤ N ≤ 1000",
    "examples": [
      [
        "3\nA\n1\n2\n3",
        "A"
      ],
      [
        "6\nC\n1\n2\n3\n3\n1\n1",
        "B"
      ],
      [
        "1\nB\n3",
        "B"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "copos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tabela do campeonato",
    "description": "Joana adora futebol e conseguiu um estágio no clube pelo qual torce. Na sala de troféus Joana encontrou uma caderneta em que um antigo conselheiro do clube anotou os resultados de todos os campeonatos que o time participou.\nPara cada campeonato há uma anotação na caderneta informando cinco dados: o número de jogos, o número de pontos, o número de vitórias, o número de empates e o número de derrotas do time naquele campeonato. Em todos os campeonatos, cada vitória vale três pontos, cada empate vale um ponto e derrotas não valem pontos.\nInfelizmente, a caderneta era muito velha e alguns desses números estavam ilegíveis. Joana, no entanto, percebeu que, para cada campeonato, se algum número estivesse ilegível ele poderia ser computado utilizando os números legíveis daquele campeonato.\nSua tarefa é escrever um programa para completar as informações encontradas na caderneta.\nEntrada\nA entrada consiste de uma única linha que contém cinco inteiros J,P,V,E e D, indicando respectivamente o número de jogos, o número de pontos, o número de vitórias, o número de empates e o número de derrotas para um campeonato. Um ou dois desses números tem o valor -1, indicando que o número é ilegível na caderneta. Todos os casos da entrada têm solução.\nSaída\nSeu programa deve produzir uma única linha, com exatamente cinco números inteiros, os valores corrigidos da caderneta para o campeonato da entrada. Os números devem ser dados na mesma ordem fornecida na entrada: o número de jogos, o número de pontos, o número de vitórias, o número de empates e o número de derrotas, separados por exatamente um espaço em branco. Note que no resultado devem valer as equações J = V + E + D e P = 3 × V + E.\nRestrições\n• 1 ≤ J ≤ 100; 0 ≤ P ≤ 300; 0 ≤ V ≤ 100; 0 ≤ E ≤ 100; 0 ≤ D ≤ 100.\n• Na entrada, um ou dois dos valores entre J,P,V,E e D é igual a −1 (e somente nesses casos as restrições acima não são obedecidas).\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, P,V,E,D ≥ 0 e J = −1.\n• Para um conjunto de casos de testes valendo outros 40 pontos, apenas um dos valores da entrada é −1.",
    "examples": [
      [
        "10 20 6 2 -1",
        "10 20 6 2 2"
      ],
      [
        "-1 64 18 10 10",
        "38 64 18 10 10"
      ],
      [
        "-1 47 14 -1 9",
        "28 47 14 5 9"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tabela"
    },
    "imagesQuant": 0
  },
  {
    "name": "Matriz super-legal",
    "description": "Denotando por Ai,j o elemento na i-ésima linha e j-ésima coluna da matriz A, dizemos que uma matriz é “legal” se a condição A1,1 + Alin,col ≤ A1,col + Alin,1 é verdadeira para todo lin > 1 e col > 1.\nAdicionalmente, dizemos que a matriz é “super-legal” se cada uma de suas submatrizes com pelo menos duas linhas e duas colunas é legal. Lembre que uma submatriz S de uma matriz ML×C é uma matriz que inclui todos os elementos Mi,j tais que l1 ≤ i ≤ l2 e c1 ≤ j ≤ c2, para 1 ≤ l1 ≤ l2 ≤ L e 1 ≤ c1 ≤ c2 ≤ C.\nA sua tarefa é, dada uma matriz A, determinar a maior quantidade de elementos de uma submatriz super-legal da matriz A.\nEntrada\nA primeira linha contém dois inteiros L e C indicando respectivamente o número de linhas e o número de colunas da matriz. Cada uma das L linhas seguintes contém C inteiros Xi representando os elementos da matriz.\nSaída\nSeu programa deve produzir uma única linha, com apenas um número inteiro, a maior quantidade de elementos de uma submatriz super-legal da matriz da entrada, ou zero no caso de não existir uma submatriz super-legal.\nRestrições\n• 2 ≤ L,C ≤ 1000 • −106 ≤ Xi ≤ 106 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, L,C ≤ 3.\n• Para um conjunto de casos de testes valendo outros 50 pontos, L,C ≤ 300.",
    "examples": [
      [
        "3 3\n1 4 10\n5 2 6\n11 1 3",
        "9"
      ],
      [
        "3 3\n1 3 1\n2 1 2\n1 1 1",
        "4"
      ],
      [
        "5 6\n1 1 4 0 3 3\n4 4 9 7 11 13\n-3 -1 4 2 8 11\n1 5 9 5 9 10\n4 8 10 5 8 8",
        "15"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "matriz"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ponto do meio",
    "description": "Paulo foi contratado por uma companhia de mapas digitais para implementar melhorias em seus mapas. Seu primeiro trabalho na empresa é implementar o algoritmo denominado deslocamento do ponto do meio. Não vamos descrever aqui o algoritmo completo, vamos focar apenas num aspecto importante para Paulo, que está preocupado em otimizar o uso de memória em sua implementação do algoritmo. O algoritmo funciona em passos. Inicialmente, quatro pontos do mapa são selecionados, formando um quadrado. Então a cada passo, para cada quadrado, faça: • adicione quatro novos pontos, um ponto em cada lado do quadrado, exatamente no meio do lado.\n• adicione também mais um novo ponto, exatamente no meio do quadrado.\nO algoritmo utiliza os pontos criados para calcular e armazenar valores do mapa, mas Paulo está interessado apenas no número de pontos criados pelo algoritmo. Na figura abaixo, pontos brancos representam pontos adicionados no passo corrente, pontos pretos representam pontos adicionados em passos anteriores.\nInício Passo 1 Passo 2 4 pontos 9 pontos 25 pontos Paulo notou que o algoritmo gera muitos pontos, e muitos pontos pertencem a mais de um quadrado.\nPara economizar memória, Paulo planeja calcular e armazenar cada ponto apenas uma vez.\nSua tarefa, dado o número de passos que Paulo planeja executar, é determinar a quantidade de pontos únicos que Paulo necessita calcular e armazenar.\nEntrada\nA entrada consiste de uma única linha que contém um inteiro N, o número de passos.\nSaída\nSeu programa deve produzir uma única linha, com apenas um número inteiro, a quantidade de pontos únicos que Paulo deve calcular e armazenar em N passos.\nRestrições\n• 1 ≤ N ≤ 50 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N ≤ 3.\n• Para um conjunto de casos de testes valendo outros 40 pontos, 4 ≤ N ≤ 10.",
    "examples": [
      [
        "2",
        "25"
      ],
      [
        "5",
        "1089"
      ],
      [
        "1",
        "9"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "ponto"
    },
    "imagesQuant": 0
  },
  {
    "name": "Detetive",
    "description": "detetive_py3.py Uma agência de detetives quer criar um aplicativo para ajudar a resolver os problemas dos clientes.\nA agência é muito eficiente em coletar informações e fazer deduções muito precisas. Para cada cliente a agência monta uma base de dados contendo um conjunto de eventos e um conjunto de implicações na forma A → B, onde A e B representam eventos. O significado da implicação é que, se o evento A ocorreu, então o evento B também necessariamente tem que ter ocorrido. Para essa implicação, A é a causa e B é a consequência. Além disso, se um evento é consequência de pelo menos uma causa, então ele só pode ocorrer se pelo menos uma de suas causas ocorrer também. Não existe, na base de dados da agência, uma sequência circular de implicações (A → B → C ... → A).\nPortanto, alguns eventos não possuem causa, não são consequência em nenhuma implicação.\nVeja que essas condições permitem deduções muito precisas. Por exemplo, considere que o conjunto de eventos seja {1,2,3,4} e o conjunto de implicações seja {1 → 2,1 → 3, 2 → 4,3 → 4}. Se algum detetive conseguir determinar que o evento 4 é verdadeiro, que ele ocorreu, então o evento 2 ou o evento 3 tem que ter ocorrido, mas para eles ocorrerem o evento sem causa 1 tem que ter ocorrido.\nE como 1 ocorreu, por implicação, 2 e 3 ocorreram também. Portanto o aplicativo da agência poderia concluir que todos os quatro eventos ocorreram com certeza, a partir da determinação de que o evento 4 ocorreu. Por um outro exemplo, considere que o conjunto de eventos seja {1,2,3} e o conjunto de implicações seja {1 → 3,2 → 3}. Se um detetive determinar que o evento 3 é verdadeiro, não podemos ter certeza de qual foi a causa.\nA agência solicita que você escreva um programa para determinar o conjunto de todos os eventos que ocorreram com certeza, considerando as informações da base de dados e um conjunto inicial de eventos determinados como verdadeiros pelos detetives.\nEntrada\nA primeira linha contém três números inteiros E,I e V , representando respectivamente o número total de eventos, o número de implicações e o número de eventos que a agência determinou que são verdadeiros.\nCada evento é identificado por um número de 1 a E. Cada uma das I linhas seguintes contém dois inteiros A e B, representando dois eventos, descrevendo uma implicação A → B coletada pela agência. A última linha contém V inteiros Xi, representando os eventos que a agência determinou que são verdadeiros. Os eventos Xi são dados em ordem crescente do número de identificação.\nSaída\nSeu programa deve produzir uma única linha, com os identificadores de todos os eventos que certamente ocorreram, considerando o conjunto de implicações dado na entrada. Os identificadores dos eventos devem ser escritos em ordem crescente, separados por um único espaço em branco.\nRestrições\n• 1 ≤ E ≤ 103 • 1 ≤ I ≤ 105 • 1 ≤ A,B,V ≤ E • 1 ≤ Xi ≤ E, para 1 ≤ i ≤ V .\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 70 pontos, 1 ≤ E ≤ 500.",
    "examples": [
      [
        "3 2 1\n2 3\n1 2\n3",
        "1 2 3"
      ],
      [
        "4 4 1\n1 2\n1 3\n2 4\n3 4\n4",
        "1 2 3 4"
      ],
      [
        "3 2 1\n1 3\n2 3\n3",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "detetive"
    },
    "imagesQuant": 0
  },
  {
    "name": "Supermercado",
    "description": "Maria está participando de um programa de intercâmbio no reino da Nlogônia. Ela está gostando muito da experiência, e decidiu fazer um churrasco para suas novas amigas da escola. Como não tem muito dinheiro, Maria vai fazer uma pesquisa para comprar carne no supermercado mais barato que encontrar.\nNo entanto ela está um pouco confusa para saber qual supermercado tem o menor preço. O dinheiro na Nlogônia é o Bit, abreviado por B$, mas não é esse o problema. O problema é que o costume na Nlogônia é informar o preço de uma maneira diferente do que Maria está acostumada. Os preços são anunciados como “X Bits por Y gramas do produto”.\nPor exemplo o preço de um dado produto é anunciado como sendo B$ 24,00 por 250 gramas em um supermercado, B$ 16,00 por 100 gramas em outro supermercado, B$ 19,00 por 120 gramas em outro supermercado, e assim por diante.\nVocê pode ajudar Maria? Dados os preços anunciados pelos supermercados no bairro em que Maria mora, determine o menor valor que Maria deve gastar para comprar 1 kilograma (1000 gramas) de carne.\nEntrada\nA primeira linha contém um número inteiro N, o número de supermercados próximos à casa de Maria. Cada uma das N linhas seguintes indica o preço da carne em um supermercado e contém um número real P e um número inteiro G, indicando que G gramas de carne custam P Bits.\nSaída\nSeu programa deve produzir uma única linha, com apenas um número real, o menor preço para comprar 1 kilograma de carne. O resultado deve ser escrito com exatamente dois dígitos após o ponto decimal.\nRestrições\n• 1 ≤ N ≤ 100 • 0 < P ≤ 1000.00, representado com dois dígitos após o ponto decimal.\n• 1 ≤ G ≤ 1000",
    "examples": [
      [
        "3\n3.0 100\n2.0 100\n5.0 100",
        "20.00"
      ],
      [
        "4\n100.00 500\n190.00 1000\n200.00 900\n110.00 550",
        "190.00"
      ],
      [
        "5\n46.50 794\n25.72 130\n66.00 800\n22.45 110\n38.99 453",
        "58.56"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "super"
    },
    "imagesQuant": 0
  },
  {
    "name": "Manchas de pele",
    "description": "manchas_py3.py O laboratório de dermatologia da Linearlândia está implementando um software para contar o número de manchas presentes numa imagem digital de N por M pixels. Cada pixel na imagem é preto ou branco e dois pixels pretos distintos A e B pertencem à mesma mancha se e somente se: existir uma sequência de pixels [P1,P2,...,Pk], onde k ≥ 2, A = P1, B = Pk e para todo 1 ≤ i < k, Pi é ortogonalmente adjacente a Pi+1 (Pi imediatamente acima, abaixo, à esquerda ou à direita de Pi+1).\n  A figura acima, para N = 8 e M = 9, ilustra uma imagem digital onde existem oito manchas. Dada a imagem, seu programa deve contar o número de manchas presentes.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, representando, respectivamente, o número de linhas e colunas da imagem. As N linhas seguintes contêm, cada uma, M inteiros P representando os pixels da imagem.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro, o número de manchas na imagem.\nRestrições\n• 1 ≤ N ≤ 1000 • 1 ≤ M ≤ 1000 • O valor de P é 1, representando um pixel preto, ou 0, representando um pixel branco.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N = M = 2.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N = 1.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N,M ≤ 100.\n• Para um conjunto de casos de testes valendo outros 50 pontos, nenhuma restrição adicional (Atenção, para essa parcial, não é recomendada uma implementação recursiva!)",
    "examples": [
      [
        "8 9\n1 0 0 0 0 0 1 1 1\n1 1 0 1 1 1 0 1 1\n1 0 0 0 0 1 0 1 0\n0 0 1 0 0 1 1 1 0\n0 1 1 0 0 0 0 1 0\n0 1 0 0 1 1 0 0 0\n0 0 0 1 0 1 0 0 1\n1 1 1 0 0 0 0 1 0",
        "8"
      ],
      [
        "1 1\n0",
        "0"
      ],
      [
        "1 10\n0 0 1 0 1 1 1 0 1 0",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "manchas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Parcelamento sem juros",
    "description": "parcelamento_py2.py ou parcelamento_py3.py Pedrinho está implementando o sistema de controle de pagamentos parcelados de uma grande empresa de cartão de crédito digital. Os clientes podem parcelar as compras sem juros no cartão, em até 18 vezes. Quando o valor V da compra é divisível pelo número P de parcelas que o cliente escolhe, todas as parcelas terão o mesmo valor. Por exemplo, se o cliente comprar um livro de V = 30 reais em P = 6 vezes, então as parcelas terão valores: 5, 5, 5, 5, 5 e 5. Mas se o valor da compra não for divisível pelo número de parcelas será preciso fazer um ajuste, pois a empresa quer que todas as parcelas tenham sempre um valor inteiro e somem no total, claro, o valor exato da compra. O que Pedrinho decidiu foi distribuir o resto da divisão de V por P igualmente entre as parcelas iniciais. Por exemplo, se a compra for de V = 45 e o número de parcelas for P = 7, então as parcelas terão valores: 7, 7, 7, 6, 6, 6 e 6. Quer dizer, como o resto da divisão de 45 por 7 é 3, então as 3 parcelas iniciais devem ter valor um real maior do que as 4 parcelas finais.\nVocê precisa ajudar Pedrinho e escrever um programa que, dado o valor da compra e o número de parcelas, imprima os valores de cada parcela.\nEntrada\nA primeira linha da entrada contém um inteiro V , representando o valor da compra. A segunda linha da entrada contém um inteiro P, indicando o número de parcelas.\nSaída\nSeu programa deve imprimir P linhas, cada uma contendo um inteiro representando o valor de uma parcela. A i-ésima linha deve conter o valor da i-ésima parcela, para 1 ≤ i ≤ P, de acordo com o que Pedrinho decidiu.\nRestrições\n• 10 ≤ V ≤ 1000 • 2 ≤ P ≤ 18",
    "examples": [
      [
        "30\n6",
        "5\n5\n5\n5\n5\n5"
      ],
      [
        "45\n7",
        "7\n7\n7\n6\n6\n6\n6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "parcelamento"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pares de números",
    "description": "Temos um vetor de N inteiros distintos e dois inteiros I e F. Precisamos computar quantos pares desses inteiros do vetor somam pelo menos I e no máximo F. Por exemplo, se o vetor for [45,12,11,7,83,29,5] e I = 19 e F = 52, temos exatamente 8 pares cuja soma está entre 19 e 52: {5,29}, {5,45}, {7,12}, {7,29}, {7,45}, {11,12}, {11,29} e {12,29}.\nEntrada\nA primeira linha da entrada contém três inteiros N, I e F, indicando respectivamente o tamanho do vetor e o valor mínimo da soma e o valor máximo da soma.\nSaída\nSeu programa deve imprimir uma única linha contendo um inteiro indicando quantos pares de inteiros no vetor somam pelo menos I e no máximo F.\nRestrições\n• 2 ≤ N ≤ 1000 • −2000 ≤ I,F ≤ 2000 • O valor de cada inteiro no vetor está entre −1000 e 1000 • Os inteiros no vetor são distintos",
    "examples": [
      [
        "7 19 52\n45 12 11 7 83 29 5",
        "8"
      ],
      [
        "2 -2 2\n12 -16",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pares"
    },
    "imagesQuant": 0
  },
  {
    "name": "Coleção de Upas",
    "description": "colecao_py3.py Mayuri é uma jovem que adora colecionar Upas. Ela está sempre procurando pelos melhores Upas para melhorar sua coleção. Cada Upa possui uma cor única e como Mayuri é muito perfeccionista ela não acha que todas cores combinam juntas, então ela resolveu escrever uma lista com pares de cores que não combinam. No entanto, ela está muito confusa em como organizar sua coleção, pois existem Upas mais raros que outros e por isso ela também precisa manter sempre os Upas mais raros.\nSua coleção é composta por N Upas e ela possui exatamente um Upa de cada cor entre 1 e N. Um Upa de cor i possui raridade igual a 2i. Dada a coleção atual de Upas de Mayuri, informe quais Upas ela deve manter na sua coleção de modo que todos os Upas possuem cores que combinam entre si e tal que a soma das raridades de todos os Upas é maior possível.\nEntrada\nA primeira linha da entrada contém dois números inteiros N e M, indicando respectivamente o número de Upas e o tamanho da lista de pares de cores que não combinam. As próximas M linhas contêm, cada uma, dois inteiros U e V , indicando que as cores U e V não combinam.\nSaída\nSeu programa deve produzir duas linhas de saída. A primeira linha da saída é composta por um inteiro Q indicando a quantidade de Upas que Mayuri deve manter na coleção. A segunda linha da saída deve ser composta por Q inteiros, indicando quais Upas ela manter na coleção, em ordem crescente de cor.\nRestrições\n• 1 ≤ N,M ≤ 105.\n• 1 ≤ U,V ≤ N e U (cid:54)= V • Mayuri possui exatamente um Upa para cada cor entre 1 e N • É garantido que existe exatamente uma única resposta Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ N ≤ 10 e 1 ≤ M ≤ 15.\n• Para um conjunto de casos de testes valendo outros 20 pontos, 1 ≤ N ≤ 15 e 1 ≤ M ≤ 30.\n• Para um conjunto de casos de testes valendo outros 20 pontos, 1 ≤ N,M ≤ 1000.\n• Para um conjunto de casos de testes valendo outros 40 pontos, não existem restrições adicionais.",
    "examples": [
      [
        "10 4\n10 9\n8 7\n8 6\n1 2",
        "6\n2 3 4 5 8 10"
      ],
      [
        "13 19\n12 1\n12 2\n12 3\n12 4\n10 5\n13 6\n3 7\n1 8\n1 9\n11 10\n7 11\n12 13\n1 5\n9 13\n6 2\n8 11\n8 7\n11 3\n7 12",
        "5\n2 4 5 11 13"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "colecao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Linhas de Ônibus",
    "description": "Nessa grande cidade na China, há T terminais de ônibus, numerados de 1 a T; e L linhas de ônibus,numeradas de 1 a L. Os mapas são muito confusos mas conseguimos entender que os ônibus de uma linha fazem viagens circulares passando por um conjunto fixo de terminais. Por exemplo, a tabela seguinte indica o conjunto de terminais por onde passam os ônibus de cada linha, para T = 10 e L = 5:   Não estamos preocupados com o trajeto da linha, com a ordem na qual o ônibus passa pelos terminais. Portanto, para ir do terminal 2 para o terminal 4, precisamos apenas tomar um ônibus da linha 1 e esperar até ele chegar no terminal 4. O sistema garante que é possível viajar entre qualquer par de terminais, mas talvez seja preciso trocar de linha de ônibus algumas vezes.\nNós estamos com medo de tomar um ônibus errado e acabar perdidos na cidade. É tudo muito grande na China! Por isso, queremos trocar de ônibus o menor número possível de vezes. Por exemplo, você pode ir do terminal 2 para o terminal 10 primeiro tomando a linha 1 até o terminal 1, depois a linha 3 até o terminal 5 e, por fim, a linha 2 até o terminal 10; trocando de ônibus duas vezes, usando três linhas no total. Só que dá para ir do terminal 2 para o 10 trocando apenas uma vez: primeiro tomando a linha 1 até o terminal 8 e depois a linha 4 até o terminal 10.\nNeste problema, dados os conjuntos de terminais de cada linha, um terminal origem e um terminal destino, seu programa deve computar o número mínimo possível de linhas de ônibus para fazer a viagem.\nEntrada\nA primeira linha da entrada contém quatro inteiros, T, L, O e D, representando, respectivamente, o número de terminais, o número de linhas de ônibus, o terminal origem e o terminal destino. As últimas L linhas da entrada descrevem, cada uma, o conjunto de terminais pelos quais uma linha de ônibus passa. A i-ésima linha (dessas últimas L linhas da entrada) descreve o conjunto de terminais da linha de ônibus i, no seguinte formato: o primeiro inteiro na linha, C, indica o número de terminais no conjunto. Depois desse inteiro, o restante da linha da entrada contém C inteiros distintos representando os terminais.\nSaída\nSeu programa deve produzir uma única linha, contendo apenas um inteiro, o número mínimo possível de linhas de ônibus para viajar do terminal O para o terminal D.\nRestrições\n• 2 ≤ T ≤ 500 • 1 ≤ L ≤ 500 • 2 ≤ C ≤ T • O (cid:54)= D Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 5 pontos, L = 2 • Em um conjunto de casos de teste somando outros 5 pontos, T = 3 • Em um conjunto de casos de teste somando outros 10 pontos, T ≤ 10 • Em um conjunto de casos de teste somando outros 20 pontos, T ≤ 100 • Em um conjunto de casos de teste somando outros 20 pontos, C ≤ 10 • Em um conjunto de casos de teste somando os demais 40 pontos, nenhuma restrição adicional Exemplos",
    "examples": [
      [
        "10 5 2 10\n5 4 3 8 2 1\n3 5 10 7\n2 1 5\n3 6 8 10\n3 9 4 5",
        "2"
      ],
      [
        "2 1 1 2\n2 2 1",
        "1"
      ],
      [
        "10 9 1 10\n2 1 2\n2 2 3\n2 3 4\n2 4 5\n3 5 6 7\n2 6 7\n2 7 8\n2 8 9\n2 9 10",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "linhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Etiquetas",
    "description": "etiquetas_py2.py ou etiquetas_py3.py Uma fita esticada horizontalmente é composta de N quadrados de dimensão 1 × 1, cada um deles contendo um número inteiro anotado. Temos também K etiquetas retangulares idênticas, de dimensão 1 × C, onde C é um inteiro. Nosso objetivo é colar todas as etiquetas sobre a fita de modo que a soma dos inteiros que não estiverem cobertos por nenhuma etiqueta ao final seja a máxima possível. Cada etiqueta deve ser colada na horizontal, ao longo da fita. Duas etiquetas não podem estar sobrepostas e cada quadrado da fita deve estar ou totalmente coberto por uma etiqueta, ou totalmente descoberto.\nEntrada\nA primeira linha da entrada contém três inteiros N, K e C, representando, respectivamente, o comprimento da fita, o número de etiquetas e o comprimento das etiquetas. A segunda linha da entrada contém N inteiros A indicando a sequência de números anotados nos quadrados da fita.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro indicando a soma máxima possível de inteiros descobertos na fita depois que todas as etiquetas sejam coladas seguindo as condições do enunciado.\nRestrições\n• 1 ≤ N ≤ 10000 • −10000 ≤ A ≤ 10000 • 1 ≤ K ≤ 10000 • 1 ≤ C ≤ 10000 • K × C ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, os números no vetor estão ordenados crescentemente.\n• Para um conjunto de casos de testes valendo outros 10 pontos, C = 1.\n• Para um conjunto de casos de testes valendo outros 20 pontos, K = 1.\n• Para um conjunto de casos de testes valendo outros 20 pontos, K,N ≤ 100.",
    "examples": [
      [
        "12 2 3\n1 22 4 -8 9 2 10 -1 5 5 32 -11",
        "58"
      ],
      [
        "1 1 1\n10000",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "etiquetas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Exploração do Capitão Levi",
    "description": "exploracao_py2.py ou exploracao_py3.py O Capitão Levi está indo para mais uma expedição pela tropa de exploração e, como sempre, ele resolveu olhar o mapa do local que ele e sua equipe estavam a caminho para que pudessem criar a melhor estratégia possível. Como todos sabem, a tropa de exploração é responsável por enfrentar titãs e deixar os habitantes da cidade mais protegidos.\nO mapa do local pode ser resumido a um plano cartesiano e os titãs podem ser representados como pontos nesse plano. No entanto, seu dispositivo de manobra bidimensional(DMB) está defeituoso e agora Levi só consegue se locomover de um titã para outro titã durante o combate se eles estão em uma determinada direção, um em relação ao outro.\nSe existe um titã no ponto A = (Xa,Ya) e um outro titã no ponto B = (Xb,Yb) ele consegue ir de A pra B se o coeficiente angular da reta que passa pelos pontos A e B for maior ou igual a P . Observe Q que os pontos A e B devem ser distintos e que não existem pontos com a mesma coordenada X.\nLevi quer contar quantos pares de pontos distintos A e B existem, tais que há um titã em A e em B e ele consegue ir de A para B, ou seja XY aa−− XYb b ≥ QP .\nNo entanto, existem muitos titãs no mapa e por isso Levi pediu sua ajuda para contabilizar os pares, lembrando que o par (A,B) e (B,A) são o mesmo par, ou seja, a ordem dos pontos não faz diferença.\nEntrada\nA primeira linha da entrada contém três números inteiros N, P e Q, indicando respectivamente a quantidade de titãs, e os dois inteiros descritos no enunciado. Cada uma das N linhas seguintes contém dois inteiros X e Y , indicando as coordenadas de um titã.\nSaída\nA saída consiste em um único número inteiro, representando a quantidade de pares de titãs entre os quais Levi pode se locomover respeitando as condições do enunciado.\nRestrições\n• 2 ≤ N ≤ 5 ∗ 105 • −109 ≤ P,Q ≤ 109 • P (cid:54)= 0 e Q (cid:54)= 0 • 1 ≤ X,Y ≤ 107 • Não existem dois titãs com a mesma coordenada X Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 15 pontos, 2 ≤ N ≤ 103, P = 1 e Q = 1.\n• Para um conjunto de casos de testes valendo 20 pontos, 2 ≤ N ≤ 6 ∗ 104, P = 1 e Q = 1.\n• Para um conjunto de casos de testes valendo 15 pontos, todos os titãs estão sobre uma mesma reta.\n• Para um conjunto de casos de testes valendo 20 pontos, P > 0 e Q > 0.\n• Para um conjunto de casos de testes valendo 30 pontos, não há restrições adicionais.",
    "examples": [
      [
        "6 1 1\n1 1\n4 6\n2 5\n8 2\n7 1\n6 10",
        "6"
      ],
      [
        "6 1 1\n7 7\n1 1\n2 2\n16 16\n11 11\n200 200",
        "15"
      ],
      [
        "8 418732 641936\n60693 28595\n15649 57089\n77335 92158\n57291 25242\n21420 56599\n62278 58106\n52009 12362\n41982 64916",
        "11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "exploracao"
    },
    "imagesQuant": 1
  },
  {
    "name": "Mesa redonda",
    "description": "Ana, Beatriz e Carolina sempre saem juntas para tomar café numa padaria onde as mesas são circulares e têm três cadeiras numeradas 0, 1 e 2, no sentido anti-horário, como ilustrado na figura ao lado.\nElas gostam de decidir quem vai sentar em qual cadeira com 2 uma brincadeira gerando números aleatórios nos seus celulares. Primeiro Ana sorteia um número inteiro A e, começando da cadeira 1, seguindo no sentido anti-horário, conta A cadeiras e senta na cadeira em que a contagem terminar.\nDepois Beatriz sorteia um número B e faz a mesma coisa: começando da cadeira 1, no sentido anti-horário, conta B 00 1 cadeiras. Se a cadeira final estiver livre, Beatriz senta nela.\nCaso seja a cadeira onde Ana está sentada, então Beatriz senta na próxima cadeira no sentido anti-horário. Claro, ao final, Carolina senta na cadeira que estiver livre.\nPor exemplo, se Ana sortear 8, ela vai contar [1,2,0,1,2,0,1,2] e sentar na cadeira 2. Depois, se Beatriz sortear 6, ela vai contar [1,2,0,1,2,0] e sentar na cadeira 0. Assim, Carolina senta na cadeira 1. Num outro exemplo, se Ana sortear 3, ela vai contar [1,2,0] e sentar na cadeira 0. Depois, se Beatriz sortear 9, ela vai contar [1,2,0,1,2,0,1,2,0] e, como Ana já está sentada na cadeira 0, Beatriz senta na cadeira 1. Dessa forma, Carolina senta na cadeira 2.\nNeste problema, dados os números sorteados por Ana e Beatriz, seu programa deve imprimir o número da cadeira onde Carolina vai sentar.\nEntrada\nA primeira linha da entrada contém um inteiro A representando o número sorteado por Ana. A segunda linha da entrada contém um inteiro B representando o número sorteado por Beatriz.\nSaída\nSeu programa deve imprimir uma linha contendo um número inteiro indicando a cadeira onde Carolina vai sentar.\nRestrições\n• 1 ≤ A ≤ 1000 • 1 ≤ B ≤ 1000",
    "examples": [
      [
        "8\n6",
        "1"
      ],
      [
        "3\n9",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "mesa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Metrô da Nlogônia",
    "description": "Há dois sistemas de metrô na capital da Nlogônia, operados por duas empresas diferentes. O dois sistemas, denominados Círculo e Quadrado, são independentes e não conectados entre si, ou seja, não há nenhuma estação em comum e nenhum trilho em comum. Em cada sistema há exatamente um caminho possível entre duas estações quaisquer, possivelmente passando por outras estações do sistema. A figura abaixo mostra uma representação de dois sistemas de metrô independentes, similares ao metrô da capital da Nlogônia. Apropriadamente, no sistema Círculo as estações são representadas por círculos, e no sistema Quadrado as estações são representadas por quadrados.\n2 4 6 4 3 2 5 1 3 5 7 6 1 Vamos chamar de diâmetro do sistema de metrô o maior número de estações no trajeto entre qualquer par de estações do sistema. Assim, o diâmetro do sistema Círculo na figura acima é cinco (trajeto 2-3-4-5-7 por exemplo) e o diâmetro do sistema Quadrado é quatro (trajeto 4-3-5-6 por exemplo).\nO rei da Nlogônia decidiu que os dois sistemas existentes devem ser integrados, para facilitar a vida dos usuários. A integração vai ser implementada através da construção de um único novo trecho de metrô ligando exatamente um par de estações existentes (uma estação do sistema Círculo e uma estação do sistema Quadrado). O rei determinou ainda que o diâmetro do sistema integrado seja o menor possível.\nVocê pode ajudar a planejar a integração dos sistemas? Dadas as descrições dos dois sistemas, sua tarefa é determinar qual par de estações deve ser ligado para realizar a integração como desejada pelo rei.\nEntrada\nA primeira linha contém dois inteiros N e M, indicando respectivamente o número de estações do sistema Círculo e do sistema Quadrado. No sistema Círculo as estações são identificadas por números de 1 a N e no sistema Quadrado as estações são identificadas por números de 1 a M. Cada uma das N −1 linhas seguintes descreve as ligações entre estações do sistema Círculo e contém dois inteiros A e B indicando que existe uma ligação entre as estações A e B. Cada uma das M − 1 linhas seguintes descreve as ligações entre estações do sistema Quadrado e contém dois inteiros X e Y indicando que existe uma ligação entre as estações X e Y .\nSaída\nSeu programa deve produzir dois inteiros, o primeiro representando uma estação do sistema Círculo e o segundo representando uma estação do sistema Quadrado. Se houver mais de um par possível, indique qualquer um entre os possíveis.\nRestrições\n• 2 ≤ N,M ≤ 105 • 1 ≤ A,B ≤ N • 1 ≤ X,Y ≤ M Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N,M ≤ 100.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N,M ≤ 1000.",
    "examples": [
      [
        "7 6\n1 3\n3 2\n3 4\n4 5\n5 7\n6 5\n1 3\n2 3\n3 4\n3 5\n5 6",
        "4 3"
      ],
      [
        "3 4\n1 2\n2 3\n1 2\n2 3\n3 4",
        "2 2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "metro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Grand Prix da Nlogônia",
    "description": "A Nlogônia irá realizar o Grand Prix de corrida de carros. Foram dados planos de construção de um circuito para a realização do evento e você ficou responsável pela avaliação do plano. Um grafo direcionado de N vertices e M arestas é considerado um Grand Prix se existe algum ciclo direcionado, ou seja, existe um vertice P e um caminho direcionado saindo de P que chega novamente em P.\nA Nlogônia pode ser representada como um grafo direcionado que contêm N esquinas, numeradas de 1 a N. Foram dados para você M planos de construção, cada um contendo três inteiros U,L e R, que significa o seguinte: caso esse plano seja aceito, será construída uma estrada direcionada da esquina U para a esquina i, para todo L ≤ i ≤ R. Sua tarefa é computar o menor inteiro X tal que aceitando todos os planos de 1 até X, teremos um Grand Prix em Nlogônia.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, representando, respectivamente, o número de esquinas e o número de planos. As M linhas seguintes contêm, cada uma, três inteiros U,L e R, descrevendo um plano de construção.\nSaída\nImprima um inteiro X, o menor inteiro tal que aceitando todos os planos de 1 até X, inclusive, conseguiremos um Grand Prix. Caso Nlogônia não consiga realizar o Grand Prix, imprima −1.\nRestrições\n• 2 ≤ N ≤ 200000 • 1 ≤ M ≤ 200000 • 1 ≤ L ≤ R ≤ N • 1 ≤ U ≤ N • É garantido que não existe uma aresta de um vertice indo para ele mesmo.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste valendo 10 pontos, N ≤ 200000, M ≤ 200000 e L = R para todo plano.\n• Em um conjunto de casos de teste valendo 10 pontos, N ≤ 1000, M ≤ 500.\n• Em um conjunto de casos de teste valendo 10 pontos, N ≤ 500, M ≤ 20000.\n• Em um conjunto de casos de teste valendo 25 pontos, N ≤ 200000, M ≤ 200000 e é garantido que L = 1 para todo plano.\n• Em um conjunto de casos de teste valendo 45 pontos, nenhuma restrição adicional.",
    "examples": [
      [
        "8 6\n5 6 8\n3 1 2\n6 2 4\n1 4 5\n8 4 7\n2 3 6",
        "4"
      ],
      [
        "2 2\n1 2 2\n2 1 1",
        "2"
      ],
      [
        "5 6\n1 2 5\n3 4 5\n5 2 2\n1 2 4\n3 4 5\n4 2 2",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "prix"
    },
    "imagesQuant": 0
  },
  {
    "name": "Computador",
    "description": "computador_py2.py ou computador_py3.py Uma grande empresa está construindo uma nova arquitetura de computadores que permita a execução eficiente de duas instruções especiais de soma. O computador possui N posições de memória, endereçadas de 1 a N, e cada posição pode guardar um inteiro maior ou igual a zero. Inicialmente, todas as posições contêm o valor zero. As instruções especiais de soma são: • FRENTE i V : Dado o endereço i, 1 ≤ i ≤ N, e um valor positivo V , o computador deve somar V na posição i, V − 1 em i + 1, V − 2 em i + 2, etc, enquanto o valor a ser somando for maior do que zero e a posição for menor ou igual a N; • TRÁS i V : Dado o endereço i, 1 ≤ i ≤ N, e um valor positivo V , o computador deve somar V na posição i, V −1 em i−1, V −2 em i−2, etc, enquanto o valor a ser somando for maior do que zero e a posição for maior ou igual a 1.\nPor exemplo, para N = 16, uma possível sequência de instruções é dada abaixo:   FRENTE 4 8   TRÁS 16 3   TRÁS 2 12   FRENTE 8 7   Além disso, o computador possui a instrução IMPRIME i, que deve imprimir na saída o valor atual armazenado na posição i da memória.\nDados N e uma sequência de M instruções, seu programa deve imprimir, para cada instrução do tipo IMPRIME i, uma linha contendo o valor armazenado na posição de memória i no instante da execução da instrução.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, representando o número de posições de memória e o número de instruções, respectivamente. As M linhas seguintes contêm, cada uma, a descrição de uma instrução em uma de três formas possíveis: 1 I V , representando FRENTE I V ; 2 I V , representando TRÁS I V ; e 3 I, representando IMPRIME I.\nSaída\nPara cada instrução do tipo IMPRIME i, seu programa deve imprimir uma linha contendo um inteiro representando o valor armazenado na posição de memória i no instante da execução da instrução.\nRestrições\n• 1 ≤ N ≤ 200000; • 1 ≤ M ≤ 200000; • 1 ≤ I ≤ N; • 1 ≤ V ≤ 200000; • Ao menos uma instrução será do tipo 3.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 10000, M ≤ 10000 e V ≤ 10000; Exemplos",
    "examples": [
      [
        "16 7\n1 4 8\n2 16 3\n3 14\n2 2 12\n1 8 7\n3 10\n3 14",
        "1\n7\n2"
      ],
      [
        "200000 2\n1 2345 193290\n3 112230",
        "83405"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "computador"
    },
    "imagesQuant": 0
  },
  {
    "name": "Xadrez Aleatório",
    "description": "Xadrez Aleatório de Fischer, ou Xadrez 960, é uma variante do jogo de Xadrez que usa exatamente as mesmas regras com uma única exceção, a posição inicial das peças é sorteada antes do jogo. As peças da primeira linha do tabuleiro podem estar em qualquer posição desde que respeitem duas restrições: o rei deve estar entre as duas torres; e os dois bispos devem estar em casas de cores opostas. Como você já deve ter desconfiado, o número de posições iniciais válidas nessa variante do Xadrez é 960.\nNeste problema queremos contar o número de posições iniciais válidas numa outra variante, bem mais simples. A dimensão do tabuleiro não é mais fixa. Para qualquer dimensão, a primeira linha do tabuleiro vai conter apenas três tipos de peças: rei, torre e peão. Haverá sempre exatamente um rei e no máximo duas torres. O número de peões será a dimensão menos a soma do número das demais peças. Se o número de torres for dois, então o rei deve estar entre as duas torres. A figura abaixo mostra uma posição inicial válida para N = 8.\nEntrada\nA entrada consiste de apenas uma linha contendo dois inteiros, N e T, representando, respectivamente, a dimensão do tabuleiro e o número de torres.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro indicando o número de posições iniciais válidas.\nRestrições\n• 2 ≤ N ≤ 1000 • 0 ≤ T ≤ 2 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, T = 0.\n• Para um conjunto de casos de testes valendo outros 20 pontos, T = 1.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N = 4.",
    "examples": [
      [
        "2 0",
        "2"
      ],
      [
        "8 1",
        "56"
      ],
      [
        "213 2",
        "1587986"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2019,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "xadrez"
    },
    "imagesQuant": 0
  },
  {
    "name": "Entrega de Caixas",
    "description": "Você precisa transportar três caixas vazias usando um drone que pode levantar uma caixa por vez apenas em cada viagem. Quer dizer, sempre dá para transportar as três caixas vazias fazendo três viagens do drone. Mas talvez dê para fazer menos do que três viagens, se for possível colocar uma caixa dentro de outra. As caixas têm formato de cubo e a única restrição para uma caixa ser colocada dentro de outra é o tamanho, não importando o peso.\nUma caixa de tamanho X pode ser colocada dentro de uma caixa de tamanho Y se X < Y . Note, portanto, que uma caixa não cabe dentro de outra do mesmo tamanho. Além disso, duas caixas de tamanhos X e Y podem ser colocadas, lado a lado, dentro de uma caixa de tamanho Z se (X + Y ) < Z.\nA figura ilustra as quatro configurações possíveis para o drone fazer uma viagem.\nNeste problema, os tamanhos das três caixas são dados em ordem crescente e seu programa deve computar o número mínimo de viagens que o drone pode fazer para transportar todas as três caixas.\nEntrada\nA primeira linha da entrada contém um inteiro A. A segunda linha da entrada contém um inteiro B. A terceira linha da entrada contém um inteiro C. Os três inteiros representam os tamanhos das três caixas.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro, representando o número mínimo de viagens que o drone pode fazer para transportar todas as três caixas.\nRestrições\n• 1 ≤ A ≤ B ≤ C ≤ 1000 Exemplos",
    "examples": [
      [
        "12\n45\n188",
        "1"
      ],
      [
        "67\n67\n67",
        "3"
      ],
      [
        "111\n463\n463",
        "2"
      ],
      [
        "72\n72\n345",
        "1"
      ],
      [
        "30\n30\n55",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caixas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Escher",
    "description": "M. C. Escher foi um artista gráfico holandês que fazia incríveis ilustrações onde preenchia a tela com objetos auto-similares, cujos contornos encaixam neles próprios, criando simetrias geométricas muito impressionantes. Veja um exemplo dessa ideia na figura, que mostra um objeto que é um perfil ortogonal definido por uma sequência de números naturais representando a sequência de alturas. Podemos pegar uma cópia do objeto, rotacionar 180 graus e encaixar perfeitamente no objeto original, formando um retângulo.\n3 6 6 4 3 2 8 7 6 4 4 7 Em termos mais gerais, se uma sequência de N números naturais representando a sequência de alturas for A1,A2,A3,...,AN−2,AN−1,AN, o perfil definido será chamado de perfil Escher se tivermos A1 + AN igual a A2 + AN−1 igual a A3 + AN−2, e assim por diante. Neste problema, será dada a sequência de alturas que definem o perfil e seu programa deve decidir se o perfil é Escher, ou não.\nEntrada\nA primeira linha da entrada contém um número N, indicando quantos números tem a sequência. A segunda linha da entrada contém N números naturais, Ai, para 1 ≤ i ≤ N, definindo a sequência de alturas do perfil.\nSaída\nSeu programa deve imprimir uma linha contendo o caractere S, se o perfil for Escher; ou N, senão.\nRestrições\n• 3 ≤ N ≤ 10000.\n• 1 ≤ Ai ≤ 1000, para todo 1 ≤ i ≤ N.\nInformações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N = 3.\n• Em um conjunto de casos de teste somando 80 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "12\n3 6 6 4 3 2 8 7 6 4 4 7",
        "S"
      ],
      [
        "5\n2 1 9 13 12",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "escher"
    },
    "imagesQuant": 0
  },
  {
    "name": "Piloto Automático",
    "description": "Uma grande fábrica de carros elétricos está realizando melhorias no sistema de piloto automático e precisa da sua ajuda para implementar um programa que decida se um carro B, que está trafegando no meio de dois carros A e C, precisa acelerar, desacelerar ou manter a velocidade atual. Os carros são iguais e os sensores do piloto automático vão fornecer, como entrada, a posição atual da traseira dos três carros. Veja um exemplo na figura.\nA B C O carro B precisa ser acelerado se a distância da sua traseira para a traseira do carro A for menor do que a distância da sua traseira para a traseira do carro C. Se for maior, ele precisa ser desacelerado.\nSe for igual, precisa manter a velocidade atual. Quer dizer, o carro B precisa ser acelerado se (B − A) < (C − B), desacelerado se (B − A) > (C − B) e manter a velocidade se (B − A) for igual a (C − B).\nEntrada\nA primeira linha da entrada contém um inteiro A. A segunda linha da entrada contém um inteiro B. A terceira linha da entrada contém um inteiro C. Os três inteiros representam as posições atuais das traseiras dos carros A, B e C, respectivamente.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro: 1 se o carro B precisa acelerar; −1 se precisa desacelerar; ou 0 se precisa manter a velocidade atual.\nRestrições\n• 0 ≤ A < B < C ≤ 500 Exemplos",
    "examples": [
      [
        "10\n23\n38",
        "1"
      ],
      [
        "105\n212\n319",
        "0"
      ],
      [
        "80\n120\n132",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "piloto"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fissura Perigosa",
    "description": "A erupção do vulcão Kilauea em 2018 no Havaí atraiu a atenção de todo o mundo. Inicialmente a força da erupção era menor e a lava avançou para o sul com relativamente poucos danos. Após algumas semanas, porém, a fissura 8 começou a jorrar com mais força e a lava avançou também para o norte trazendo muita destruição.\nVocê está ajudando na implementação de um sistema para simular a área por onde a lava avançaria, em função da força da erupção. O mapa será representado simplificadamente por uma matriz quadrada de caracteres, de 1 a 9, indicando a altitude do terreno em cada posição da matriz. Vamos considerar que a fissura 8, por onde a erupção se inicia, está sempre na posição do canto superior esquerdo da matriz. Dada a força da erupção, que será um valor inteiro, de 0 a 9, seu programa deve imprimir a matriz de caracteres representando o avanço final da lava. Se a lava consegue invadir uma posição da matriz, o caractere naquela posição deve ser trocado por um asterisco (‘*’). Uma posição será invadida pela lava se seu valor for menor ou igual à força da erupção e • for a posição inicial; ou • estiver adjacente, ortogonalmente (abaixo, acima, à esquerda ou à direita), a uma posição invadida.\nA figura abaixo mostra um exemplo de mapa e o avanço final da lava para quatro forças de erupção: 1, 3, 6 e 8, respectivamente da esquerda para a direita.\n27755478 *7755478 *7755478 ******** 29985439 *9985439 *9985439 *99****9 34899989 *4899989 **899989 ***999*9 22115569 ****5569 *******9 *******9 66736689 667*6689 **7***89 *******9 99886555 99886555 9988**** 99****** 44433399 44433399 ******99 ******99 99986991 99986991 9998*991 999**991 Entrada\nA primeira linha da entrada contém dois inteiros N e F representando, respectivamente o número de linhas (que é igual ao de colunas) da matriz e a força da erupção. Cada uma das N linhas seguintes contém uma string de N caracteres, entre 1 e 9, indicando o mapa de entrada.\nSaída\nSeu programa deve imprimir N linhas contendo, cada uma, N caracteres representando o avanço final da lava de acordo com o enunciado.\nRestrições\n• 1 ≤ N ≤ 500 • 0 ≤ F ≤ 9 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 10.\n• Em um conjunto de casos de teste somando 20 pontos, 10 < N ≤ 100.\n• Em um conjunto de casos de teste somando 60 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "8 6\n27755478\n29985439\n34899989\n22115569\n66736689\n99886555\n44433399\n99986991",
        "*7755478\n*9985439\n**899989\n*******9\n**7***89\n9988****\n******99\n9998*991"
      ],
      [
        "5 4\n25679\n35234\n17182\n39993\n11223",
        "*5679\n*5***\n*7*8*\n*999*\n*****"
      ],
      [
        "2 8\n91\n11",
        "91\n11"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fissura"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pandemia",
    "description": "Um grupo de amigos, preocupados por ter que prestar o ENEM este ano, resolveu iniciar o ano fazendo reuniões de estudo. Mas eles não esperavam que uma epidemia com um novo vírus ocorresse na região em que moravam. Nessa epidemia específica, os sintomas da doença aparecem muitos dias depois do contágio, mas mesmo sem sintomas uma pessoa infectada infecta todos com quem tenha o mínimo contato.\nO grupo de amigos também não sabia que um deles havia sido infectado, sem saber, por pessoas de fora do grupo, o que fez a infecção se espalhar pelos amigos do grupo. Felizmente todos os amigos infectados se recuperaram e passam bem.\nMuitas reuniões de estudo aconteceram, mas nem todos os amigos participaram de todas as reuniões.\nVocê receberá a informação de quais amigos participaram de cada reunião. Além disso, você receberá também a informação de qual amigo participou de reunião do grupo após ter sido infectado por pessoas de fora do grupo, e em qual reunião isso ocorreu. Você deve assumir que: 1. todos os amigos que participaram de reunião em que ao menos um deles estava infectado também foram infectados.\n2. o único amigo infectado por pessoas de fora do grupo é o que foi informado. No caso de todos os outros amigos que foram infectados a infecção aconteceu em reunião do grupo.\nEscreva um programa para determinar quantos amigos, ao final da sequência de reuniões, foram infectados.\nEntrada\nA primeira linha da entrada contém dois números inteiros N, M, respectivamente o total de amigos do grupo e o total de dias em que houve reunião. Os amigos são identificados por números inteiros de 1 a N, as reuniões são identificadas por números inteiros de 1 (primeira reunião) a M (última reunião). A segunda linha contém dois números inteiros I e R, respectivamente o identificador do amigo que foi infectado por pessoas de fora do grupo e o número da primeira reunião em que ele participou infectado. Cada uma das M linhas seguintes contém a informação dos participantes de uma reunião, em sequência; ou seja, a primeira linha descreve os participantes da reunião 1, a segunda linha descreve os participantes da reunião 2 e assim por diante. Cada uma dessas linhas inicia com um número A, o total de amigos que participaram dessa reunião, seguido de A inteiros Pi identificando cada amigo participante da reunião.\nSaída\nSeu programa deve produzir um inteiro representando o número total de amigos infectados ao final do mês.\nRestrições\n• 2 ≤ N ≤ 1000 • 2 ≤ M ≤ 1000 • 1 ≤ I ≤ N • 1 ≤ R ≤ M • 1 ≤ A ≤ N • 1 ≤ Pi ≤ N para 1 ≤ i ≤ A Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 10 e M ≤ 10.\n• Para um conjunto de casos de testes valendo 60 pontos, 10 < N ≤ 500 e 10 < M ≤ 500.\n• Para um conjunto de casos de testes valendo 20 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "4 3\n2 1\n2 1 2\n3 3 1 2\n2 2 1",
        "3"
      ],
      [
        "5 6\n3 4\n2 1 3\n4 1 2 3 5\n2 1 3\n2 1 3\n2 4 5\n2 2 4",
        "2"
      ],
      [
        "10 5\n2 1\n6 7 5 1 9 6 2\n3 9 4 6\n3 2 9 5\n3 8 5 7\n2 8 9",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pandemia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Acelerador de Partículas",
    "description": "A universidade está inaugurando um grande acelerador de partículas, com um emissor e três sensores, numerados 1, 2 e 3. Uma partícula, após sair do emissor, entra no acelerador onde pode dar várias voltas sendo acelerada a velocidades muito altas. Num determinado momento, a partícula sai do acelerador por uma das três saídas, atingindo um dos sensores. A figura mostra o caminho por onde as partículas trafegam, com uma graduação de 1 quilômetro. Por exemplo, do emissor até o acelerador são 3 quilômetros e a circunferência do acelerador tem 8 quilômetros.\n3 2 1 emissor Neste problema, será dada a distância total, em quilômetros, percorrida por uma certa partícula trafegando do emissor até algum sensor e seu programa deve determinar qual sensor foi atingido pela partícula. Por exemplo, veja que se a distância total for 23 quilômetros, então a partícula tem que ter atingido o sensor 2.\nEntrada\nA entrada consiste de apenas uma linha contendo um inteiro D, representando a distância total percorrida pela partícula.\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro, representando o número do sensor que a partícula atingiu.\nRestrições\n• 6 ≤ D ≤ 800008. D sempre será a distância total percorrida entre o emissor e algum sensor.\nExemplos",
    "examples": [
      [
        "23",
        "2"
      ],
      [
        "6",
        "1"
      ],
      [
        "9192",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "acelerador"
    },
    "imagesQuant": 0
  },
  {
    "name": "Promoção de Primeira",
    "description": "O reino da Linearlândia possui N cidades espalhadas por seu vasto território, sendo que N − 1 pares distintos de cidades estão ligados diretamente por uma rodovia bi-direcional. Esses pares foram escolhidos de forma que existe exatamente um caminho entre qualquer par de cidades, possivelmente passando por outras cidades no meio do caminho. Cada rodovia da Linearlândia é servida por uma linha de ônibus, que faz viagens de ida e volta entre as duas cidades, operada por apenas uma empresa, como manda a lei determinada pelo Rei. O problema é que existem apenas duas empresas de ônibus: a RoyalBus e a ImperialBus.\nCada viagem entre duas cidades ligadas diretamente por uma rodovia custa uma passagem da empresa que opera aquela linha. Ao chegar numa cidade, se o passageiro quiser prosseguir viagem para outra cidade, ele tem que desembarcar, entrar em outro ônibus e pagar outra passagem. Só que o Rei determinou, para o feriadão anual de celebração da Linearidade Real, uma estranha promoção: sempre que o passageiro entrar no ônibus de uma empresa ele não precisa pagar a passagem se sua viagem imediatamente anterior foi pela outra empresa. Quer dizer, se o caminho alterna entre a RoyalBus e a ImperialBus, só é preciso pagar uma passagem, a primeira.\nNeste problema, dada a descrição da malha de rodovias da Linearlândia, seu programa deve computar o número máximo de cidades num caminho, começando em qualquer cidade, para o qual é preciso pagar apenas uma passagem para ir da cidade inicial até a cidade final do caminho. O número de cidades no caminho inclui a cidade inicial e a cidade final.\nEntrada\nA primeira linha da entrada contém um inteiro N, representando o número de cidades da Linearlândia. As cidades são numeradas de 1 até N. As N − 1 linhas seguintes contêm, cada uma, três inteiros A, B e E, indicando que existe uma rodovia entre as cidades A e B e que a linha de ônibus entre elas é operado pela empresa E (0 para RoyalBus, 1 para ImperialBus).\nSaída\nSeu programa deve imprimir uma linha contendo um inteiro representando o número máximo de cidades num caminho para o qual é preciso pagar apenas uma passagem durante a celebração da Linearidade Real.\nRestrições\n• 2 ≤ N ≤ 50000 • 1 ≤ A ≤ N • 1 ≤ B ≤ N • 0 ≤ E ≤ 1 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 20 pontos, o número máximo de rodovias chegando em qualquer cidade é dois. Quer dizer, a malha é um longo caminho passando por todas as cidades.\n• Em um conjunto de casos de teste somando 20 pontos, N ≤ 103.\n• Em um conjunto de casos de teste somando 20 pontos, 103 < N ≤ 104.\n• Em um conjunto de casos de teste somando 40 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "8\n3 1 0\n2 7 0\n6 8 1\n1 4 1\n5 4 1\n4 7 1\n7 6 0",
        "4"
      ],
      [
        "2\n1 2 0",
        "2"
      ],
      [
        "18\n13 16 0\n16 15 1\n16 12 0\n14 12 0\n12 8 1\n1 18 0\n1 3 0\n2 3 1\n3 8 1\n11 17 1\n17 10 1\n8 17 0\n6 7 0\n9 7 0\n5 7 1\n4 5 0\n8 5 1",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "promocao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bingo!",
    "description": "O grande prêmio do Bingo de São João será um carro zero-quilômetro. Todo mundo quer ser o primeiro a completar sua cartela, claro. São N cartelas identificadas de 1 até N que contêm, cada uma, K números distintos entre os números naturais de 1 até U, para K < U. Um número, claro, pode aparecer em mais de uma cartela e duas cartelas podem até ser iguais, ter o mesmo conjunto de números. Justamente por isso, veja que pode acontecer empate com mais de uma cartela sendo completada no mesmo instante.\nNeste problema, serão dados na entrada os conjuntos de números de todas as cartelas e a sequência de números sorteados, que será uma permutação dos naturais de 1 até U. Seu programa deve determinar qual ou quais cartelas vão ser completadas primeiro e ganhar o carro.\nPor exemplo, para N = 4, K = 5 e U = 10, com as cartelas dadas pela tabela abaixo, se a sequência de números sorteados for [7,3,5,2,6,1,9,10,4,8], então haverá uma cartela vencedora, a número 3.\n  Entrada\nA primeira linha da entrada contém três inteiros N, K e U representando respectivamente o número de cartelas, quantos números cada cartela contém e o maior natural que pode ocorrer numa cartela.\nAs N linhas seguintes contêm, cada uma, K inteiros distintos Ci, para 1 ≤ i ≤ K, representando o conjunto de números de cada cartela, da cartela 1 até a N. A última linha da entrada contém U inteiros indicando a sequência de números sorteados, uma permutação dos naturais entre 1 e U.\nSaída\nSeu programa deve imprimir uma linha contendo os números identificadores das cartelas vencedoras do carro, em ordem crescente.\nRestrições\n• 1 ≤ N ≤ 1000 • 1 ≤ K ≤ 1000 • 1 ≤ U ≤ 10000 Informações sobre a pontuação\n• Em um conjunto de casos de teste somando 15 pontos, N ≤ 100,K ≤ 50,U ≤ 100, e apenas uma cartela é vencedora.\n• Em um conjunto de casos de teste somando 15 pontos, N ≤ 100,K ≤ 50,U ≤ 100.\n• Em um conjunto de casos de teste somando 30 pontos, N ≤ 100,K ≤ 500,U ≤ 1000.\n• Em um conjunto de casos de teste somando 40 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "4 5 10\n3 10 8 7 2\n4 1 7 10 9\n9 1 5 3 6\n6 8 1 5 7\n7 3 5 6 1 9 2 10 4 8",
        "3"
      ],
      [
        "5 4 9\n1 9 3 2\n4 5 6 7\n2 3 5 4\n2 6 8 1\n2 5 7 9\n1 9 7 4 5 3 2 8 6",
        "1 3 5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bingo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Paciente Zero",
    "description": "Quando ocorre uma epidemia por uma nova espécie de vírus, uma das tarefas dos infectologistas é determinar o Paciente Zero, ou seja, a pessoa que foi infectada primeiro pelo novo vírus. A primeira infecção é geralmente causada por transmissão do novo vírus de algum hospedeiro não humano como morcego, rato, ou macaco, para um humano. Esse primeiro humano infectado então infecta outras pessoas, que por sua vez infectam ainda outras pessoas, e assim surge a epidemia.\nA procura pelo Paciente Zero é feita através de um minucioso trabalho de entrevistas com infectados para determinar quem contaminou quem desde o início da epidemia. Vamos chamar de “cadeia de infecção” a sequência de infecção causada por uma pessoa. Por exemplo, se as entrevistas determinarem que João infectou Clarisse, Clarisse infectou Silvia, e Silvia infectou Rafael, a cadeia de infecção de João é Clarisse → Silvia → Rafael. O Paciente Zero é definido como a pessoa infectada com o vírus que não foi infectada por nenhum outro humano, ou seja, não faz parte da cadeia de infeção de nenhuma outra pessoa. Às vezes não é possível determinar um único Paciente Zero, e nesse caso um grupo de pessoas são designadas como Pacientes Zero.\nNesta tarefa você deve determinar o Paciente ou Pacientes Zero a partir das cadeias de infecção determinadas pelos infectologistas.\nEntrada\nA primeira linha da entrada contém dois números inteiros N e C, respectivamente o total de pessoas infectadas e o número de cadeias de transmissão. As pessoas são identificados por números inteiros de 1 a N. Cada uma das C linhas seguintes contém a informação sobre uma cadeia de transmissão.\nA linha inicia com um número P, o identificador da pessoa infectante, seguido de um número I, o total pessoas nessa cadeia de transmissão, seguido de I inteiros Xi identificando as pessoas na cadeia de transmissão.\nCada pessoa consta, no máximo, de uma cadeia de transmissão. Em outras palavras, se um pessoa aparece uma cadeia de transmissão, ela não aparece em nenhuma outra cadeia de transmissão.\nSaída\nSe houver apenas um Paciente Zero, seu programa deve produzir na saída uma linha contendo o número identificador do Paciente Zero. Se houver K Pacientes Zero, seu programa deve produzir na saída K linhas, cada uma contendo o identificador um Paciente Zero distinto, em ordem crescente do número de identificação dos pacientes.\nRestrições\n• 2 ≤ N ≤ 1000 • 1 ≤ C ≤ N − 1 • 1 ≤ P ≤ N • 1 ≤ I ≤ N − 1 • 1 ≤ Xi ≤ N para 1 ≤ i ≤ I Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 2 ≤ N ≤ 10 e há apenas um Paciente Zero.\n• Para um conjunto de casos de testes valendo 40 pontos, 10 < N ≤ 500.\n• Para um conjunto de casos de testes valendo 40 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "6 2\n3 2 4 1\n1 3 2 5 6",
        "3"
      ],
      [
        "6 3\n4 2 5 3\n2 1 1\n5 1 6",
        "2\n4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "paciente"
    },
    "imagesQuant": 0
  },
  {
    "name": "Palavras Cruzadas",
    "description": "Você já deve ter tentado completar um jogo de palavras cruzadas. Nesse jogo, o jogador deve descobrir um conjunto de palavras através de dicas fornecidas juntamente com um retângulo dividido em quadrados de mesmo tamanho, sendo a maoria quadrados em branco e alguns quadrados pretos.\nCada linha e cada coluna formada pelos quadrados em branco deve ser preenchida por uma palavra, com uma letra em cada quadrado em branco. As palavras das linhas são chamadas de palavras horizontais, as palavras das colunas são chamadas palavras verticais. As palavras horizontais cruzam com as palavras verticais em uma letra comum às duas palavras, vindo daí o nome do jogo.\nNesta tarefa, dadas uma palavra horizontal e uma palavra vertical, você deve encontrar a melhor letra de cruzamento entre elas, que é definida como a letra que produz 1. o cruzamento mais à direita possível na palavra horizontal; 2. se há mais de uma possibilidade de cruzamento com a regra (1), a melhor letra de cruzamento é definida como a que produz o cruzamento mais abaixo possível na palavra vertical.\nA figura abaixo ilustra alguns exemplos. Entre parênteses estão os índices da melhor letra de cruzamento. O índice de uma letra é a posição que ela ocupa na palavra, iniciando com 1 (primeira letra).\nC M R E U N T Z P A T O T R A E A N J O U D L R A T R I T O A E A A P A L A V R A S (1,1) (4,5) (5,4) (8,8) Entrada\nA primeira linha da entrada contém a palavra horizontal. A segunda linha da entrada contém a palavra vertical.\nSaída\nSeu programa deve produzir uma única linha, contendo apenas dois inteiros descrevendo a melhor letra de cruzamento. O primeiro número deve ser o índice da letra de cruzamento na palavra horizontal, o segundo número deve ser o índice da letra de cruzamento na palavra vertical. Se não há letra de cruzamento possível, os dois inteiros devem ser iguais a −1.\nRestrições\n• As palavras são compostas por letras maiúsculas não acentuadas, com comprimento de pelo menos uma letra e de no máximo 1000 letras.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos há exatamente uma possibilidade de cruzamento possível.\n• Para um conjunto de casos de testes valendo 80 pontos adicionais não há restrições adicionais.\nExemplos",
    "examples": [
      [
        "PATO\nPELE",
        "1 1"
      ],
      [
        "ANJO\nMENTORA",
        "4 5"
      ],
      [
        "MENTORA\nANJO",
        "7 1"
      ],
      [
        "URUBU\nPOLIVALENTE",
        "-1 -1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cruzadas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dona Lesma",
    "description": "Dona Lesma é esportista e aventureira e definiu como objetivo deste verão alcançar o topo do muro do jardim em que vive. A cada dia, valente e metodicamente ela sobe exatamente uma certa distância (sempre a mesma a cada dia). Mas a cada noite enquanto dorme Dona Lesma escorrega para baixo uma outra distância (sempre a mesma a cada noite)...\nDadas a altura do muro, a distância que ela sobe a cada dia e a distância que ela desce a cada noite, ajude Dona Lesma a calcular quantos dias ela levará para chegar ao topo do muro.\nEntrada\nA primeira linha contém um inteiro A, a altura do muro. A segunda linha contém um inteiro S, distância que Dona Lesma sobe a cada dia. A terceira linha contém um inteiro D, a distância que Dona Lesma escorrega para baixo a cada noite.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de dias que Dona Lesma demorará para chegar ao topo do muro.\nRestrições\n• 1 ≤ A ≤ 10000 • 1 ≤ D < S ≤ 10000 Exemplos",
    "examples": [
      [
        "4\n2\n1",
        "3"
      ],
      [
        "12\n5\n2",
        "4"
      ],
      [
        "10000\n100\n50",
        "199"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "lesma"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo dos Pinos",
    "description": "O Jogo dos Pinos é um quebra-cabeças que utiliza pinos e um tabuleiro com furos em forma de cruz. Inicialmente há apenas um furo vago, no centro do tabuleiro, e todos os outros furos contém um pino como mostra figura abaixo.\nO objetivo do jogo é remover os pinos do tabuleiro de forma que reste apenas um pino. Para remover um pino é necessário fazer um movimento válido, que é definido da seguinte maneira. O jogador deve escolher um pino, chamado pivô, e uma das quatro direções (acima, abaixo, esquerda, direita) de tal forma que o pivô tenha um outro pino, chamado alvo, como vizinho imediato na direção escolhida e que o pino alvo seja seguido, também na direção escolhida, por um furo vago (chamado de destino). A figura abaixo mostra os quatro possíveis pivôs da configuração inicial do jogo.\nO jogador pode então fazer o pino pivô pular sobre o pino alvo e ocupar o furo destino, removendo o pino alvo do tabuleiro. A figura abaixo mostra um exemplo (a) antes, (b) durante e (c) depois de um movimento válido.\nPivô Alvo Destino Pivô Alvo Destino Pivô Alvo Destino (a) (b) (c) Dada uma configuração de pinos em um tabuleiro, escreva um programa para determinar o número de movimentos válidos possíveis na configuração dada.\nEntrada\nA entrada é composta por sete linhas, cada linha com exatamente sete caracteres. A linhas são identificadas por números de 1 a 7. Os dois primeiros caracteres e os dois últimos caracteres das linhas 1, 2, 6 e 7 são ‘-’ (hífen). Todos os outros caracteres são ou ‘o’ (letra o minúscula) representando um pino, ou ‘.’ (ponto) representando um furo.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de movimentos válidos na configuração da entrada.\nRestrições\n• A seção Entrada\ndescreve as restrições.\nExemplos",
    "examples": [
      [
        "--ooo--\n--ooo--\nooooooo\nooo.ooo\nooooooo\n--ooo--\n--ooo--",
        "4"
      ],
      [
        "--.o.--\n--o.o--\n....o..\n....o..\no.o.o..\n--o.o--\n--o.o--",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pinos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Estrada",
    "description": "Para melhorar a integração com os países vizinhos, o Rei da Nlogônia decidiu que uma nova estrada será construída cruzando o país, da fronteira oeste à fronteira leste. O formato da estrada é uma única reta, que passará pelo centro de algumas cidades.\nO Rei também decidiu que a construção será paga pelo Tesouro Real, mas cada cidade pela qual a estrada passar será responsável pela manutenção do trecho da estrada que constitui a vizinhança da estrada para aquela cidade. A vizinhança da estrada de uma cidade A é definida como todos os pontos da estrada que são mais próximos do centro da cidade A do que do centro de qualquer outra cidade.\nDados o comprimento total da estrada, de fronteira a fronteira, e as distâncias da fronteira oeste até os centros de cada cidade ao longo da nova estrada, escreva um programa para determinar qual a menor vizinhança de estrada entre as cidades pelas quais a estrada vai passar.\nEntrada\nA primeira linha da entrada contém um inteiro T, o comprimento total da estrada. A segunda linha contém um inteiro N, o número de cidades pelas quais a estrada vai passar. Cada uma das N linhas seguintes contém um inteiro Xi, indicando a distância da fronteira oeste até o centro da cidade i.\nNão há cidades nas fronteiras e cada centro de cidade tem uma localização distinta.\nSaída\nSeu programa deve produzir uma única linha, contendo um número real com duas casas após o ponto decimal, a menor vizinhança de estrada entre as cidades pelas quais a estrada vai passar.\nRestrições\n• 3 ≤ T ≤ 106 • 2 ≤ N ≤ 104 • 0 < Xi < T, para 1 ≤ i ≤ N • Xi (cid:54)= Xj, para todo par 1 ≤ i,j ≤ N.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N = 2.\n• Para um conjunto de casos de testes valendo 90 pontos adicionais, nenhuma outra restrição.\nExemplos",
    "examples": [
      [
        "10\n2\n8\n5",
        "3.50"
      ],
      [
        "10\n3\n7\n6\n8",
        "1.00"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "estrada"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dona Formiga",
    "description": "Dona Formiga é uma ótima trabalhadora e todos os dias coleta muitas folhas para seu formigueiro.\nMas no final de semana, quando todas as outras formigas estão descansando, ela gosta de se divertir escorregando pelos túneis do formigueiro.\nO formigueiro de Dona Formiga tem muitos túneis e salões. Cada túnel conecta exatamente dois salões diferentes. Cada salão está a uma altura no formigueiro. Se existe um túnel ligando um salão I a um salão J e o salão I está a uma altura maior do que o salão J, então Dona Formiga pode escorregar do salão I para o salão J usando esse túnel.\nDados o mapa dos túneis do formigueiro, as alturas em que estão os salões e o salão de onde Dona Formiga quer partir, escreva um programa para determinar o maior número de salões que ela pode visitar (não contando o salão do qual ela parte), usando túneis exclusivamente para escorregar entre os salões.\nEntrada\nA primeira linha da entrada contém três inteiros S, T e P, respectivamente o número de salões, o número de túneis e o salão do formigueiro do qual Dona Formiga quer partir. Os salões são numerados de 1 a S. A segunda linha contém S números inteiros Ai, a altura em que o salão i está no formigueiro. Cada uma das T linhas seguintes contém dois inteiros I e J, indicando que há um túnel entre o salão I e o salão J.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o maior número de salões que Dona Formiga pode visitar (não contando o salão do qual ela parte), usando os túneis exclusivamente para escorregar entre os salões do formigueiro.\nRestrições\n• 1 ≤ S ≤ 200 • 1 ≤ T ≤ S × (S − 1)/2 • 1 ≤ P ≤ S • −1000 ≤ Ai ≤ 1000 para 1 ≤ i ≤ S • 1 ≤ I < J ≤ S Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ S ≤ 10.\n• Para um conjunto de casos de testes valendo 80 pontos adicionais, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "4 5 2\n100 150 -50 200\n1 2\n2 4\n1 4\n3 4\n1 3",
        "2"
      ],
      [
        "4 5 3\n100 150 -50 200\n1 2\n2 4\n1 4\n3 4\n1 3",
        "0"
      ],
      [
        "4 5 4\n100 150 -50 200\n1 2\n2 4\n1 4\n3 4\n1 3",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "formiga"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fotografia",
    "description": "Chegou o final do ano, e os alunos resolveram dar um presente para a profa. Vilma: um quadro com a fotografia dos alunos classe. João está pesquisando os preços de molduras em um site da internet, e precisa de sua ajuda. Ele quer encontrar uma moldura tal que • a fotografia seja inteiramente contida dentro na moldura; e • a área da moldura que a fotografia não ocupa seja a menor possível; e • uma moldura pode ser rotacionada para acomodar a fotografia, mas a fotografia deve ser acomodada de forma que seus lados sejam paralelos aos lados da moldura.\nDada as dimensões da fotografia e das molduras disponíveis, escreva um programa para ajudar João a escolher a melhor moldura, segundo os critérios acima.\nEntrada\nA primeira linha da entrada contém dois inteiros A e L indicando respectivamente a altura e largura da fotografia, em centímetros. A segunda linha da entrada contém um inteiro N, a quantidade de molduras disponíveis. As molduras são identificadas por números de 1 a N. Cada uma das N linhas seguintes contém dois inteiros Xi e Yi indicando as dimensões em centímetros da moldura de número i, para 1 ≤ i ≤ N.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único número inteiro, o identificador da melhor moldura de acordo com os critérios acima. Se houver mais de uma moldura que satisfaz os critérios, o programa deve produzir o menor identificador entre as molduras que satisfazem os critérios. Se nenhuma moldura satisfaz os critérios, a linha deve conter −1.\nRestrições\n• 1 ≤ A ≤ 100 • 1 ≤ L ≤ 100 • 1 ≤ N ≤ 100 • 1 ≤ Xi ≤ 200 para 1 ≤ i ≤ N • 1 ≤ Yi ≤ 200 para 1 ≤ i ≤ N • não há duas molduras com as mesmas dimensões Exemplos",
    "examples": [
      [
        "10 20\n3\n20 20\n25 10\n5 5",
        "2"
      ],
      [
        "24 30\n1\n25 25",
        "-1"
      ],
      [
        "20 20\n4\n30 30\n30 10\n35 40\n25 36",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "fotografia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quebra-cabeças",
    "description": "Um quebra-cabeças é composto por um tabuleiro composto por células quadradas organizadas em duas linhas de N colunas. Cada célula do tabuleiro pode conter uma ficha numerada, como na figura abaixo.\n  As fichas podem ser deslizadas para uma célula não ocupada à direita ou à esquerda da posição corrente da ficha, mas a ordem das fichas, da esquerda para a direita, não pode ser alterada. Assim, na figura acima as fichas −3 e 5 podem ser movidas no máximo uma célula para a direita ou para a esquerda; já a ficha 3 pode ser movida somente para a esquerda, uma ou duas células. A figura abaixo ilustra algumas configurações possíveis para o quebra-cabeça da figura acima.\n2 -3 5 2 -3 5   -1 2 3 -1 2 3 (a) (b) (c) O valor de uma configuração é a soma das multiplicações entre as fichas da primeira e da segunda linha do tabuleiro, para cada coluna (a ausência de ficha em uma célula é equivalente à presença de uma ficha de valor zero). Ou seja, para a configuração (a) acima, o valor é 2 × −1 + −3 × 0 + 5 × 2 + 0 × 3 = 8; para a configuração (b), o valor é 2 × −1 + −3 × 0 + 0 × 2 + 5 × 3 = 13; para a configuração (c), o valor é 0×−1+0×2+2×3+−3×0+5×0 = 6. O objetivo do quebra-cabeça é encontrar uma configuração com o maior valor possível.\nDada a descrição do tabuleiro e das fichas do quebra-cabeças, escreva um programa para determinar o maior valor possível que uma configuração pode ter.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de colunas do tabuleiro. Cada uma das duas linhas seguintes descreve as fichas de uma linha do tabuleiro. A linha da entrada inicia com um inteiro M indicando o número de fichas na linha do tabuleiro, seguido de M inteiros Xi indicando o valor e ordem das fichas.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, o valor máximo de uma configuração para o quebra-cabeças da entrada.\nRestrições\n• 1 ≤ N ≤ 500 • 1 ≤ M ≤ N • −100 ≤ Xi ≤ 100 e Xi (cid:54)= 0 para 1 ≤ i ≤ M Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ N ≤ 10 e M = N − 1.\n• Para um conjunto adicional de casos de testes valendo 30 pontos, 1 ≤ N ≤ 200.\n• Para um conjunto adicional de casos de testes valendo 50 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5\n3 2 -3 5\n3 -1 2 3",
        "19"
      ],
      [
        "6\n4 -20 7 13 -2\n5 1 -2 7 1 -1",
        "133"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quebra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caixeiro Viajante",
    "description": "Paulo é um caixeiro viajante, que visita clientes nas cidades do reino da Nlogônia para demonstrar novos produtos da empresa para a qual trabalha.\nPaulo está organizando uma viagem para visitar cada uma das N cidades do reino. A Nlogônia é imensa, as cidades são distantes, de forma que Paulo vai sempre usar transporte aéreo para ir de uma cidade a outra. Paulo conhece o tempo de vôo entre cada par de cidades, mas não gosta de viajar de avião e quer minimizar o tempo de vôo total para a viagem. No entanto, Paulo tem uma demanda peculiar quanto à ordem das cidades que vai visitar.\nNa Nlogônia os “nomes” das cidades são números inteiros de 1 a N. Paulo deseja que a ordem das cidades que vai visitar obedeçam à seguinte regra: quando Paulo visitar a cidade K, ou todas as cidades de nomes menores do que K já foram visitadas ou todas serão visitadas após K.\nPor exemplo, se N é igual a três, Paulo pode visitar as cidades nas ordens 1,2,3 ou na ordem 3,2,1 ou na ordem 2,1,3, mas não pode visitá-las na ordem 1,3,2, pois quando visita a cidade 3, como 1 já foi visitada, 2 também deveria ter sido visitada.\nEscreva um programa para determinar o tempo mínimo total de vôo para a viagem de Paulo, iniciando em qualquer cidade, terminando em qualquer cidade, mas visitando cada cidade uma única vez.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de cidades. Cada uma das N(N −1)/2 linhas contém três inteiros A, B e T, indicando que o tempo de vôo da cidade A para a cidade B é T (o tempo de vôo da cidade B para a cidade A também é T).\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, o tempo mínimo total de vôo para a viagem de Paulo.\nRestrições\n• 2 ≤ N ≤ 1500 • 1 ≤ A < B ≤ N • 1 ≤ T ≤ 1000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 25 pontos, 1 ≤ N ≤ 10.\n• Para um conjunto adicional de casos de testes valendo 50 pontos, 1 ≤ N ≤ 20.\n• Para um conjunto adicional de casos de testes valendo 25 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "3\n1 2 5\n1 3 2\n2 3 4",
        "7"
      ],
      [
        "4\n1 2 15\n1 3 7\n1 4 8\n2 3 16\n2 4 9\n3 4 12",
        "31"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 2,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caixeiro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Atlanta",
    "description": "Documentos recentemente encontrados por pesquisadores mostram que na Sala de Audiências do palácio Real na cidade perdida de Atlanta o piso era formado por ladrilhos 20 cm x 20 cm. Ladrilhos de duas cores foram usados: o centro da Sala era formado por ladrilhos brancos e exatamente uma fileira de ladrilhos azuis foram colocados em cada lateral do Sala, como nas figuras abaixo.\n3 x 4 5 x 6 Os pesquisadores não encontraram vestígios da Sala de Audiências (nem da cidade de Atlanta!), mas os documentos recentes, se forem autênticos, indicam também a quantidade de ladrilhos que foram utilizados no piso da Sala.\nSua tarefa é, dadas as quantidades de azulejos azuis e brancos, determinar as dimensões da Sala de Audiências.\nEntrada\nA primeira linha da entrada contém um inteiro A, o número de azulejos azuis. A segunda linha contém um número inteiro B, o número de azulejos brancos.\nSaída\nSeu programa deve produzir uma única linha, contendo dois números inteiros, representando as dimensões da Sala (largura e comprimento). Se a largura for diferente do comprimento, seu programa deve imprimir primeiro a menor dimensão, seguida da maior dimensão. Se as quantidades de azulejos não forem corretas para construir o piso da Sala no formato descrito acima, seu programa deve imprimir -1 -1.\nRestrições\n• 1 ≤ A ≤ 106 • 1 ≤ B ≤ 106 Exemplos",
    "examples": [
      [
        "10\n2",
        "3 4"
      ],
      [
        "8\n2",
        "-1 -1"
      ],
      [
        "3996\n996004",
        "1000 1000"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "atlanta"
    },
    "imagesQuant": 0
  },
  {
    "name": "Aplicativo de Calorias",
    "description": "Um aplicativo de celular está sendo desenvolvido para, a partir da foto de um prato contendo uma refeição, estimar a quantidade de calorias da refeição.\nO algoritmo de inteligência artificial (IA) utilizado no aplicativo produz três números inteiros, E1, E2 e E3. E1 é a quantidade mínima de calorias estimada e E2 a quantidade máxima de calorias estimada para a refeição da fotografia. E3 só tem significado se a diferença entre as quantidades estimadas mínima e máxima são maiores do que um valor pré-definido X; nesse caso, E3 é a quantidade de calorias estimada por um método alternativo.\nDepois de vários testes, os desenvolvedores do aplicativo determinaram que os melhores resultados são obtidos usando as estimativas produzidas pelo algoritmo de IA da seguinte forma: • se a diferença entre E1 e E2 for menor ou igual ao valor de X, o aplicativo deve mostrar ao usuário o valor de E2 como o número de calorias; • se a diferença entre E1 e E2 for maior do que o valor de X, o aplicativo deve mostrar ao usuário o valor de E3 como o número de calorias; Dados o valor de X e as três estimativas produzidas pelo algoritmo de IA, escreva um programa que determine o resultado que deve ser mostrado para o usuário.\nEntrada\nA primeira linha da entrada contém um inteiro, o valor de E1. A segunda linha contém um inteiro, o valor de E2. A terceira linha contém um inteiro, o valor de E3. A quarta linha contém um inteiro, o valor de X.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o resultado que deve ser mostrado para o usuário do aplicativo.\nRestrições\n• 0 ≤ E1 ≤ E2 ≤ 10000 • 0 ≤ E3 ≤ 10000 • 0 ≤ X ≤ 10000 Exemplos",
    "examples": [
      [
        "1500\n2000\n2500\n1000",
        "2000"
      ],
      [
        "1000\n1300\n1050\n200",
        "1050"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "calorias"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cobertura para Celular",
    "description": "Para atrair mais turistas, o governo decidiu permitir a instalação de uma rede de telefonia celular no paradisíaco arquipélago de Logarium. O arquipélago tem muitas ilhas no formato circular, todas com no máximo 1 km de diâmetro.\nExatamente uma torre de celular será instalada no centro de cada uma das ilhas. Todas as torres serão idênticas e terão o mesmo alcance; o alcance é a distância máxima da torre que um equipamento (telefone ou outra torre) pode estar de forma que a comunição seja possível.\nO governo deseja que a rede de telefonia celular garanta a cobertura total do arquipélago, ou seja, deve ser possível a um usuário comunicar-se com qualquer outro usuário no arquipélago, mesmo que a comunicação tenha que passar por mais de uma torre.\nHá vários tipos de torres disponíveis no mercado, cada tipo com um alcance. O governo recebeu uma proposta atrativa de uma empresa e deseja saber se o alcance da torre ofertada permitirá a cobertura total do arquipélago.\nDadas a localização das torres e o alcance da torre ofertada, escreva um programa para determinar se a torre ofertada permite a cobertura total do arquipélago.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de ilhas do arquipélago.\nCada uma das N linhas seguintes contém dois inteiros Xi e Yi, as coordenadas da i-ésima torre.\nNão existem duas torres com as mesmas coordenadas. A última linha da entrada contém um inteiro A indicando o alcance da torre.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único caractere, que deve ser S se a torre permite a cobertura total ou N caso contrário.\nRestrições\n• 2 ≤ N ≤ 10000 • 0 ≤ Xi,Yi ≤ 1000, para 1 ≤ i ≤ N • 1 ≤ A ≤ 10000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, Yi = 0 para 1 ≤ i ≤ N.\n• Para um conjunto de casos de testes valendo 80 pontos adicionais, nenhuma outra restrição.\nExemplos",
    "examples": [
      [
        "3\n200 200\n400 400\n600 600\n200",
        "N"
      ],
      [
        "5\n10 10\n10 30\n30 10\n30 30\n20 20\n20",
        "S"
      ],
      [
        "3\n0 0\n40 0\n0 30\n49",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "celular"
    },
    "imagesQuant": 0
  },
  {
    "name": "Torre de Dados",
    "description": "Hortência está brincando de construir uma torre com dados de seis faces. Os dados são similares aos dados comuns utilizados em jogos, com as faces estampadas com valores de 1 a 6. Mas os dados usados por Hortência têm uma grande diferença em relação aos dados comuns: enquanto em dados comuns a soma dos valores em faces opostas é sempre sete, para os dados de Hortência os valores em faces opostas nem sempre têm soma sete.\nHortência está criando a torre empilhando os seus dados, obedecendo às seguintes regras: 1. Seja X dado que está colocado imediatamente em cima de um dado Y. Então o valor da face inferior de X deve ser igual ao valor da face superior de Y. Por exemplo, se a pilha tem três dados R, S e T, empilhados nessa ordem de baixo para cima, então o valor da face superior de R deve ser igual ao valor da face inferior de S, e o valor da face superior de S deve ser igual ao valor da face inferior de T.\n2. Os dados devem ter suas laterais alinhadas, ou seja, a torre formada tem exatamente quatro lados, correspondendo aos lados dos dados.\nHortência quer criar uma torre tal que a soma dos valores de um dos lados da torre seja a maior possível. Note que após empilhar os dados obedecendo à regra (1), Hortência pode girar cada dado horizontalmente de forma independente, obedecendo à regra (2), para alterar os valores das somas dos lados.\nDadas as informações sobre os dados utilizados na torre, escreva um programa para determinar o maior valor possível para a soma de um dos lados da torre.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de dados. Cada uma das N linhas seguintes descreve um dado e contém seis inteiros A, B, C, D, E e F, identificando os valores dos lados do dado, conforme a figura abaixo. Errata, faltou a seguinte frase na prova online: os dados são empilhados na torre na ordem dada na entrada, de baixo para cima. As submisões serão julgadas com dois conjuntos de testes, um considerando os dados na ordem dada na entrada e outro considerando que a ordem pode ser qualquer uma e o competidor receberá a maior pontuação entre as duas correções.\nA C A B B C D E F E F A E B C D F D Saída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o maior valor possível para a soma de um dos lados da torre.\nRestrições\n• 1 ≤ N ≤ 1000 • 1 ≤ A,B,C,D,E,F ≤ 6, todos distintos em um dado.\nExemplos",
    "examples": [
      [
        "2\n1 2 3 4 5 6\n1 2 6 4 5 3",
        "12"
      ],
      [
        "5\n4 6 1 5 3 2\n1 3 2 4 6 5\n5 3 1 4 2 6\n6 1 5 2 4 3\n4 6 1 5 3 2",
        "28"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "torre"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo do Preto e Branco",
    "description": "Você gosta de quebra-cabeças? O jogo do Preto e Branco é um quebra-cabeças que usa um tabuleiro retangular com L linhas e C colunas, formando L×C casas. No tabuleiro são posicionadas algumas peças pretas, cada peça em uma casa diferente.\nO objetivo do jogo é colocar o maior número possível de peças brancas no tabuleiro, obedecendo às seguintes restrições: • cada casa do tabuleiro pode conter no máximo uma peça; • uma peça branca deve ter ao menos uma peça preta como vizinha, à direita, à esquerda, acima ou abaixo; • uma peça branca não pode ter outra peça branca como vizinha, à direita, à esquerda, acima ou abaixo; A figura abaixo mostra dois exemplos de jogos, com as respectivas soluções, um com um tabuleiro 3 × 3 e outro com um tabuleiro 3 × 5.\n(a) (b) Sua tarefa é escrever um programa que, dadas as descrições do tabuleiro e das peças pretas posicionadas, determine o maior número de peças brancas que podem ser colocadas.\nEntrada\nA primeira linha contém dois inteiros L e C, o número de linhas e o número de colunas do tabuleiro.\nAs linhas são numeradas de 1 a L e as colunas são numeradas de 1 a C. A segunda linha contém um inteiro P, o número de peças pretas colocadas no tabuleiro. Cada uma das P linhas seguintes descreve a posição de uma peça preta e contém dois inteiros Xi e Yi, indicando a linha e a coluna em que a peça foi colocada.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o maior número de peças brancas que podem ser colocadas no tabuleiro.\nRestrições\n• 1 ≤ L ≤ 6 • 1 ≤ C ≤ 6 • 1 ≤ P ≤ 10 • 1 ≤ Xi ≤ L para 1 ≤ i ≤ L • 1 ≤ Yi ≤ C para 1 ≤ i ≤ C Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, L = 1.\n• Para um conjunto adicional de casos de testes valendo 80 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "3 3\n3\n1 1\n1 3\n3 2",
        "3"
      ],
      [
        "1 6\n2\n1 2\n1 5",
        "3"
      ],
      [
        "3 5\n3\n2 2\n2 3\n3 5",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Rede Social",
    "description": "Uma nova rede social foi lançada e fez sucesso imediato. Nessa nova rede é possível postar mensagens que são recebidas por seguidores; um seguidor pode decidir repostar uma mensagem que recebeu e seus seguidores também receberão a mensagem e poderão por sua vez repostá-la.\nPara medir a influência de um usuário na nova rede foi criado um novo critério, chamado de Fator de Influência, descrito a seguir.\n• Inicialmente vamos definir o índice de repostagem de uma mensagem M de um usuário U como sendo o número de usuários diferentes de U que repostaram M.\n• O Fator de Influência de um usuário U é o máximo valor de FI tal que U postou FI mensagens que, cada uma, tem um índice de repostagem de pelo menos FI.\nPor exemplo, se João postou quatro mensagens, com índices de repostagem 1, 1, 5, 6, seu Fator de Influência é 2, pois postou duas mensagens com índice de repostagem maior ou igual a 2.\nDada uma lista com os índices de repostagens de todas as mensagens postadas por um usuário, escreva um programa para calcular o Fator de Influência do usuário.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de mensagens postadas pelo usuário.\nCada uma das N linhas seguintes contém um inteiro Ri, o índice de repostagem de uma mensagem.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, o Fator de Influência para o usuário.\nRestrições\n• 1 ≤ N ≤ 5 × 105 • 0 ≤ Ri ≤ 106 para 1 ≤ i ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ N ≤ 1000.\n• Para um conjunto adicional de casos de testes valendo 80 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5\n1\n4\n1\n7\n1",
        "2"
      ],
      [
        "5\n12\n5\n3\n5\n15",
        "4"
      ],
      [
        "4\n3\n3\n3\n3",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "rede"
    },
    "imagesQuant": 0
  },
  {
    "name": "Trem da mina",
    "description": "Uma antiga mina de ouro foi desativada e Herculano quer torná-la uma atração turística. A mina contém uma verdadeira rede ferroviária subterrânea, composta de estações e ramos de trilhos, pelos quais trafegavam os trens carregando minério. Cada ramo de trilho liga duas estações distintas e pode ser usado nas duas direções. Um “ciclo” na rede ferroviária é uma sequência de estações s1,s2,...,sn,sn+1 = s1, tais que si (cid:54)= si+1 e (si,si+1) é um ramo de trilho, para 1 ≤ i ≤ n. A rede ferroviária pode conter ciclos, mas cada estação faz parte de no máximo um ciclo da rede ferroviária. Os ramos de trilhos e estações são tais que, se uma parte do trem ocupa um ramo de trilho ou estação, não há espaço para outro (ou o mesmo!) trem entrar novamente nesse ramo de trilho ou estação.\nAlgumas estações da rede ferroviária têm acesso ao direto ao solo, para descarregar o minério.\nHerculano tem um mapa que descreve a rede ferroviária da mina, informando para cada ramo de trilho o seu comprimento e quais duas estações o ramo de trilho liga.\nPara planejar o passeio turístico de trem pela mina Herculano quer saber, para as estações que têm acesso ao solo, conhecendo o comprimento do trem, se é possível que o trem entre na mina pela estação, percorra a menor distância possível dentro da mina e saia novamente pela mesma estação que entrou, sempre andando para a frente, sem nunca dar marcha-a-ré. Você pode ajudá-lo? Entrada\nA primeira linha contém dois inteiros E e R representando respectivamente o número de estações e o número de ramos de trilhos da rede ferroviária da mina. As estações são identificadass por inteiros de 1 a E. Cada uma das R linhas seguintes descreve um ramo de trilho e contém três inteiros A, B e C, onde A e B representam as estações ligadas pelo ramo de trilho, e C representa o comprimento do ramo de trilho. Uma estação é ligada por ramos de trilhos a no máximo outras 100 estações e cada duas estações são ligadas por no máximo um ramo de trilho. A próxima linha contém um inteiro K, que indica o número de consultas. Cada uma das K linhas seguintes descreve uma consulta, e contém dois inteiros X e T, que indicam respectivamente a estação pela qual Herculano quer que o trem entre e o comprimento do trem.\nSaída\nPara cada consulta da entrada seu programa deve produzir uma única linha, contendo um único número inteiro, o comprimento do percurso mínimo que o trem deve percorrer dentro da mina para entrar e sair pela estação indicada na consulta, sem dar marcha-a-ré. Se não for possível para o trem entrar e sair sem dar marcha-a-ré, a linha deve conter o valor −1.\nRestrições\n• 2 ≤ E ≤ 104 • 1 ≤ R ≤ 2 × E • 1 ≤ A < B ≤ E • 1 ≤ C ≤ 100 • 1 ≤ K ≤ 100 • 1 ≤ X ≤ E • 1 ≤ T ≤ 105 • Uma estação é ligada por ramos de trilhos a no máximo outras 100 estações e cada duas estações são ligadas por no máximo um ramo de trilho.\nExemplos",
    "examples": [
      [
        "4 4\n1 2 10\n1 3 12\n3 4 7\n1 4 6\n4\n2 18\n1 10\n4 26\n3 25",
        "45\n25\n-1\n25"
      ],
      [
        "7 8\n1 2 2\n2 3 2\n2 5 10\n5 6 25\n2 6 20\n3 7 1\n4 7 4\n3 4 3\n4\n1 6\n4 50\n7 56\n7 5",
        "16\n65\n-1\n8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "trem"
    },
    "imagesQuant": 0
  },
  {
    "name": "Candidatas",
    "description": "Carla é uma biotecnóloga que está investigando proteínas para usar em uma vacina. As proteínas estão codificadas em uma longa sequência de números naturais, que vamos chamar de S.\nAtravés de múltiplos experimentos, Carla determinou que uma subsequência contígua de S é candidata se o máximo divisor comum dos elementos da subsequência é maior do que 1.\nCarla quer investigar o número de subsequências candidatas contidas em alguns intervalos contíguos de S, possivelmente também alterando alguns elementos de S. Mais precisamente, durante suas pesquisas ela deseja realizar operações de dois tipos: 1. alterar o valor de um elemento da sequência S; e 2. consultar o número de subsequências candidatas em um dado trecho contíguo de S.\nAjude Carla a realizar suas pesquisas e avançar na busca pela vacina! Entrada\nA primeira linha da entrada contém dois inteiros N e M, indicando respectivamente o número de elementos na sequência S e o número de operações a serem realizadas. A segunda linha contém N inteiros Si, os elementos da sequência S. Os elementos são identificados por índices de 1 a N. Cada uma das M linhas seguintes descreve uma operação e contém três inteiros. O primeiro inteiro, T, indica o tipo de operação e pode ser 1 ou 2. Se a operação é do tipo 1, os dois números seguintes na linha são I e V , indicando que o elemento de índice I da sequência S deve ter o valor atualizado para V . Se a operação é do tipo 2, os dois números seguintes na linha são E e D, indicando respectivamente o índice do elemento inicial e o índice do elemento final de um intervalo contíguo da sequência S.\nSaída\nPara cada operação do tipo 2, seu programa deve produzir uma única linha, contendo um único inteiro, o número de subsequências candidatas no intervalo indicado.\nRestrições\n• 1 ≤ N ≤ 105 • 1 ≤ M ≤ 105 • 1 ≤ Si ≤ 109, para 1 ≤ i ≤ N • 1 ≤ I ≤ N • 1 ≤ V ≤ 109 • 1 ≤ E ≤ D ≤ N Exemplos",
    "examples": [
      [
        "5 1\n9 3 4 8 1\n2 2 5",
        "4"
      ],
      [
        "4 3\n4 4 4 4\n2 1 4\n1 3 5\n2 1 4",
        "10\n5"
      ],
      [
        "5 3\n2 3 6 4 1\n2 1 4\n1 3 1\n2 3 5",
        "6\n1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2020,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "candidatas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Idade de Camila",
    "description": "Cibele, Camila e Celeste são três irmãs inseparáveis. Estão sempre juntas e adoram fazer esportes, ler, cozinhar, jogar no computador... Agora estão aprendendo a programar computadores para desenvolverem seus próprios jogos.\nMas nada disso interessa para esta tarefa: estamos interessados apenas nas suas idades. Sabemos que Cibele nasceu antes de Camila e Celeste nasceu depois de Camila.\nDados três números inteiros indicando as idades das irmãs, escreva um programa para determinar a idade de Camila.\nEntrada\nA entrada é composta por três linhas, cada linha contendo um número inteiro N, a idade de uma das irmãs.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, a idade de Camila.\nRestrições\n• 5 ≤ N ≤ 100 Exemplos",
    "examples": [
      [
        "6\n9\n7",
        "7"
      ],
      [
        "34\n36\n38",
        "36"
      ],
      [
        "22\n25\n22",
        "22"
      ],
      [
        "91\n91\n91",
        "91"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "idade"
    },
    "imagesQuant": 0
  },
  {
    "name": "Plano de Internet",
    "description": "João conseguiu contratar um ótimo plano de Internet para o seu telefone celular.\nO plano permite que João utilize uma quota de até X megabytes de dados por mês para navegar na Internet. Se João não usa toda a sua quota no mês, os megabytes que ele não usou são adicionados à quota do mês seguinte. Pelo contrato, João nunca pode usar mais megabytes do que a sua quota corrente.\nPor exemplo, se X = 200 megabytes e João usou 150 no primeiro mês e 220 megabytes no segundo mês, então no terceiro mês João tem uma quota de 230 megabytes para usar (50 megabytes são transferidos do primeiro para o segundo mês, 30 megabytes são transferidos do segundo para o terceiro mês).\nNesta tarefa são dados o valor da quota mensal X e quantos megabytes João usou em cada um dos primeiros N meses do plano. Você deve determinar quantos megabytes João tem para usar no mês N + 1.\nEntrada\nA primeira linha da entrada contém um número inteiro X, o valor da quota mensal em megabytes.\nA segunda linha contém um inteiro N, o número de meses. Cada uma das linhas seguintes contém um número inteiro Mi, indicando a quantidade de megabytes que João usou em cada mês, do mês 1 até o mês N.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número inteiro, a quantidade de megabytes que João tem para usar no mês N + 1.\nRestrições\n• 1 ≤ X ≤ 100 • 1 ≤ N ≤ 100 • 0 ≤ Mi ≤ 10000 para 1 ≤ i ≤ N • Mi nunca é maior do que a quantidade de megabytes que João tem para usar no mês.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, 1 ≤ N ≤ 3.\n• Para um conjunto de casos de testes valendo 90 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "100\n2\n50\n120",
        "130"
      ],
      [
        "10\n3\n4\n6\n2",
        "28"
      ],
      [
        "100\n2\n100\n100",
        "100"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "plano"
    },
    "imagesQuant": 0
  },
  {
    "name": "Torneio de tênis",
    "description": "A prefeitura contratou um novo professor para ensinar as crianças do bairro a jogar tênis na quadra de tênis do parque municipal. O professor convidou todas as crianças do bairro interessadas em aprender a jogar tênis. Ao final do primeiro mês de aulas e treinamentos foi organizado um torneio em que cada participante disputou exatamente seis jogos. O professor vai usar o desempenho no torneio para separar as crianças em três grupos, de forma a ter grupos de treino em que os participantes tenham habilidades mais ou menos iguais, usando o seguinte critério: • participantes que venceram 5 ou 6 jogos serão colocados no Grupo 1; • participantes que venceram 3 ou 4 jogos serão colocados no Grupo 2; • participantes que venceram 1 ou 2 jogos serão colocados no Grupo 3; • participantes que não venceram nenhum jogo não serão convidados a continuar com os treinamentos.\nDada uma lista com o resultado dos jogos de um participante, escreva um programa para determinar em qual grupo ele será colocado.\nEntrada\nA entrada consiste de seis linhas, cada linha indicando o resultado de um jogo do participante.\nCada linha contém um único caractere: V se o participante venceu o jogo, ou P se o jogador perdeu o jogo. Não há empates nos jogos.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único inteiro, identificando o grupo em que o participante será colocado. Se o participante não for colocado em nenhum dos três grupos seu programa deve imprimir o valor −1.\nExemplos",
    "examples": [
      [
        "V\nV\nP\nP\nP\nV",
        "2"
      ],
      [
        "P\nP\nP\nP\nP\nP",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "torneio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tempo de resposta",
    "description": "Sara adora trocar mensagens com amigos. Como ela recebe e envia muitas mensagens, está preocupada com o tempo que seus amigos esperam para receber respostas das mensagens.\nAs seguintes regras de etiqueta são sempre obedecidas: • as únicas mensagens que Sara envia são respostas a mensagens que ela recebeu.\n• Sara envia no máximo uma mensagem como reposta a uma mensagem que recebeu.\n• um amigo de Sara nunca envia uma nova mensagem para Sara até que tenha recebido resposta da mensagem que enviou anteriormente.\nO aplicativo de mensagens que Sara e seus amigos usam recebe e envia mensagens instantaneamente.\nO envio e o recebimento de mensagens são chamados de eventos. O aplicativo registra cada evento na ordem em que os eventos ocorrem, usando dois tipos de registro: • R X indica que uma mensagem foi recebida do amigo X.\n• E X indica que uma mensagem foi enviada ao amigo X.\nO aplicativo usa ainda um outro tipo de registro, para indicar o tempo que se passou entre dois eventos consecutivos, na forma • T X indicando que X segundos se passaram entre o evento anterior e o evento posterior a esse registro.\nSe não há registro do tipo T X entre dois registros de eventos consecutivos significa que exatamente 1 segundo se passou entre esses dois eventos.\nO Tempo de Resposta de uma mensagem é o tempo que se passa entre o recebimento da mensagem por Sara e o envio da resposta a essa mensagem por Sara. Se um amigo recebeu respostas para todas as suas mensagens, o Tempo de Resposta Total para esse amigo é a soma dos Tempos de Respostas para as mensagens desse amigo; caso contrário o Tempo de Resposta Total para esse amigo é −1.\nDada a lista de registros do aplicativo de Sara, sua tarefa é determinar o Tempo de Resposta Total para cada amigo.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de registros. Os amigos de Sara são identificados por números inteiros. Cada uma das N linhas seguintes descreve um registro e contém um caractere (R, E ou T) seguido de um número inteiro X. No caso de registros dos tipos R e E o valor de X indica um amigo de Sara; no caso do registro de tipo T, o valor de X indica o número de segundos que se passaram entre o evento anterior e o posterior.\nSaída\nPara cada amigo de Sara seu programa deve produzir uma linha na saída contendo dois inteiros: o número do amigo e o Tempo de Resposta Total para esse amigo, em ordem crescente dos números dos amigos.\nRestrições\n• 1 ≤ N ≤ 20 • 1 ≤ X ≤ 100 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, 1 ≤ N ≤ 10.\n• Para um conjunto de casos de testes valendo 80 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5\nR 2\nR 3\nT 5\nE 2\nE 3",
        "2 6\n3 6"
      ],
      [
        "14\nR 12\nT 2\nR 23\nT 3\nR 45\nE 45\nR 45\nE 23\nR 23\nT 2\nE 23\nR 34\nE 12\nE 34",
        "12 13\n23 8\n34 2\n45 -1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tempo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Zero para cancelar",
    "description": "Seu chefe está ao telefone, nervoso. Ele quer que você compute a soma de uma sequência de números que ele vai falar para você ao telefone, para saber o total das vendas em sua mais recente viagem de negócios.\nInfelizmente, de vez em quando seu chefe fala números errados para você ao telefone.\nFelizmente, seu chefe rapidamente percebe que falou um número errado e diz “zero”, que como combinado previamente quer dizer ignore o último número corrente.\nInfelizmente, seu chefe pode cometer erros repetidos, e diz “zero” para cada erro.\nPor exemplo, seu chefe pode falar ao telefone “Um, três, cinco, quatro, zero, zero, sete, zero, zero, seis”, o que significa uma soma total igual a 7, conforme explicado na tabela abaixo:   Para não deixar seu chefe ainda mais nervoso, escreva um programa que determine a soma total dos números falados por seu chefe ao telefone.\nEntrada\nA primeira linha da entrada contém um inteiro N, a quantidade de números inteiros (incluindo os “zeros”) que o seu chefe falou ao telefone. Cada uma das N linhas seguintes contém um número inteiro Xi.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único inteiro, a soma correta dos números, levando em conta que o valor 0 significa erro, conforme descrito.\nRestrições\n• 1 ≤ N ≤ 100 000 • 0 ≤ Xi ≤ 100, para (1 ≤ i ≤ N) • 0 ≤ resultado ≤ 1 000 000 Exemplos",
    "examples": [
      [
        "4\n3\n0\n4\n0",
        "0"
      ],
      [
        "10\n1\n3\n5\n4\n0\n0\n7\n0\n0\n6",
        "7"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "zero"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cifra da Nlogônia",
    "description": "O rei da Nlogônia ordenou que todos os documentos importantes sejam “cifrados”, para que apenas quem tem conhecimento da cifra possa lê-los (cifrar um documento significa alterar o original modificando as letras de acordo com algum algoritmo de cifra).\nO rei decretou que o seguinte algotimo deve ser usado para cifrar os documentos: • Cada consoante deve ser substituída por exatamente três letras, na seguinte ordem: 1. a própria consoante (vamos chamar de consoante original); 2. a vogal mais próxima da consoante original no alfabeto, com a regra adicional de que se a consoante original está à mesma distância de duas vogais, então a vogal mais próxima do início do alfabeto é usada. Por exemplo, se a consoante original é d, a vogal que deve ser usada é e, pois esta é a vogal mais próxima; se a consoante original é c, a vogal que deve ser utilizada é a, porque c está à mesma distância de a e e, e a é mais próxima do início do alfabeto.\n3. a consoante que segue a consoante original, na ordem do início ao fim do alfabeto. Por exemplo, se a consoante original é d, a consoante a ser utilizada é f. No caso de a consoante original ser z, deve ser utilizada a própria letra z.\n• As vogais não são modificadas.\nNesta tarefa, o alfabeto é a b c d e f g h i j k l m n o p q r s t u v x z e as vogais são a e i o u Por exemplo, a cifra da palavra “ter” é “tuveros” (tuv-e-ros) e a cifra da palavra “paz” é “poqazuz” (poq-a-zuz).\nO rei da Nlogônia procura por alguém que saiba escrever um programa que produza a cifra de uma palavra dada. Você pode ajudá-lo? Entrada\nA primeira e única linha da entrada contém uma palavra P formada por letras minúsculas sem acentuação.\nSaída\nSeu programa deve produzir uma única linha, contendo a palavra cifrada.\nRestrições\n• A palavra P tem no mínimo uma e no máximo 30 letras, todas minúsculas e sem acentuação.\nExemplos",
    "examples": [
      [
        "ter",
        "tuveros"
      ],
      [
        "rei",
        "rosei"
      ],
      [
        "arteiro",
        "arostuveiroso"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cifra"
    },
    "imagesQuant": 0
  },
  {
    "name": "Baralho",
    "description": "Uma gráfica iniciou a produção de cartas de baralho. Cada baralho produzido deve ser um baralho completo, ou seja, deve ter exatamente 52 cartas, compreendendo quatro naipes (Copas, Espadas, Ouros e Paus), com treze cartas em cada naipe (Ás, 2, 3, 4, 5, 6, 7, 8, 9, 10, Valete, Dama e Rei).\nUm robô coleta cartas produzidas pelas máquinas impressoras e cortadoras e as agrupa em conjuntos de 52 cartas, preparando o baralho para ser embalado para venda. A empresa deseja garantir que cada baralho embalado seja um baralho completo e precisa de sua ajuda.\nDada a lista das cartas de um baralho pronto para ser embalado, escreva um programa para verificar se há cartas faltando ou duplicadas no baralho.\nEntrada\nA primeira linha da entrada contém uma cadeia de caracteres que descreve as cartas do baralho.\nCada carta é descrita usando três caracteres, no formato ddN onde dd são dois dígitos decimais (de 01, representando a carta Ás, a 13, representanto a carta Rei) e N é um caractere entre C, E, U e P, representando respectivamente os naipes Copas, Espadas, Ouros e Paus). Note que o caractere que representa o naipe Ouros é U (e não O), para não confundir com o dígito zero.\nSaída\nSeu programa deve produzir exatamente quatro linhas na saída, cada linha correspondendo aos naipes Copas, Espadas, Ouros, e Paus, nessa ordem. Para cada naipe, se o conjunto de cartas está completo (ou seja, se exatamente 13 cartas com valores de 01, 02, 03, ..., 12, 13 estão presentes), seu programa deve produzir o valor 0; se o conjunto de cartas tem alguma carta duplicada, seu programa deve produzir a palavra erro; se o conjunto de cartas tem cartas faltando, seu programa deve imprimir o número de cartas que faltam.\nRestrições\n• 3 ≤ comprimento da cadeia de caracteres na entrada ≤ 156 • para toda carta ddN, 01 ≤ dd ≤ 13 e N é C, E, U ou P.\nInformações sobre a pontuação\n• Para um conjunto de casos de teste valendo 20 pontos, não há cartas duplicadas, há apenas cartas faltando.\nExemplos",
    "examples": [
      [
        "11P01C02C01U02U03U04U",
        "11\n13\n9\n12"
      ],
      [
        "13P02P01P03P04P05P06P07P08P09P10P11P12P",
        "13\n13\n13\n0"
      ],
      [
        "01C02C03C04C05C07C09C10C11C02E02E03E11U",
        "4\nerro\n12\n13"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "baralho"
    },
    "imagesQuant": 0
  },
  {
    "name": "Média e mediana",
    "description": "A média de três números inteiros A, B e C é (A + B + C)/3. A mediana de três números inteiros é o número que ficaria no meio se os três números fossem ordenados em ordem não-decrescente.\nSua tarefa é escrever um programa que, dados dois números inteiros distintos A e B, calcule o menor inteiro possível C tal que a média e a mediana de A, B e C sejam iguais.\nEntrada\nA entrada é composta de uma única linha contendo dois números inteiros A e B.\nSaída\nSeu programa deve produzir uma única linha, contendo um único número, o menor inteiro possível C tal que a média e a mediana de A, B e C são iguais.\nRestrições\n• 1 ≤ A ≤ B ≤ 109 Exemplos",
    "examples": [
      [
        "1 2",
        "0"
      ],
      [
        "6 10",
        "2"
      ],
      [
        "1 1000000000",
        "-999999998"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "media"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pangrama",
    "description": "Um pangrama é uma frase que contém todas as letras de um determinado alfabeto.\nEm português, um pangrama pode incluir também letras acentuadas, mas neste problema vamos desconsiderar os acentos (mesmo que isso torne a frase mal escrita!) Veja alguns exemplos de pangramas em português (sem acentos): • grave e cabisbaixo, o filho justo zelava pela querida mae doente • hoje a noite, sem luz, decidi xeretar a quinta gaveta de vovo: achei linguica, pao e fuba • marta foi a cozinha pois queria ver belo jogo de xicaras Note que para os pangramas acima consideramos o alfabeto composto pelas letras a b c d e f g h i j l m n o p q r s t u v x z (ou seja, não consideramos as letras k, w ou y). Note ainda que as frases não contêm letras acentuadas mas podem conter símbolos gráficos como espaço em branco, vírgula e dois pontos.\nEntrada\nA primeira e única linha da entrada contém uma cadeia de caracteres C.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser S se a frase for um pangram ou N caso contrário.\nRestrições\n• A cadeia de caracteres C tem no mínimo um e no máximo 200 caracteres. Os únicos caracteres em C são as letras minúsculas do alfabeto mostrado acima, espaços em branco, vírgulas e o caractere dois pontos.\nExemplos",
    "examples": [
      [
        "gazeta publica hoje: breve anuncio de faxina na quermesse",
        "S"
      ],
      [
        "esta frase nao usa todas as letras, estao faltando algumas",
        "N"
      ],
      [
        "abcdefghijlmnopqrstuvxz",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pangrama"
    },
    "imagesQuant": 0
  },
  {
    "name": "Robô",
    "description": "Um fazendeiro comprou um robô-espantalho para espantar os pássaros de sua plantação de milho.\nO robô se move ao longo de um caminho que circunda a plantação. No caminho há N estações numeradas sequencialmente, a partir de 1, no sentido horário. A figura abaixo mostra um exemplo com oito estações.\n1 2 3 8 plantação 4 7 6 5 O robô inicia cada dia na estação número 1, e então obedece a uma sequência de comandos. Os comandos são gerados por um algoritmo de aprendizagem de máquina que coleta informações através de sensores espalhados na plantação, para garantir uma cobertura de vigia máxima. Cada comando faz com que o robô se mova para outra estação, vizinha à estação em que ele se encontra, ou no sentido horário ou no sentido anti-horário. O robô permanece nessa nova estação até receber um novo comando.\nApesar da promessa de que o robô protegeria a plantação, ao final de um determinado dia o fazendeiro notou que parte de sua plantação estava devastada por pássaros. O fazendeiro agora quer entender melhor o que aconteceu.\nDados o número da estação mais próxima à área devastada e a sequência de comandos que o robô obedeceu naquele dia, escreva um programa para determinar quantas vezes o robô permaneceu na estação mais próxima à àrea devastada.\nEntrada\nA primeira linha contém três inteiros N, C e S, representando respectivamente o número de estações, o número de comandos e o número da estação mais próxima à área devastada. A segunda linha contém C inteiros X1,X2,...,XC, representando a sequência de comandos recebidos pelo robô.\nPara i = 1,2,...,C, se Xi é 1 então o i-ésimo comando significa “mova-se para a próxima estação no sentido horário”, enquanto se Xi é −1 então o i-ésimo comando significa “mova-se para a próxima estação no sentido anti-horário”. O robô sempre inicia na estação número 1.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de vezes que o robô permaneceu na estação número S durante o dia.\nRestrições\n• 2 ≤ N ≤ 100 • 1 ≤ C ≤ 1000 Exemplos",
    "examples": [
      [
        "8 8 3\n1 -1 1 1 1 -1 1 1",
        "2"
      ],
      [
        "5 4 1\n1 1 1 1",
        "1"
      ],
      [
        "2 1 1\n1",
        "1"
      ],
      [
        "2 1 2\n1",
        "1"
      ],
      [
        "2 2 1\n-1 1",
        "2"
      ],
      [
        "2 2 1\n-1 -1",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "robo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Duplas de tênis",
    "description": "Quatro amigos combinaram de jogar tênis em duplas. Cada um dos amigos tem um nível de jogo, que é representado por um número inteiro: quanto maior o número, melhor o nível do jogador.\nOs quatro amigos querem formar as duplas para iniciar o jogo. De forma a tornar o jogo mais interessante, eles querem que os níveis dos dois times formados sejam o mais próximo possível. O nível de um time é a soma dos níveis dos jogadores do time.\nEmbora eles sejam muito bons jogadores de tênis, os quatro amigos não são muito bons em algumas outras coisas, como lógica ou matemática. Você pode ajudá-los e encontrar a menor diferença possível entre os níveis dos times que podem ser formados? Entrada\nA entrada contém quatro linhas, cada linha contendo um inteiro A, B, C e D, indicando o nível de jogo dos quatro amigos.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, a menor diferença entre os níveis dos dois times formados.\nRestrições\n• 0 ≤ A ≤ B ≤ C ≤ D ≤ 104 Exemplos",
    "examples": [
      [
        "4\n7\n10\n20",
        "7"
      ],
      [
        "0\n0\n1\n1000",
        "999"
      ],
      [
        "1\n2\n3\n4",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tenis"
    },
    "imagesQuant": 0
  },
  {
    "name": "Retângulo",
    "description": "Vô Pedro é um fazendeiro meticuloso. Em sua fazenda ele tem uma plantação no formato circular, com algumas árvores plantadas exatamente na circunferência da plantação. A figura (a) abaixo mostra a plantação com as árvores.\nAgora vô Pedro quer usar uma longa corda e quatro das árvores para demarcar um retângulo na plantação, usando as árvores como vértices, com a corda marcando os lados. A figura (b) abaixo mostra dois retângulos que podem ser demarcados usando as árvores na plantação figura (a).\n3 2 3 2 2 2 3 2 3 2 4 4 6 6 2 2 (a) (b) Dada a descrição das posições das árvores na plantação circular de vô Pedro, sua tarefa é determinar se é possível demarcar um retângulo conforme descrito acima.\nEntrada\nA primeira linha da entrada contém um inteiro N indicando o número de árvores na circunferência da plantação. As árvores são representadas como pontos na circunferência. A segunda linha contém N inteiros L1,L2,...LN, indicando o comprimento do arco entre cada par de árvores consecutivas.\nOs arcos são dados no sentido anti-horário.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser S se é possível demarcar um retângulo usando as árvores como vértices, ou N caso contrário.\nRestrições\n• 4 ≤ N ≤ 105 • 1 ≤ Li ≤ 106 para i = 1,2,...,N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 100.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N ≤ 300.\n• Para um conjunto de casos de testes valendo outros 20 pontos, N ≤ 1000.\n• Para um conjunto de casos de testes valendo outros 40 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "8\n3 3 4 2 6 2 2 2",
        "S"
      ],
      [
        "4\n14 16 15 15",
        "N"
      ],
      [
        "6\n3 7 7 3 10 10",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "retangulo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Passatempo",
    "description": "Desafios de lógica e matemática são um ótimo passatempo, atraindo um grande número de praticantes, e um mercado que envolve aplicativos para celular, atividades on-line, revistas especializadas e até mesmo cursos na internet para melhorar o desempenho! Neste problema sua tarefa é escrever um programa que resolva um novo passatempo, mostrado na figura abaixo. O passatempo é composto por um quadriculado com letras dentro de cada célula e números ao lado de cada linha ou coluna do quadriculado. As letras dentro de cada célula representam variáveis, e os números representam as somas dos valores das variáveis em cada linha ou coluna.\ndf bb cg df df 11 ee az cg az ee 6 df cg cg df df 10 az az cg az az 6 6 7 8 6 6 O objetivo desse passatempo é determinar o valor de cada variável de modo a satisfazer as somas das linhas e colunas mostradas. Para permitir que um número maior de pessoas consiga resolver o passatempo, ele tem uma propriedade que facilita a sua solução: sempre é possível encontrar uma linha ou coluna em que há apenas uma variável cujo valor ainda é desconhecido. Assim, uma possível maneira de resolver o problema é, a cada passo da solução, encontrar o valor de uma variável.\nSua tarefa é, dado um passatempo, determinar os valores das variáveis que o solucionam.\nEntrada\nA primeira linha contém dois inteiros L e C indicando o número de linhas e o número de colunas do passatempo. Cada uma das L linhas seguintes contém C nomes de variáveis, seguidos de um inteiro S, a soma resultante das variáveis dessa linha. A última linha contém C inteiros Xi, indicando respectivamente a soma das variáveis na coluna i. Nomes de variáveis são formados por precisamente duas letras minúsculas, de ’a’ a ’z’. Todos os passatempos têm solução única, em que todas as variáveis são números inteiros.\nSaída\nSeu programa deve produzir uma linha para cada variável do passatempo, contendo o nome da variável e o seu valor inteiro. As variáveis devem ser escritas em ordem alfabética crescente, ou seja, respeitando a ordem aa,ab,...,az,ba,bb,...,za,zb,...,zz.\nRestrições\n• 1 ≤ L ≤ 100 • 2 ≤ C ≤ 100 • −108 ≤ S ≤ 108 • −108 ≤ Xi ≤ 108 Exemplos",
    "examples": [
      [
        "4 5\ndf bb cg df df 11\nee az cg az ee 6\ndf cg cg df df 10\naz az cg az az 6\n6 7 8 6 6",
        "az 1\nbb 3\ncg 2\ndf 2\nee 1"
      ],
      [
        "3 4\naa bb cc dd 10\naa bb cc dd 10\naa bb cc dd 10\n3 6 9 12",
        "aa 1\nbb 2\ncc 3\ndd 4"
      ],
      [
        "3 3\naa zz aa 27\nvv zz aa -5\nkk kk aa 40\n15 -7 54",
        "aa 18\nkk 11\nvv -14\nzz -9"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "passatempo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sanduíche",
    "description": "Uma nova lanchonete abriu na cidade, prometendo um menu com a maior variedade de sanduíches da região. A cada dia o Chef de cozinha compra N ingredientes distintos e prepara o menu usando esses N ingredientes. Infelizmente não é possível ter sanduíches com qualquer combinação de ingredientes: a cada dia o Chef determina que M pares de ingredientes não podem ser utilizados no mesmo sanduíche, porque ele considera que esses ingredientes “não combinam”.\nPor exemplo, suponha que num determinado dia N é igual a quatro e os ingrediantes são queijo, presunto, goiabada e azeitona, e M é igual a dois: os pares (goiabada, presunto) e (azeitona, goiabada) não podem ser utilizados no mesmo sanduíche. Nesse dia, alguns dos sanduíches que podem ser feitos são: • presunto, queijo • azeitona • presunto, azeitona, queijo • goiabada, queijo Alguns dos sanduíches que não podem ser feitos são: • presunto, queijo, goiabada • azeitona, goiabada • goiabada, presunto, azeitona Dados os N ingredientes e os M pares de ingredientes que não combinam, sua tarefa é determinar qual o máximo número de sanduíches diferentes que podem ser feitos. Dois sanduíches A e B são considerados diferentes se A contém um ingrediente X que não está presente em B ou se B contém um ingrediente Y que não está presente em A. Um sanduíche deve conter ao menos um ingrediente.\nEntrada\nA primeira linha contém dois números inteiros N e M, indicando respectivamente o número de ingredientes e o número de pares de ingredientes que não combinam. Os ingredientes são identificados por números de 1 a N. Cada uma das M linhas seguintes contém dois números inteiros X e Y que representam um par de ingredientes que não combinam.\nSaída\nSeu programa deve produzir uma única linha, o número de sanduíches diferentes que podem ser feitos.\nRestrições\n• 1 ≤ N ≤ 20 • 0 ≤ M ≤ 400 • 1 ≤ X ≤ N • 1 ≤ X < Y Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N ≤ 5.\n• Para um conjunto de casos de testes valendo outros 40 pontos, N ≤ 10.\n• Para um conjunto de casos de testes valendo outros 50 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "3 2\n2 3\n1 2",
        "4"
      ],
      [
        "3 0",
        "7"
      ],
      [
        "3 3\n1 2\n2 3\n1 3",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sanduiche"
    },
    "imagesQuant": 0
  },
  {
    "name": "Casamento de inteiros",
    "description": "Vamos definir a operação de casamento de dois números inteiros A e B da seguinte forma: • inicialmente fazemos A e B terem o mesmo número de dígitos, adicionando zeros à esquerda conforme necessário; • então cada dígito de A (do menos significativo ao mais significativo) é comparado com o dígito correspondente de B, e o dígito de menor valor é eliminado do número a que pertence (se os dígitos são iguais nenhum é eliminado).\n• o resultado da operação de casamento é o par de números inteiros formados pelos dígitos remanescentes de A e B. No caso de não haver digito remanescente para um dos números, o resultado para esse número é −1.\nPor exemplo, considere o casamento de 69961 com 487920:     9961     489 O resultado do casamento é o par de números 489 e 9961.\nDados dois números inteiros, sua tarefa é determinar o resultado do casamento desses dois números.\nEntrada\nA primeira linha da entrada contém um número inteiro A, a segunda linha contém um número inteiro B.\nSaída\nSeu programa deve produzir uma única linha, contendo os dois números inteiros produzidos pelo casamento dos números dados, em ordem não decrescente.\nRestrições\n• 1 ≤ A ≤ 109 • 1 ≤ B ≤ 109 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 22 pontos, 100 ≤ A ≤ 999 e 100 ≤ B ≤ 999.\n• Para um conjunto de casos de testes valendo outros 78 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: este exemplo corresponde ao exemplo mostrado no enunciado.\n  Explicação do exemplo 2: todos os dígitos são eliminados do segundo número.\n  Explicação do exemplo 3: o dígito 1 é eliminado dos dois números.\n  Explicação do exemplo 4: o dígito 1 é eliminado do segundo número.",
    "examples": [
      [
        "69961\n487920",
        "489 9961"
      ],
      [
        "5678\n1234",
        "-1 5678"
      ],
      [
        "21\n12",
        "2 2"
      ],
      [
        "200\n100",
        "0 200"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "casamento"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ogro",
    "description": "O Ogro da Nlogônia está aprendendo a contar até dez usando os dedos das mãos (assim como os humanos, ele possui 2 mãos com 5 dedos cada)). Ele está treinando muito, mas gostaria de ter um aplicativo para ajudá-lo nessa empreitada.\nO Ogro aprendeu a mostrar a representação de um número com as mãos da seguinte forma: • se o número pode ser representado usando apenas uma das mãos, o Ogro usa os dedos na mão esquerda e mantém a mão direita fechada.\n• caso contrário, o Ogro mostra todos os cinco dedos da mão esquerda, e na mão direita mostra os dedos que faltam para representar o número.\nPor exemplo, para o número 3, o Ogro mostra: III * onde cada letra I representa um dedo e a mão fechada é representada pelo símbolo ‘*’ (asterisco).\nPara o número 8 o Ogro mostra: IIIII III Sua tarefa é ajudar o Ogro em seu treinamento, escrevendo um programa para, dado um número entre 0 e 10, mostrar a configuração de dedos correspondente a esse número, de acordo com as regras acima.\nEntrada\nA primeira e única linha da entrada contém um inteiro N, o número que deve ser representado com os dedos das mãos.\nSaída\nSeu programa deve produzir duas linhas na saída. A primeira linha deve conter a representação dos dedos da mão esquerda, a segunda linha deve conter a representação dos dedos da mão direita. A letra ‘I’ deve ser usada para representar um dedo, e o caractere ‘*’ (asterisco) deve ser usado para representar a mão fechada (isto é, nenhum dedo mostrado).\nRestrições\n• 0 ≤ N ≤ 10   Explicação do exemplo 1: para representar o número 8 o Ogro mostra os cinco dedos da mão esquerda e três dedos da mão direita.\n  Explicação do exemplo 2: para representar o número 3 o Ogro mostra três dedos da mão esquerda e nenhum dedo na mão direita.\n  Explicação do exemplo 3: para representar o número zero o Ogro não mostra nenhum dedo da mão esquerda ou da mão direita.",
    "examples": [
      [
        "8",
        "IIIII\nIII"
      ],
      [
        "3",
        "III\n*"
      ],
      [
        "0",
        "*\n*"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "ogro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Sr. Sapo",
    "description": "O Sr. Sapo mora num lago de formato retangular dividido em um reticulado de células quadradas de um metro de lado. Algumas das células são pedras que estão acima do nível da água.\nO Sr. Sapo é muito atlético e pode saltar a distâncias de até três metros, mas curiosamente ele só pode saltar nas direções paralelas aos lados do lago. A figura (a) abaixo mostra um lago, e a figura (b) uma sequência de pulos do Sr. Sapo.\n1 2 3 4 1 2 3 4 1 S 1 2 pedra 2 3 3 4 água 4 5 R 5 (a) (b) O Sr. Sapo está em uma pedra e quer ir visitar sua namorada que está em outra pedra. Ele está com pressa e não quer se molhar, portanto quer chegar ao seu destino pulando de pedra em pedra, sem cair na água.\nDados o mapa do lago, a pedra em que o Sr. Sapo está e a pedra em que a sua namorada está, determine se é possível ele chegar ao seu destino sem se molhar.\nEntrada\nA primeira contém dois inteiros N, M, respectivamente a largura e o comprimento do lago em metros (ou seja, o lago é composto por N colunas e M linhas de células quadradas de 1m de lado).\nAs colunas são numeradas de 1 a N e as linhas são numeradas de 1 a M. A segunda linha contém um inteiro P, o número de células que são pedras. Cada uma das P linhas seguintes contém dois inteiros Ci e Li, respectivamente o número da coluna e o número da linha de uma célula que é pedra. A linha seguinte descreve a célula em que o Sr. Sapo está e contém dois inteiros SC e SL, respectivamente a coluna e a linha da célula. A linha seguinte descreve a célula em que está a namorada do Sr. Sapo e contém dois inteiros RC e RL, respectivamente a coluna e a linha da célula.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único caractere, que deve ser ‘S’ se for possível o Sr. Sapo chegar ao destino sem se molhar, ou ‘N’ caso contrário.\nRestrições\n• 3 ≤ N ≤ 100 • 1 ≤ M ≤ 100 • 2 ≤ P ≤ N × M • 1 ≤ Ci ≤ M e 1 ≤ Li ≤ M para 1 ≤ i ≤ P • 1 ≤ SC ≤ N e 1 ≤ SL ≤ M • 1 ≤ RC ≤ N e 1 ≤ RL ≤ M • As posições do Sr. Sapo e da sua namorada são distintas e ambas são posições de pedras especificadas na entrada.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 14 pontos, M = 1 • Para um conjunto de casos de testes valendo outros 16 pontos, para a pedra em que o Sr.\nSapo está inicialmente, há no máximo uma outra pedra para a qual ele pode saltar, e para todas as outras pedras, há no máximo duas para a qual ele pode saltar (ou seja, se o Sr. Sapo consegue chegar ao destino, há um único caminho de pedras que podem ser usadas, e esse caminho não tem \"bifurcações\").\n• Para um conjunto de casos de testes valendo outros 70 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: este exemplo corresponde à figura do enunciado. O Sr. Sapo pode usar as pedras (1,1) → (1,4) → (3,4) → (3,5) → (4,5) e assim consegue chegar ao destino.\n  Explicação do exemplo 2: este exemplo corresponde à seguinte figura: 1 2 3 4 1 R 2 3 4 S 5 O Sr. Sapo não consegue dar nenhum pulo e não consegue chegar ao seu destino.",
    "examples": [
      [
        "4 5\n6\n1 1\n2 2\n1 4\n3 4\n3 5\n4 5\n1 1\n4 5",
        "S"
      ],
      [
        "4 5\n6\n2 1\n2 5\n3 4\n4 1\n4 3\n4 5\n3 4\n2 1",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "sapo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Festa olímpica",
    "description": "Os atletas da Nlogônia obtiveram o melhor resultado do país em olimpíadas, e para comemorar o rei decidiu dar uma grande festa no Palácio Real. Todos os atletas foram convidados, mas o rei quer também convidar alguns de seus súditos.\nComo não é possível convidar todos os súditos, o rei determinou que a seguinte Lei seja utilizada para calcular a lista de convidados: lei especial sobre comemoração das olimpíadas Por ordem de Sua Majestade, fiquem todos sabendo que: • Os N súditos de Nlogônia serão numerados 1,2,3,...,N e uma lista ordenada será criada com os números dos súditos. A primeira posição da lista será 1.\n• Um número M de turnos serão então executados; em cada turno i, será sorteado um número Ti que será usado para remover súditos da lista, da seguinte forma: no turno i, devem ser removidos da lista todos os súditos que ainda continuam na lista e que ocupam posições que são múltiplas de Ti; ou seja, devem ser removidos os súditos que estão nas posições (Ti,2Ti,3Ti,...) da lista corrente. Ao final do turno, para não haver posições vazias na lista (cujos súditos foram removidos) a lista é reagrupada, mantendo-se a mesma ordem relativa, e contendo apenas os números dos súditos remanescentes.\n• Os súditos que permanecerem na lista ao final dos M turnos serão convidados para a grande festa de comemoração do resultado das olimpíadas.\nDados o número de súditos e os números sorteados em cada turno, sua tarefa é determinar os súditos que serão convidados de acordo com a Lei Especial.\nEntrada\nA primeira linha da entrada contém um número inteiro N, o número de súditos de Nlogôgina. A segunda linha contém um inteiro M, o número de turnos. Cada uma das M linhas seguintes contém um inteiro Ti, o número que foi sorteado para o turno i.\nSaída\nSeu programa deve produzir a lista de convidados de acordo com a Lei Especial, com uma linha para cada convidado, cada linha contendo somente o número de um convidado. Como a lista total dos convidados pode ser muito grande, o rei ordenou que, caso o número de convidados seja maior que 10.000, você deve listar apenas os 10.000 primeiros (ou seja, os com menores números) convidados.\nRestrições\n• 2 ≤ N ≤ 1 000 000 000 • 1 ≤ M ≤ 5 000 • 2 ≤ Ti ≤ 100 000 para 1 ≤ i ≤ M Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 17 pontos, N ≤ 100 e M ≤ 10.\n• Para um conjunto de casos de testes valendo outros 22 pontos, N ≤ 400 000 e M ≤ 5 000.\n• Para um conjunto de casos de testes valendo outros 21 pontos, Ti = 2 para 1 ≤ i ≤ M.\n• Para um conjunto de casos de testes valendo outros 40 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: A lista inicial é 1 2 3 4 5 6 7 8 9 10 Após remover todos os que ocupam posições múltiplas de 2 a lista é 1 3 5 7 9 Após remover todos os que ocupam posições múltiplas de 3 a lista é 1 3 7 9   Explicação do exemplo 2: A lista inicial é 1 2 3 4 5 6 Após remover todos os que ocupam posições múltiplas de 2 a lista é 1 3 5 Após remover todos os que ocupam posições múltiplas de 2 a lista é 1 5 Após remover todos os que ocupam posições múltiplas de 2 a lista é 1",
    "examples": [
      [
        "10\n2\n2\n3",
        "1\n3\n7\n9"
      ],
      [
        "6\n3\n2\n2\n2",
        "1"
      ],
      [
        "5\n1\n10",
        "1\n2\n3\n4\n5"
      ],
      [
        "1000000\n3\n2\n15\n3",
        "1\n3\n7\n9\n...\n32137\n32139"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "festa"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cubo e quadrado",
    "description": "O número 729 tem uma particularidade interessante: é ao mesmo tempo o cubo e o quadrado de um número inteiro (729 = 272 e 729 = 93). Outro número com essa particularidade é 4096 (4096 = 642 e 4096 = 163).\nSua tarefa é, dados dois números inteiros A e B, determinar quantos números no intervalo entre A e B são ao mesmo tempo cubo e quadrado de um número inteiro.\nEntrada\nA primeira da entrada contém um inteiro A, o limite inferior do intervalo de interesse, a segunda linha contém um inteiro B, o limite superior do intervalo de interesse (A e B fazem parte do intervalo de interesse).\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único inteiro, a quantidade de números que são ao mesmo tempo cubo e quadrado de um número inteiro, para todos os números do intervalo de interesse.\nRestrições\n• 1 ≤ A < B ≤ 100 000 000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 30 pontos, B ≤ 100 000.\n• Para um conjunto de casos de testes valendo outros 70 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: os números que são cubo e quadrado de um outro número no intervalo entre 64 e 729 são somente 64 e 729, portanto a resposta é 2.\n  Explicação do exemplo 2: 4096 é o único número no intervalo entre 3000 e 5000 que é cubo e quadrado de um outro número, portanto a resposta é 1.",
    "examples": [
      [
        "64\n729",
        "2"
      ],
      [
        "3000\n5000",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cubo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Falha de segurança",
    "description": "Rafael foi contratado como programador por um grande banco que está atualizando todo o sistema computacional. O novo sistema vai ser instalado amanhã, mas Rafael acabou de descobrir uma falha grave na nova autenticação para acesso às contas do banco: se um usuário digitar como senha uma cadeia de caracteres que contenha, como sub-cadeia contígua, a senha correta para esse usuário, o sistema se confunde e permite o acesso.\nPor exemplo, se a senha correta é ’senhafraca’ e o usuário digitar ‘quesenhafracameu’ ou ‘senhafraca123’, o sistema permite o acesso. Note que nesse caso o sistema não permite o acesso se o usuário digitar ‘senha’ ou ‘nhafra’ ou ‘senha123fraca’.\nO chefe de Rafael chamou um programador mais experiente para alterar a autenticação do novo sistema, mas solicitou que Rafael determinasse, para o conjunto de senhas existentes, quantos pares ordenados (A,B) de usuários distintos existem tal que o usuário A, usando sua senha, consegue acesso à conta do usuário B. Você poderia por favor ajudar Rafael? Entrada\nA primeira linha da entrada contém um número inteiro N, o número de usuários no sistema. Cada uma das N linhas seguintes contém uma senha Si, a senha do i-ésimo usuário.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de pares ordenados (A,B) de usuários distintos tal que o usuário A, usando sua senha, consegue acesso à conta do usuário B.\nRestrições\n• 1 ≤ N ≤ 20000 • Si inicia com letra minúscula sem acento e contém apenas letras minúsculas sem acento e dígitos de 0 a 9, para 1 ≤ i ≤ N • 1 ≤ comprimento de Si ≤ 10 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 12 pontos, comprimento de Si = 1 e N ≤ 1000.\n• Para um conjunto de casos de testes valendo outros 28 pontos, N ≤ 2000.\n• Para um conjunto de casos de testes valendo outros 60 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: o primeiro usuário consegue acesso à conta do terceiro usuário.\n  Explicação do exemplo 2: o primeiro usuário consegue acesso à conta do segundo usuário, o segundo usuário consegue acesso à conta do primeiro usuário, e o terceiro usuário consegue acesso à contas tanto do primeiro como do segundo usuário, totalizando quatro pares de usuários com falha de acesso.\n  Explicação do exemplo 3: o primeiro usuário consegue acesso à conta do quarto usuário, o segundo usuário consegue acesso às contas dos outros quatro usuários, o terceiro usuário consegue acesso à conta do quinto usuário, totalizando seis pares de usuários com falha de acesso.",
    "examples": [
      [
        "3\nxxx\nx23\nxx",
        "1"
      ],
      [
        "3\na\na\na8",
        "4"
      ],
      [
        "5\njus\njusta\nta\nus\nt",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "falha"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dona Minhoca",
    "description": "Dona Minhoca construiu uma bela casa, composta de N salas conectadas por N − 1 túneis. Cada túnel conecta exatamente duas salas distintas, e pode ser percorrido em qualquer direção. A casa de dona Minhoca foi construída de modo que, percorrendo os túneis, é possível partir de qualquer sala e chegar a qualquer outra sala da casa.\nDona Minhoca quer se exercitar, e para isso planeja construir um túnel adicional, de modo a criar um “ciclo” de salas e túneis. Vamos chamar de comprimento do ciclo o número de salas do ciclo.\nA figura (a) abaixo mostra um exemplo de casa. É possível obter um ciclo de comprimento três construindo um túnel entre as salas 2 e 5, ou um ciclo de comprimento quatro construindo um túnel entre as salas 1 e 3.\n2 2 2 1 4 1 4 1 4 3 5 3 5 3 5 (a) (b) (c) Dada a descrição da casa de dona Minhoca, escreva um programa para determinar o número de salas do ciclo de maior comprimento que é possível construir, e de quantas maneiras é possível construir um ciclo com esse comprimento.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de salas da casa de dona Minhoca. As salas são identificadas por números de 1 a N. Cada uma das N − 1 linhas seguintes contém dois inteiros X e Y , indicando que há um túnel entre a sala X e a sala Y .\nSaída\nSeu programa deve produzir duas linhas. A primeira linha deve conter somente um inteiro, o número de salas do ciclo de maior comprimento que é possível construir. A segunda linha deve conter somente um inteiro, o número de ciclos distintos que é possível contruir com esse comprimento.\nRestrições\n• 3 ≤ N ≤ 50 000 • 1 ≤ X ≤ N; 1 ≤ Y ≤ N; X (cid:54)= Y • nos testes, o número de possíveis ciclos distintos é menor do que 100 000 000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 40 pontos, N ≤ 5 000 • Para um conjunto de casos de testes valendo outros 60 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: este exemplo corresponde à figura do enunciado. O comprimento do maior ciclo possível é quatro, e há duas maneiras de conseguir um ciclo desse comprimento: criando um túnel entre as salas 1 e 3 ou entre as salas 1 e 5.\n  Explicação do exemplo 2: o comprimento do maior ciclo possível é cinco, e há seis maneiras de conseguir isso: criando um túnel entre os pares de salas (4,7) (4,8), (5,7), (5,8), (6,7) ou (6,8).",
    "examples": [
      [
        "5\n1 2\n2 4\n4 5\n4 3",
        "4\n2"
      ],
      [
        "8\n1 2\n2 3\n3 4\n3 6\n5 3\n1 8\n1 7",
        "5\n6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "minhoca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Teclado",
    "description": "Os teclados de telefones mostram teclas com os dígitos de 0 a 9, para que possamos digitar o número do telefone que queremos contactar, como na figura abaixo. Mas as teclas também mostram letras, que podem ser usadas por exemplo para facilitar a memorização de um número de telefone em particular. Por exemplo, para memorizar o número (74) 7622 3623 podemos associar esse número à cadeia de caracteres pipocadoce: 1 2 3 abc def 4 5 6 ( 7 4 ) 7 6 2 2 3 6 2 3 ghi jkl mno ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 7 8 9 p i p o c a d o c e pqrs tuv wxyz * 0 + # Claramente, um número pode ser representado por diferentes cadeias de caracteres. Por exemplo, o número 3482 pode ser representado por fita, diva, dita, egua, e muitas outras cadeias de caracteres.\nDados um número e uma lista de cadeias de caracteres, sua tarefa é determinar quantas cadeias de caracteres da lista podem representar o número dado.\nEntrada\nA primeira linha da entrada contém uma cadeia de caracteres N, o número de telefone. A segunda linha contém um inteiro M, o número de cadeias de caracteres na lista. Cada uma das M linhas seguintes contém uma cadeia de caracteres Ci.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único inteiro, o número de cadeias de caracteres da lista que podem representar o número dado.\nRestrições\n• 1 ≤ comprimento de N ≤ 1 000 • N contém apenas dígitos entre 2 e 9 • 1 ≤ M ≤ 1 000 • Ci contém apenas letras minúsculas não acentuadas, para 1 ≤ i ≤ M • 1 ≤ comprimento de Ci ≤ 1 000, para 1 ≤ i ≤ M • Ci são todas distintas para 1 ≤ i ≤ M Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 13 pontos, comprimento de N = 1 e M ≤ 20.\n• Para um conjunto de casos de testes valendo outros 87 pontos, nenhuma restrição adicional.\n  Explicação do exemplo 1: fita e diva são representações do número 3482.\n  Explicação do exemplo 2: apenas pipocadoce representa o número 7476223623.\n  Explicação do exemplo 3: nenhuma das cadeias de caracteres representa o número 4444.",
    "examples": [
      [
        "3482\n4\nfita\nregua\nmilho\ndiva",
        "2"
      ],
      [
        "7476223623\n5\npipoca\npipocadoce\nmisobafobe\ndoce\ndocepipoca",
        "1"
      ],
      [
        "4444\n3\nmono\ntudo\nnada",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2021,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "teclado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Cinema",
    "description": "Duas amigas estão na fila para comprar ingressos para uma sessão de cinema. O preço dos ingressos, em Reais, é dado na tabela abaixo:   Dadas as idades das amigas, escreva um programa para calcular o total a ser pago pelos dois ingressos.\nEntrada\nA entrada contém duas linhas, cada linha contendo um inteiro, a idade de uma das amigas.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, que deve ser o valor total em Reais a ser pago pelos dois ingressos.\nRestrições\n• 1 ≤ idade ≤ 100   Explicação do exemplo 1: Os valores dos ingressos para as idades 100 e 10 são respectivamente 20 e 15, portanto o total é 35.\n  Explicação do exemplo 2: Os valores dos ingressos para as idades 17 e 18 são respectivamente 15 e 30, portanto o total é 45.",
    "examples": [
      [
        "100\n10",
        "35"
      ],
      [
        "17\n18",
        "45"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cinema"
    },
    "imagesQuant": 0
  },
  {
    "name": "Hotel",
    "description": "O hotel da Colônia de Férias dos Professores está com uma promoção para as férias de julho. A promoção é válida para quem chegar a partir do dia 1 de julho e sair no dia 1 de agosto.\nO preço da diária do hotel é menor para quem chegar mais cedo, e vai aumentando a cada dia. Mais precisamente, a promoção funciona assim: • A diária do hotel para cada quem chegar no dia 1 é D Reais. Assim, quem chegar no dia 1 vai pagar um total de 31 × D Reais.\n• A diária do hotel aumenta A reais por dia. Ou seja, a diária é D + A Reais para quem chegar no dia 2; D + 2 × A Reais no dia 3; D + 3 × A Reais no dia 4 e assim por diante.\n• A partir do dia 16 a diária não aumenta mais.\nNote que quem chegar no dia 2 vai pagar um total de 30 × (D + A) reais; quem chegar no dia 3 vai pagar um total de 29 × (D + 2 × A) reais, e assim por diante.\nBruno gosta muito da professora Vilma, e para agradá-la quer ajudá-la a planejar suas férias, escrevendo um programa para calcular o total (em Reais) que a professora Vilma vai gastar, dependendo do dia em que chegar no hotel.\nEntrada\nA primeira linha contém um inteiro D, o valor da diária no dia 1. A segunda linha contém um inteiro A, o aumento da diária a cada dia a partir do dia 2 até o dia 15 (inclusive). A terceira linha contém um inteiro N, o dia de chegada no hotel.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, que deve ser o valor total a ser pago ao hotel pela estadia.\nRestrições\n• 1 ≤ D ≤ 1 000 • 1 ≤ A ≤ 1 000 • 1 ≤ N ≤ 31 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, N = 1.\n  Explicação do exemplo 1: Como a chegada é no dia 1, o valor da diária com a promoção é 100.\nDo dia 1 ao dia 31 são 31 diárias. Assim, o total a pagar é 31 × 100.\n  Explicação do exemplo 2: Como a chegada é no dia 15, o valor da diária com a promoção é 100 + 14 × 20 = 380. Do dia 15 ao dia 31 são 17 diárias. Assim, o total a pagar é 17 × 380 = 6460.\n  Explicação do exemplo 3: Como a chegada é no dia 16, o valor da diária com a promoção é 100 + 14 × 5 = 170. Do dia 16 ao dia 31 são 16 diárias. Assim, o total a pagar é 16 × 170 = 2720.",
    "examples": [
      [
        "100\n10\n1",
        "3100"
      ],
      [
        "100\n20\n15",
        "6460"
      ],
      [
        "100\n5\n16",
        "2720"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "hotel"
    },
    "imagesQuant": 0
  },
  {
    "name": "Quadrado Mágico",
    "description": "Em um Quadrado Mágico, a soma de qualquer coluna, linha ou diagonal tem sempre o mesmo valor, e nenhum número aparece mais do que uma vez.\n15 2 9 4 2 9 4 15 7 5 3 7 5 3 15 6 1 8 6 1 8 15 15 15 15 15 A dimensão de um quadrado mágico é o número de colunas (ou de linhas, já que o número de colunas é igual ao número de linhas).\nRita encontrou um caderno antigo de sua avó, repleto de quadrados mágicos de todas as dimensões.\nInfelizmente alguns dos números estão ilegíveis. Você pode ajudá-la? Dado um quadrado mágico com exatamente um número ilegível, determine o valor e a posição desse número.\nEntrada\nA primeira linha da entrada contém um número inteiro N, a dimensão do quadrado mágico. Cada uma das N linhas seguintes contém N inteiros Xi. Exatamente um dos números do quadrado da entrada é igual a zero, indicando o número ilegível.\nSaída\nSeu programa deve produzir três linhas, cada uma contendo um único número inteiro. A primeira linha deve conter o valor do número ilegível. A segunda linha deve conter a linha do número ilegível no quadrado (as linhas do quadrado variam de 1 a N). A terceira linha deve conter a coluna do número ilegível no quadrado (as colunas do quadrado variam de 1 a N).\nRestrições\n• 3 ≤ N ≤ 10 • 0 ≤ Xi ≤ 100, para 1 ≤ i ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, 1 ≤ N ≤ 3.\n  Explicação do exemplo 1: O valor do número ilegível é 5 e sua posição é linha 2 e coluna 2.\n  Explicação do exemplo 2: O valor do número ilegível é 10 e sua posição é linha 1 e coluna 4.",
    "examples": [
      [
        "3\n2 9 4\n7 0 3\n6 1 8",
        "5\n2\n2"
      ],
      [
        "4\n11 8 5 0\n14 1 4 15\n2 13 16 3\n7 12 9 6",
        "10\n1\n4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "magico"
    },
    "imagesQuant": 0
  },
  {
    "name": "Show",
    "description": "Um grupo de amigos quer comprar ingressos para um show da sua banda preferida. O show acontece num teatro que tem N filas de assentos, cada fila com M assentos.\nOs amigos querem comprar ingressos de forma que os assentos dos amigos: • sejam todos na mesma fila, • sejam contíguos (ou seja, um vizinho ao outro) e • sejam na fila mais próxima possível do palco.\nDado um mapa descrevendo os assentos disponíveis, ajude os amigos a encontrarem os ingressos de acordo com as condições acima.\nEntrada\nA primeira linha contém três inteiros A, N e M, indicando respectivamente o número de amigos, o número de filas de assentos e o número de assentos em cada fila do teatro. As filas são numeradas de 1 (mais próxima do palco) até N (mais distante do palco). Cada uma das N linhas seguintes contém M inteiros Xi, que podem ter o valor 1 (representando um assento ocupado) ou o valor 0 (representando um assento não ocupado). As filas de assentos são dadas da fila mais distante para a fila mais próxima do palco. Ou seja, a primeira fila dada na entrada é a fila N (mais distante do palco), a última fila dada na entrada é a fila 1 (mais próxima do palco).\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, que deve ser o número da fila em que os amigos conseguem comprar os ingressos se é possível encontrar ingressos de acordo com as condições dadas, ou −1 caso contrário.\nRestrições\n• 2 ≤ A ≤ 100 • 1 ≤ N ≤ 100 • 1 ≤ M ≤ 100 • 0 ≤ Xi ≤ 1 para 1 ≤ i ≤ M Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N = 1.\n  Explicação do exemplo 1: São 4 amigos e o teatro tem 3 filas com 5 cadeiras cada fila. A melhor opção é a fila 1, embora os quatro amigos possam também comprar os ingressos na fila 3. Na fila 2 não há cadeiras vagas suficientes.\n  Explicação do exemplo 2: São 2 amigos e o teatro tem 3 filas com 5 cadeiras cada fila. Nenhuma fila tem 2 cadeiras vagas contíguas.\n  Explicação do exemplo 3: São 3 amigos e o teatro tem 6 filas com 4 cadeiras cada fila. As únicas filas com cadeiras vagas suficientes são a fila 5 e a fila 6, então a melhor opção é a fila 5.",
    "examples": [
      [
        "4 3 5\n0 0 0 0 0\n1 0 0 0 1\n1 0 0 0 0",
        "1"
      ],
      [
        "2 3 5\n0 1 0 1 0\n0 1 0 1 0\n0 1 0 1 0",
        "-1"
      ],
      [
        "3 6 4\n0 0 0 0\n1 0 0 0\n1 1 0 0\n1 1 1 0\n1 1 1 1\n1 1 1 1",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "show"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bombom",
    "description": "Bombom é um jogo de cartas para duas pessoas, jogado com apenas dezesseis cartas: Ás, Valete, Dama e Rei, nos quatro naipes (Copas, Espadas, Ouros e Paus). Cada carta tem um valor, que depende da figura e do naipe.\nA cada partida, as cartas são embaralhadas e colocadas em um monte. Inicialmente uma carta do monte é virada e mostrada aos dois jogadores: o naipe dessa carta é chamado de naipe dominante da partida.\nEntão cada jogador recebe três cartas do monte. Ganha a partida o jogador que tem as cartas cuja soma dos valores é maior.\nO valor das cartas é dado na tabela abaixo:   Luana e Edu estão jogando Bombom e querem sua ajuda para determinar o vencedor da partida, ou se há empate.\nEntrada\nA entrada contém sete linhas, cada linha contendo a descrição de uma carta. Cada carta é descrita por duas letras. A primeira letra de uma carta indica a figura e pode ser A, J, Q ou K, representando respectivamente as figuras Ás, Valete, Dama e Rei. A segunda letra de uma carta indica o naipe e pode ser C, E, O ou P, representando respectivamente os naipes Copas, Espadas, Ouros e Paus. O naipe da primeira carta da entrada é o naipe dominante da partida. A segunda, terceira e quarta cartas da entrada são as cartas de Luana. A quinta, sexta e sétima cartas da entrada são as cartas de Edu.\nSaída\nSeu programa deve produzir uma única linha, contendo somente o nome do jogador que ganha a partida, ou empate caso não haja um ganhador.\nRestrições\n• As cartas na entrada obedecem ao formato descrito no enunciado.\n• Não há cartas repetidas na entrada.\n  Explicação do exemplo 1: O naipe dominante é Copas. As cartas de Luana valem 15 + 11 + 11 = 37; as cartas de Edu valem 13 + 13 + 12 = 38. Assim, Edu é o vencedor.\n  Explicação do exemplo 2: O naipe dominante é Paus. As cartas de Luana valem 12 + 10 + 17 = 39; as cartas de Edu valem 13 + 13 + 13 = 39. Assim, há empate.\n  Explicação do exemplo 3: O naipe dominante é Espadas. As cartas de Luana valem 16 + 10 + 14 = 40; as cartas de Edu valem 10 + 13 + 15 = 38. Assim, Luana é a vencedora.",
    "examples": [
      [
        "AC\nJC\nJE\nJP\nKO\nKP\nQE",
        "Edu"
      ],
      [
        "QP\nQC\nAC\nKP\nKO\nKE\nKC",
        "empate"
      ],
      [
        "KE\nQE\nAC\nAE\nAP\nKO\nJE",
        "Luana"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bombom"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chuva",
    "description": "Eventos climáticos extremos como chuvas descomunais estão cada vez mais frequentes e intensos em todo o mundo.\nO Centro Nacional de Monitoramento da Nlogônia tem medidores de quantidade de chuva dia-a-dia espalhados por todo o reino. Cada medição é um número inteiro, indicando a quantidade de chuva, em milímetros, que caiu na Nlogônia num determinado dia. Como o sistema existe há vários anos, a lista de medições é muito grande.\nPreocupado com o assunto, o rei da Nlogônia mandou que o Ministro da Ciência crie um programa de computador para calcular quantos intervalos de dias existem na lista de medições tal que a soma das medições nesse intervalo é igual a um certo valor.\nMais precisamente, considere uma lista com N medições, indicando a quantidade de chuva do dia 1 ao dia N. Considere ainda todos os possíveis intervalos de dias entre 1 e N, cada intervalo definido pelo dia inicial e dia final do intervalo. O rei deseja saber quantos intervalos têm a soma das medições exatamente igual a um certo valor S.\nO Ministro da Ciência é um físico brilhante, mas não sabe resolver essa tarefa. Você poderia ajudá-lo? Entrada\nA primeira linha contém um inteiro N, o número de medições na lista. A segunda linha contém um inteiro S, o valor da soma desejada. A terceira linha contém N inteiros Xi, os valores das medições.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, que deve ser o número de intervalos que têm a soma das medições igual a S.\nRestrições\n• 1 ≤ N ≤ 100 000 • 0 ≤ S ≤ 1 000 000 • 0 ≤ Xi ≤ 10, para 1 ≤ i ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 300.\n• Para um outro conjunto de casos de testes valendo 30 pontos, N ≤ 1000.\n  Explicação do exemplo 1: São 6 os intervalos com soma igual a 2: [2], [0,2], [2,0], [0,2,0], [1,0,1] e [0,1,0,1]   Explicação do exemplo 2: Não há intervalo com soma igual a 13.\n  Explicação do exemplo 3: Há apenas um intervalo com soma igual a 6: [1, 0, 3, 0, 2].",
    "examples": [
      [
        "6\n2\n0 2 0 1 0 1",
        "6"
      ],
      [
        "8\n13\n10 1 0 0 9 10 1 5",
        "0"
      ],
      [
        "5\n6\n1 0 3 0 2",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chuva"
    },
    "imagesQuant": 0
  },
  {
    "name": "Maior valor",
    "description": "Nesta tarefa, dados três números inteiros N, M e S você deve escrever um programa para determinar o maior número inteiro I tal que • I está dentro do intervalo [N,M] (ou seja, I ≥ N e I ≤ M).\n• A soma dos dígitos de I é igual a S.\nEntrada\nA primeira linha contém um inteiro N, o menor valor do intervalo. A segunda linha contém um inteiro M, o maior valor do intervalo. A terceira linha contém um inteiro S, o valor da soma dos dígitos, conforme descrito.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, que deve ser o valor de I obedecendo às restrições acima, ou −1 se não existir.\nRestrições\n• 1 ≤ N ≤ M ≤ 10 000 • 1 ≤ S ≤ 36 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, M ≤ 100.\n  Explicação do exemplo 1: 60 é o maior inteiro no intervalo [1,100] cuja soma dos dígitos é igual a 6.\n  Explicação do exemplo 2: Não há número inteiro no intervalo [1000,1001] cuja soma dos dígitos é igual a 3.\n  Explicação do exemplo 3: 480 é o maior inteiro no intervalo [80,500] cuja soma dos dígitos é igual a 12.",
    "examples": [
      [
        "1\n100\n6",
        "60"
      ],
      [
        "1000\n1001\n3",
        "-1"
      ],
      [
        "80\n500\n12",
        "480"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "maior"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caminho",
    "description": "caminho.py A pista de treinos de corridas da Prefeitura tem formato circular, com N postes igualmente espaçados na circunferência da pista, cada poste com exatamente uma lâmpada. Atualmente há lâmpadas de várias potências luminosas nos postes.\nVamos chamar o trecho de pista entre duas lâmpadas adjadentes (ou seja, uma vizinha à outra) de trecho escuro se a soma das potências luminosas dessas duas lâmpadas é menor do que 1000.\nPara justificar um pedido à Prefeitura para que troquem as lâmpadas, os atletas querem saber qual o maior número de trechos escuros consecutivos (ou seja, um imediatamente em seguida de outro) da pista. Você pode ajudá-los? Entrada\nA primeira linha da entrada contém um inteiro N, o número de postes. Cada uma das N linhas seguintes contém um inteiro Pi, a potência luminosa de uma lâmpada. A posição de cada lâmpada é dada pela ordem da entrada (ou seja, a ordem das lâmpadas ao longo da pista é a ordem dada na entrada).\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o maior número de trechos escuros consecutivos.\nRestrições\n• 2 ≤ N ≤ 500 000 • 1 ≤ Pi ≤ 1 000 para i ≤ i ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 40 pontos, P1 + PN ≥ 1 000.\nExemplos\nExplicação do exemplo 1: O maior (e único) caminho de pares de lâmpadas com potência luminosa abaixo do especificado é formado pelos pares (499,500), (500, 499) e (499, 499), portanto a resposta é 3.\n  Explicação do exemplo 2: O único par de lâmpadas com potência luminosa abaixo do especificado é (700,100), portanto a resposta é 1.\n  Explicação do exemplo 3: O maior (e único caminho) com pares de lâmpadas com potência menor do que o especificado é formado pelos pares (290,700), (700,200), (200,400) e (400,500), portanto a resposta é 4.\n  Explicação do exemplo 4: Não há nenhum par de lâmpadas com potência abaixo do especificado, portanto a resposta é 0.\n  Explicação do exemplo 5: O maior (e único caminho) com pares de lâmpadas com potência menor do que o especificado é formado pelos pares (100,101) e (101,100), portanto a resposta é 2.",
    "examples": [
      [
        "3\n499\n500\n499",
        "3"
      ],
      [
        "6\n900\n700\n100\n900\n200\n700",
        "1"
      ],
      [
        "6\n500\n800\n290\n700\n200\n400",
        "4"
      ],
      [
        "2\n500\n600",
        "0"
      ],
      [
        "2\n100\n101",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caminho"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pirâmide",
    "description": "piramide.py O rei da Nlogônia decidiu construir uma pirâmide no jardim do Palácio Real, usando cubos de pedra de mesmo tamanho. A dimensão de uma pirâmide é o número de cubos de pedra num dos lados da base (primeira camada) da pirâmide. A base da pirâmide é quadrada, ou seja, cada lado tem o mesmo número de cubos de pedra.\nNa pirâmide, a partir da segunda camada, cada cubo de pedra deve ser empilhado exatamente em cima de outro cubo de pedra que não esteja na borda da camada abaixo. Além disso, o número de camadas deve ser o maior possível para uma dada dimensão, e em cada camada deve ser usado o maior número de cubos de pedra possível.\nA figura abaixo à esquerda mostra uma pirâmide de dimensão 3; a figura à direita mostra o plano de contrução para essa pirâmide, indicando quantos cubos de pedra devem ser empilhados em cada posição.\n  1 1 1 O rei ainda não decidiu qual a dimensão da pirâmide que vai construir, mas como é muito detalhista já avisou os Arquitetos Reais que antes de iniciar a contrução eles devem produzir um plano de contrução para a dimensão escolhida.\nAjude os Arquitetos Reais, escrevendo um programa que, dada a dimensão da pirâmide, produza o seu plano de construção.\nEntrada\nA primeira e única linha da entrada contém um número inteiro N, a dimensão da pirâmide.\nSaída\nSeu programa deve produzir o plano de contrução da pirâmide, constituído por N linhas, cada linha contendo N números inteiros.\nRestrições\n• 1 ≤ N ≤ 100 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, 1 ≤ N ≤ 3.\nExemplos\nExemplo de entrada 1 Exemplo de saída 1 3   1 1 1 Explicação do exemplo 1: Para uma pirâmide de dimensão 3, o maior número de camadas possível é 2.\n  Explicação do exemplo 2: Para uma pirâmide de dimensão 8, o maior número de camadas possível é 4.",
    "examples": [
      [
        "3",
        "1 1 1\n1 2 1\n1 1 1"
      ],
      [
        "8",
        "1 1 1 1 1 1 1 1\n1 2 2 2 2 2 2 1\n1 2 3 3 3 3 2 1\n1 2 3 4 4 3 2 1\n1 2 3 4 4 3 2 1\n1 2 3 3 3 3 2 1\n1 2 2 2 2 2 2 1\n1 1 1 1 1 1 1 1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "piramide"
    },
    "imagesQuant": 0
  },
  {
    "name": "Troféu",
    "description": "Cinco alunos e alunas da escola conseguiram classificar-se para a Final da prestigiosa e muito difícil Competição Estadual de Programação, que será realizada no próximo mês.\nIndependentemente da classificação que os alunos da escola conseguirem na Final, a direção da escola decidiu que vai fazer uma premiação para os seus alunos. Quem conseguir a maior pontuação na Final, entre os alunos da escola, vai receber um troféu. E quem receber a segunda maior pontuação, entre os alunos da escola, vai receber uma placa comemorativa.\nO problema é que pode haver alunos com as mesmas pontuações, de forma que dependendo dos resultados muitas combinações de prêmios são possíveis, como por exemplo, entre outros: • cinco troféus (empate, todos com a mesma pontuação) • um troféu (maior pontuação) e duas placas (empate na segunda maior pontuação) • dois troféus (empate na maior pontuação) e duas placas (empate na segunda maior pontuação) Dadas as pontuações dos cinco alunos e alunas, determine quantos troféus e placas deverão ser entregues.\nEntrada\nA entrada consiste de cinco linhas, cada uma contendo um inteiro Pi a pontuação de um aluno ou aluna. As pontuações serão dadas em ordem decrescente (ou seja, da maior para a menor pontuação).\nSaída\nSeu programa deve produzir uma única linha, contendo dois inteiros. O primeiro inteiro deve ser o número de troféus e o segundo inteiro o número de placas comemorativas a serem entregues.\nRestrições\n• 1 ≤ Pi ≤ 100 Exemplos\nExplicação do exemplo 1: A maior pontuação (100) ganha o troféu. A segunda maior pontuação (90) ganha a placa comemorativa.\n  Explicação do exemplo 2: Há um empate na maior pontuação (100), portanto os dois ganham troféus. A segunda maior pontuação (90) ganha a placa comemorativa.\n  Explicação do exemplo 3: Há um empate na maior pontuação (99), portanto os cinco ganham troféus. Não há entrega de placa comemorativa neste caso.",
    "examples": [
      [
        "100\n90\n80\n70\n60",
        "1 1"
      ],
      [
        "100\n100\n90\n89\n77",
        "2 1"
      ],
      [
        "99\n99\n99\n99\n99",
        "5 0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "trofeu"
    },
    "imagesQuant": 0
  },
  {
    "name": "Câmeras",
    "description": "cameras.py Uma exposição vai ser montada num espaço retangular, dividido em N ×M células dispostas em N colunas por M linhas. Uma célula é o espaço delimitado pela interseção de uma coluna com uma linha. As colunas estão na direção Norte-Sul e as linhas na direção Oeste-Leste. Para segurança das obras foram instaladas K câmeras, em células selecionadas. Cada câmera pode estar apontada para uma de quatro direções: Norte, Sul, Leste ou Oeste. Uma câmera observa todas as células da coluna ou linha na direção em que está apontada, a partir da célula em que está instalada (incluindo a célula em que está instalada).\nA porta de entrada da exposição está na célula mais ao norte e mais à oeste, a porta de saída está na célula mais ao sul e mais ao leste. A figura abaixo ilustra um espaço de exposição com 6 colunas, 5 linhas e 5 câmeras instaladas.\nentrada N câmera O L caminho do visitante S saída Preocupado com a segurança, o organizador da exposição deseja saber se é possível que um visitante entre pela porta de entrada e saia pela porta de saída, movendo-se somente nas quatro direções (Norte, Sul, Leste ou Oeste) sem que seja observado por qualquer das câmeras instaladas.\nEntrada\nA primeira linha contém três inteiros N, M e K indicando respectivamente o número de colunas, o número de linhas e o número de câmeras instaladas. As colunas estão numeradas de 1 a N e as linhas estão numeradas de 1 a M. A coluna 1 é a coluna mais à Oeste e a linha 1 é a linha mais ao Norte. Cada uma das K linhas seguintes descreve uma câmera e contém dois inteiros Ci, Li e um caractere Di, indicando respectivamente a coluna, a linha e a direção em que a câmera está instalada. O caractere Di pode ser N, S, L ou O, indicando respectivamente que a câmera está instalada direcionada para o Norte, Sul, Leste ou Oeste.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser S se é possível que um visitante entre pela porta de entrada e saia pela porta de saída sem que seja observado por qualquer das câmeras instaladas, ou N caso contrário.\nRestrições\n• 2 ≤ N ≤ 30; 2 ≤ M ≤ 30; 1 ≤ K ≤ 30 • 1 ≤ Ci ≤ N, para 1 ≤ i ≤ K • 1 ≤ Li ≤ M, para 1 ≤ i ≤ K • Di pode ser N, S, L ou O.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 10 pontos, M = 2 e K = 1.\n• Para um conjunto de casos de testes valendo outros 10 pontos, N = 3, M = 3 e K = 2.\n• Para um conjunto de casos de testes valendo outros 80 pontos, nenhuma restrição adicional.\nExemplos\nExplicação do exemplo 1: Neste caso a resposta é Não.\n  Explicação do exemplo 2: Neste caso a resposta é Sim.\n  Explicação do exemplo 3: Este caso é o exemplo dado no enunciado.",
    "examples": [
      [
        "4 5 2\n2 2 O\n3 3 L",
        "N"
      ],
      [
        "5 4 2\n2 3 N\n4 2 S",
        "S"
      ],
      [
        "6 5 5\n1 2 S\n3 2 N\n5 2 N\n3 4 O\n5 4 L",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "cameras"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tanque de combustível",
    "description": "Cássio alugou um carro para a viagem de férias. O carro tem consumo de combustível constante (em kilometros rodados por litro de combustível), independente da velocidade com que trafega. Ao fim da viagem, Cássio deve devolver o carro no aeroporto.\nCássio está terminando sua viagem de férias e está no momento na rodovia que leva ao aeroporto, em direção ao aeroporto para devolver o carro. Mais precisamente Cássio está no último posto de combustível existente na rodovia em que ele pode abastecer o carro antes de devolvê-lo.\nPara economizar o máximo possível em combustível, Cássio quer devolver o carro com o menor número de litros possível no tanque – idealmente, com o tanque zerado, ou seja, sem combustível.\nDados o consumo do carro, a distância em que se encontra do aeroporto e a quantidade de combustível presente no tanque antes do abastecimento, determine qual deve ser a menor quantidade de combustível que Cássio deve comprar.\nEntrada\nA primeira linha contém um inteiro, C, o consumo do carro em kilômetros rodados por litro de combustível. A segunda linha contém um inteiro D, a distância do aeroporto, em kilometros. A terceira linha contém um inteiro T, o número de litros de combustível presente no tanque antes do abastecimento. Você pode assumir que o tanque tem capacidade suficiente para armazenar todo o combustível que Cássio comprar.\nSaída\nSeu programa deve produzir uma única linha, contendo um único valor, com um dígito de precisão, indicando a quantidade de combustível que Cássio deve comprar, para chegar ao aeroporto com o tanque contendo a menor quantidade de combustível possível.\nRestrições\n• 1 ≤ C ≤ 50 • 1 ≤ D ≤ 1000 • 0 ≤ T ≤ 100 Exemplos\nExplicação do exemplo 1: O consumo é 2 km/l, Cássio está a 10 km do aeroporto e o tanque não tem combustível. Para chegar ao aeroporto o carro vai gastar 5.0 litros de combustível.\nComo o tanque não tem combustível, Cássio precisa comprar 5.0 litros de combustível.\n  Explicação do exemplo 2: O consumo é 30 km/l, Cássio está a 100 km do aeroporto e o tanque tem 2 litros combustível. Para chegar ao aeroporto o carro vai gastar 3.33 litros de combustível.\nComo o tanque já tem 2 litros de combustível, Cássio precisa comprar 1.3 litros de combustível (note o arredondamento).\n  Explicação do exemplo 3: O consumo é 50 km/l, Cássio está a 120 km do aeroporto e o tanque tem 3 litros combustível. Para chegar ao aeroporto o carro vai gastar 2.4 litros de combustível.\nComo o tanque já tem 3 litros de combustível, Cássio não precisa comprar combustível.\n  Explicação do exemplo 4: O consumo é 50 km/l, Cássio está a 73 km do aeroporto e o tanque não tem combustível. Para chegar ao aeroporto o carro vai gastar 1.46 litros de combustível.\nComo o tanque não tem combustível, Cássio precisa comprar 1.5 litros de combustível (note o arredondamento).",
    "examples": [
      [
        "2\n10\n0",
        "5.0"
      ],
      [
        "30\n100\n2",
        "1.3"
      ],
      [
        "50\n120\n3",
        "0.0"
      ],
      [
        "50\n73\n0",
        "1.5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "tanque"
    },
    "imagesQuant": 0
  },
  {
    "name": "Subcadeias",
    "description": "subcadeias.js ou subcadeias.py Uma cadeia de caracteres é um palíndromo se os caracteres aparecem exatamente na mesma sequência quando lemos a cadeia da esquerda para a direita, ou da direita para a esquerda. Por exemplo, as cadeias osso e arara são palíndromos, mas as cadeias xy e abbbab não são palíndromos.\nUma subcadeia de uma dada cadeia de caracteres um é trecho contínuo da cadeia. Por exemplo, abc, bc e d são subcadeias de abcde, mas abe e ded não são.\nO comprimento de uma cadeia de caracteres (ou subcadeia) é o número de caracteres da cadeia (ou subcadeia).\nDada uma cadeia de caracteres, determine o comprimento da maior subcadeia que é um palíndromo.\nEntrada\nA primeira linha da entrada contém um inteiro N, o comprimento da cadeia de caracteres. A segunda linha da entrada contém os N caracteres Ci que compõem a cadeia de caracteres.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o comprimento da maior subcadeia da cadeia da entrada que é um palíndromo.\nRestrições\n• 1 ≤ N ≤ 500 • Ci é uma letra minúscula não acentuada, para 1 ≤ i ≤ N.\nExemplos\nExplicação do exemplo 1: As subcadeias que são palíndromos são: v, o, s, r, i, m, ss, vov, ovo, rir, iri, osso, mirim. A de maior comprimento é mirim, com comprimento 5.\n  Explicação do exemplo 2: As subcadeias que são palíndromos são: a, b, x, xx, xxx, xxxx, bxxxxb, abxxxxba. A de maior comprimento é abxxxxba, com comprimento 8.",
    "examples": [
      [
        "15\nvovossorirmirim",
        "5"
      ],
      [
        "8\nabxxxxba",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "subcadeias"
    },
    "imagesQuant": 0
  },
  {
    "name": "Viagem",
    "description": "Você está viajando pelo arquipélago de Kiri, que é composto por um grande número de ilhas. Não há pontes entre as ilhas, de modo que a única maneira de viajar entre as ilhas é por navio.\nHá várias rotas de navios disponíveis. Cada rota conecta duas ilhas distintas A e B e pode ser usada nas duas direções (de A para B ou de B para A). Cada rota tem um certo tempo de percurso (o mesmo nas duas direções) e um custo (o mesmo nas duas direções).\nNo momento você quer ir da ilha X para outra ilha Y , mas quer gastar no máximo um certo valor com a viagem. Você também está com pressa e gostaria de chegar o mais rapidamente possível ao seu destino.\nDados a lista das rotas disponíveis, com seus custos e tempos de percurso, escreva um programa para determinar se é possível chegar ao destino gastando no máximo o valor previsto para a viagem, e nesse caso qual o menor tempo para chegar ao destino. Note que pode não ser possível chegar ao destino, seja porque não há rota disponível ou porque o valor alocado para a viagem não é suficiente.\nPor exemplo, considere o caso mostrado na figura abaixo, em que você está na ilha 1 e quer ir para a ilha 4: T= 6, P=12 T=1 8, P= 1 T T= = 4 7, , PP == 24 2 T= 2, P 3= 2 T= T1 = , 1P , = P =6 1 4 T P= = t e cum sp too dd ao pp ae src su ar gs eo m 1. Se o valor previsto é 10, a resposta é 5 e o caminho ótimo é 1 → 2 → 4. Note que este caminho custa 4 + 6 = 10 e demora tempo 4 + 1 = 5.\n2. Se o valor previsto é 7, a resposta é 7 e o caminho ótimo é 1 → 2 → 3 → 4, que custa 4 + 2 + 1 = 7 e demora tempo 4 + 2 + 1 = 7.\n3. Se o valor previsto é 3, a resposta é 8 e o caminho ótimo é 1− > 3− > 4, usando a aresta entre 1 e 3 que demora tempo 7 e tem custo 2. Note que este caminho custa 2 + 1 = 3 e demora tempo 7 + 1 = 8.\n4. Se o valor previsto é 2, a resposta é 9 e o caminho ótimo é 1− > 3− > 4, usando a aresta entre 1 e 3 que demora tempo 8 e tem custo 1, note que este caminho custa 1 + 1 = 2 e demora tempo 8 + 1 = 9.\n5. Se o valor previsto é 1, não existe caminho que satisfaça as restrições, por isso a resposta é −1.\nEntrada\nA primeira linha da entrada contém três inteiros V , N e M, respectivamente o valor disponível para a viagem, o número de ilhas e o número de rotas. As ilhas são identificadas por inteiros de 1 a N.\nCada uma das M linhas seguintes descreve uma rota e contém quatro inteiros Ai, Bi, Ti e Pi, onde Ai e Bi representam ilhas, Ti o tempo de percurso e Pi o custo de uma passagem para essa rota. A última linha da entrada contém dois inteiros X e Y , o início e o destino da sua viagem.\nSaída\nSeu programa deve produzir uma única linha na saída, que deve conter um único inteiro, o menor tempo necessário para chegar ao destino, ou o valor −1 caso não seja possível chegar ao destino.\nRestrições\n• 2 ≤ N ≤ 10 000 • 1 ≤ M ≤ 2 000 • 1 ≤ V ≤ 200 • 1 ≤ Ai,Bi ≤ N, Ai (cid:54)= Bi, para 1 ≤ i ≤ M.\n• Pode haver mais de uma rota entre o mesmo par de ilhas.\n• 1 ≤ Ti ≤ 100 000, para 1 ≤ i ≤ M.\n• 0 ≤ Pi ≤ 200, para 1 ≤ i ≤ M.\n• 1 ≤ X,Y ≤ N Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 20 pontos, N ≤ 200 e Pi = 0 para 1 ≤ i ≤ M.\n• Para um conjunto de casos de testes valendo outros 10 pontos, N ≤ 10 000 e Pi = 0 para 1 ≤ i ≤ M.\n• Para um conjunto de casos de testes valendo outros 30 pontos, N ≤ 100 e V ≤ 10.\n• Para um conjunto de casos de testes valendo outros 40 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "10 4 7\n1 2 4 4\n1 3 7 2\n3 1 8 1\n3 2 2 2\n4 2 1 6\n3 4 1 1\n1 4 6 12\n1 4",
        "5"
      ],
      [
        "3 3 3\n1 2 5 2\n3 2 8 2\n1 3 1 4\n1 3",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "viagem"
    },
    "imagesQuant": 0
  },
  {
    "name": "Carro elétrico",
    "description": "O mapa ao lado mostra o reino de Quadradônia. As estradas são representadas por linhas e as cidades por círculos nume- 1 rados de 1 a 10. As estradas são igualmente espaçadas com distância de 100 km entre cada par de estradas, sendo ori- 3 entadas em apenas duas direções: Norte-Sul e Leste-Oeste.\nN Uma empresa de aluguel de carros em Quadradônia utiliza apenas carros elétricos. A autonomia de um carro elétrico é 2 O L a distância que ele pode percorrer com uma carga de energia; S após essa distância o carro deve ser carregado novamente para que possa ser utilizado. Há carregadores de energia 5 6 em cada cidade e não há carregadores de energia fora das 4 cidades. Entre cidades, os carros trafegam apenas pelas estradas e todos os carros têm a mesma autonomia.\nUm vendedor deseja partir da cidade 1 e visitar todas as outras cidades, em qualquer ordem, mesmo que ele visite a mesma cidade mais de uma vez. Ele quer utilizar preferencialmente carros elétricos na sua viagem, mas se necessário viajará de avião se a distância para a próxima cidade for maior do que a autonomia do carro. Por exemplo, no mapa acima, se a autonomia for 300 km, o vendedor pode alugar um carro em 1 e visitar 3 e depois 2, mas não pode alcançar as outras cidades. Então ele pode viajar de avião até 5, alugar um carro visitar 6, depois viajar de avião até 4. Assim, são necessárias duas viagens de avião para ele visitar todas as cidades.\nDados o mapa da Quadradônia e a autonomia dos carros, determine qual o menor número de viagens de avião que são necessárias para que o viajante visite todas as cidades, partindo da cidade 1.\nEntrada\nA primeira linha contém dois inteiros X e Y , indicando respectivamente o número de estradas na direção Oeste-Leste e estradas na direção Norte-Sul. As estradas são numeradas de 1 a X na direção Oeste-Leste e de 1 a Y na direção Norte-Sul. A segunda linha contém dois inteiros N e A, indicando respectivamente o número de cidades e a autonomia dos carros, em kilômetros. As cidades são numeradas de 1 a N. Cada uma das N linhas seguintes contém um par de inteiros xi e yi, indicando a posição da cidade de número i, para 1 ≤ i ≤ N.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o menor número de viagens de avião necessárias para que o vendedor visite todas as cidades.\nRestrições\n• 1 ≤ X ≤ 100 000 • 1 ≤ Y ≤ 100 000 • 2 ≤ N ≤ 1 000 • 1 ≤ A ≤ 150 000 • 1 ≤ xi ≤ X • 1 ≤ yi ≤ Y Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 37 pontos, N = 2.\n• Para outro conjunto de casos de testes valendo 32 pontos, Y = 1, e é garantido que as cidades são dadas em ordem crescente de X (isto é, x1 < x2 < ... < xn).\n• Para um outro conjunto de casos de testes valendo 31 pontos, nenhuma restrição adicional.\nExemplos\nExplicação do exemplo 1: Este é o exemplo do enunciado.\n  Explicação do exemplo 2: Como a autonomia é 200 km, a única viagem de carro possível é entre as cidades 5 e 6. O vendedor pode por exemplo viajar de avião de 1 para 3, depois de 3 para 2, depois de 2 para 4, depois de 4 para 5, alugar um carro e visitar 6, para um total de quatro viagens de avião.",
    "examples": [
      [
        "7 9\n6 300\n2 2\n3 5\n4 3\n2 8\n6 7\n7 7",
        "2"
      ],
      [
        "7 9\n6 200\n2 2\n3 5\n4 3\n2 8\n6 7\n7 7",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "carro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dígitos",
    "description": "digitos.py Joãozinho te propôs o seguinte desafio: ele escolheu dois inteiros A e B, com 1 ≤ A ≤ B ≤ 101000, e escreveu na lousa todos os inteiros entre A e B, em sequência, porém colocando um espaço após cada dígito, de forma a não ser possível ver quando um número termina ou começa. Por exemplo, se Joãozinho escolher A = 98 e B = 102, ele escreveria a sequência \"9 8 9 9 1 0 0 1 0 1 1 0 2\".\nSeu desafio é: dada a lista de dígitos escritos na lousa, encontrar os valores de A e B. Caso exista mais de uma possibilidade para os valores que geraria a lista, você deve encontrar uma em que o valor de A é o menor possível.\nÉ garantido que a lista de dígitos da lousa tem no máximo tamanho 1000.\nEntrada\nA primeira linha da entrada contém um único inteiro N, indicando o número de dígitos. A segunda linha contém N inteiros di, indicando os dígitos escritos.\nSaída\nImprima o menor valor possível de A.\nRestrições\n• 1 ≤ N ≤ 1000 • 0 ≤ di ≤ 9 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 21 pontos, 1000 ≤ A ≤ B ≤ 9999.\n• Para outro conjunto de casos de testes valendo 23 pontos, B = A + 1.\n• Para outro conjunto de casos de testes valendo 40 pontos, A,B < 106.\n• Para outro conjunto de casos de testes valendo 16 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "6\n1 2 3 1 2 4",
        "123"
      ],
      [
        "6\n8 9 1 0 1 1",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "digitos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo",
    "description": "Uma empresa está desenvolvendo um aplicativo para celular que tem como objetivo estimular o gosto por matemática em jovens.\nO aplicativo é um jogo, chamado Maior ou Menor, que sorteia um número inteiro e o jogador tem que adivinhar qual o número sorteado. O jogo é composto de uma ou mais rodadas. A cada rodada, o jogador digita um número e o aplicativo responde com: • menor se o número digitado é maior do que o sorteado; • maior se o número digitado é menor do que o sorteado; e • correto se o número digitado é igual ao número sorteado.\nO jogo termina quando o jogador acerta o número sorteado.\nDados o número sorteado e as tentativas de um jogador, você deve escrever um programa que simule o comportamento do aplicativo.\nEntrada\nA primeira linha contém um inteiro X, o número sorteado pelo aplicativo. Cada uma das linhas seguintes contém um inteiro T, indicando uma tentativa do jogador de acertar o número sorteado.\nNa última linha da entrada, T = X.\nSaída\nPara cada tentativa do jogador seu programa deve produzir uma linha na saída, contendo apenas uma palavra, que deve ser menor se o valor da tentativa é maior do que o número sorteado, maior se o valor da tentativa é menor do que o número sorteado ou correto se o valor da tentativa é igual ao número sorteado.\nRestrições\n• −10 000 ≤ X ≤ 10 000 • −10 000 ≤ T ≤ 10 000 • Haverá no máximo 1000 rodadas em cada jogo.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 43 pontos, é garantido que o jogo termina em exatamente duas rodadas.\n• Para um outro conjunto de casos de testes valendo 57 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "103\n1000\n1\n500\n200\n100\n110\n105\n103",
        "menor\nmaior\nmenor\nmenor\nmaior\nmenor\nmenor\ncorreto"
      ],
      [
        "10000\n10000",
        "correto"
      ],
      [
        "-2\n0\n-1\n-2",
        "menor\nmenor\ncorreto"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Teste de redação",
    "description": "Você é o mais novo estagiário numa empresa de inteligência artificial que está desenvolvendo um corretor automatizado de redações. Para testar o corretor, seu chefe solicitou que você escreva um programa que gere redações aleatórias – que por não fazerem sentido, devem receber a nota zero do corretor automatizado! As redações geradas pelo seu programa devem obedecer aos seguintes requisitos: • Cada palavra deve ser composta apenas por letras minúsculas.\n• Cada palavra deve ter no mínimo uma letra e no máximo 10 letras.\n• Duas palavras devem ser separadas por um espaço em branco.\n• A redação deve ser composta por no mínimo N palavras e no máximo M palavras.\n• A redação deve ser composta por no mínimo M/2 palavras distintas.\nEntrada\nA primeira linha contém dois inteiros N e M, indicando respectivamente o número mínimo e o número máximo de palavras da redação teste.\nSaída\nSeu programa deve produzir uma única linha, contendo a redação produzida.\nRestrições\n• 1 ≤ N ≤ M ≤ 10 000 • M é par • Apenas letras minúsculas não acentuadas são permitidas: abcdefghijklmnopqrstuvwxyz Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 33 pontos, 26 ≤ M ≤ 52.\n• Para outro conjunto de casos de testes valendo 67 pontos, nenhuma restrição adicional.\nExemplos\nExplicação do exemplo 1: A redação deve ter no mínimo duas e no máximo dez palavas, então uma redação com cinco palavras obedece ao critério do número de palavras. Além disso, a redação contém cinco palavras distintas, o que obedece ao critério de número de palavras distintas (mínimo de cinco). Então a redação produzida está correta.\n  Explicação do exemplo 2: A redação deve ter exatamente seis palavras, então a redação produzida tem o número correto de palavras. Além disso, a redação contém seis palavras distintas, mais do que o mínimo exigido (três). Então a redação produzida está correta.\n  Explicação do exemplo 3: A redação deve ter no mínimo seis e no máximo oito palavras, então uma redação com seis palavras é correta. No entanto a redação produzida não tem o número mínimo de palavras distintas necessário (tem três, deveria ter no mínimo quatro), então a redação mostrada está INCORRETA.",
    "examples": [
      [
        "2 10",
        "melhor que machado de assis"
      ],
      [
        "6 6",
        "b c d e f g"
      ],
      [
        "6 8",
        "aa bb aa bb aa bb"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "teste"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pilhas de moedas",
    "description": "Flávia possui várias moedas em sua coleção, que estão organizadas em N pilhas, cada pilha com um certo número de moedas. Vamos chamar o número de moedas de uma pilha de altura da pilha.\nA garota pretende adicionar algumas moedas à sua coleção, de forma que cada moeda nova deve ser adicionada em uma das pilhas existentes. As moedas originais, porém, devem permanecer nas suas pilhas.\nFlávia está se perguntando agora: qual o número mínimo de moedas que ela deve adicionar à coleção para que, considerando os valores de todas as N novas alturas de pilhas, a quantidade de números distintos seja no máximo K? Por exemplo, se a lista de alturas inicialmente é (3,5,8,4,5,8), temos que existem 4 valores distintos de alturas: 3, 4, 5 e 8. Se K = 2, poderíamos, com 3 moedas novas, adicionar duas na pilha de índice 1, e uma na pilha de índice 4. Assim, a lista de alturas ficará (5,5,8,5,5,8), que possui apenas dois valores distintos de alturas: 5 e 8.\nNote que, se inicialmente a lista de alturas já tem no máximo K valores distintos, Flávia já estaria feliz, e não iria precisar de nenhuma moeda nova.\nEntrada\nA primeira linha da entrada contém um dois inteiros separados por espaços N, indicando o número de pilhas e K, indicado o número máximo de valores distintos. A segunda linha contém N inteiros Pi, indicando as alturas das pilhas.\nSaída\nImprima a menor quantidade adicional de moedas.\nRestrições\n• 1 ≤ N ≤ 500 • 1 ≤ K ≤ N • 1 ≤ vi ≤ 500 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 13 pontos, K = 1.\n• Para outro conjunto de casos de testes valendo 21 pontos, K = 2.\n• Para outro conjunto de casos de testes valendo 28 pontos, K,N,vi ≤ 50.\n• Para outro conjunto de casos de testes valendo 38 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "6 2\n5 3 8 4 5 8",
        "3"
      ],
      [
        "6 3\n5 3 8 4 5 8",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pilhas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Restaurante de pizza",
    "description": "Um amigo seu acabou de se mudar para Linearlandia. Apesar de recém chegado, ele decidiu montar um negócio, um restaurante de Pizza.\nSeu amigo está muito feliz na nova empreitada, contudo, com muito medo de errar. Além do preparo da pizza, o restaurante deve se preocupar com a caixa para entrega (que são retangulares), que deverá ser a mesma para todas as pizzas, e com o corte das fatias, que será automatizado e igual para todas as pizzas produzidas.\nNo momento seu amigo está planejando qual será o tamanho das pizzas (que serão todas círculos perfeitos de um único tamanho), e também qual será o ângulo interno de cada fatia (em graus).\nAlém disso, ele encontrou uma loja de caixas de pizza com ótimos preços, mas não sabe se as caixas são adequadas para as pizzas que ele vai produzir.\nA restrição para a caixa de pizza é que a pizza caiba dentro da caixa (mesmo que com alguma folga); a restrição para o ângulo de corte é que todas as fatias sejam de mesmo tamanho (mesmo que seja uma só fatia).\nDados as dimensões da caixa de pizza, o raio da pizza e o ângulo interno da fatia em graus, você deve escrever um programa para determinar se a caixa e o ângulo escolhidos satisfazem às restrições.\nEntrada\nA entrada é composta por quatro linhas, contendo respectivamente os números inteiros A, B, R e G. Os inteiros A e B são as dimensões da caixa de pizza, o inteiro R é o raio da pizza e o inteiro G é o angulo interno das fatias de pizza.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único caractere, que deve ser S se os dados satisfazem às restrições ou N caso contrário.\nRestrições\n• 1 ≤ A,B,R ≤ 109; • 1 ≤ G ≤ 360.\nInformações sobre a pontuação\n• Para um conjunto de testes valendo 13 pontos, A = B; • Para um conjunto de testes valendo 26 pontos, G = 60; • Para um conjunto de casos de testes valendo outros 61 pontos, nenhuma restrição adicional.\nExemplos\nExplicação do exemplo 1: A pizza cabe na caixa e a escolha de ângulo divide a mesma igualmente.\n  Explicação do exemplo 2: O raio da pizza é 3, logo, não cabe em uma caixa de lados de tamanho 4.\n  Explicação do exemplo 3: O ângulo da fatia é 25, logo, não resulta em fatias iguais.",
    "examples": [
      [
        "4\n10\n2\n60",
        "S"
      ],
      [
        "4\n4\n3\n60",
        "N"
      ],
      [
        "10\n10\n5\n25",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pizza"
    },
    "imagesQuant": 0
  },
  {
    "name": "Caravana",
    "description": "caravana.py No deserto da Nlogônia, uma longa caravana de camelos carregados de especiarias está parada num oásis para descansar. O chefe da caravana notou que alguns camelos pareciam mais cansados do que os outros, e descobriu que cada camelo estava carregando um peso diferente, de forma que alguns camelos carregam um peso muito maior do que outros e portanto se cansam mais.\nAproveitando a parada para descanso, o chefe da caravana quer redistribuir as especiarias entre os camelos, de forma que todos os camelos carreguem exatamente o mesmo peso.\nDados os pesos carregados por cada camelo antes da parada, escreva um programa que determine, para cada camelo, qual o peso que deve ser retirado ou adicionado, para que todos carreguem exatamente o mesmo peso.\nEntrada\nA primeira linha contém um inteiro N, o número de camelos na caravana. Os camelos são numerados de 1 a N. Cada uma das linhas seguintes contém um inteiro Pi, o peso que o camelo de número i carregava antes da parada. Os camelos são dados em ordem crescente de numeração.\nSaída\nPara cada camelo da caravana, seu programa deve produzir uma linha, o valor que deve ser adicionado ou retirado desse camelo para que todos os camelos carreguem o mesmo peso. A ordem dos camelos na saída deve ser a mesma ordem dada na entrada. Para todos os casos de teste o peso que cada camelo deve carregar é um número inteiro.\nRestrições\n• 1 ≤ N ≤ 1 000 • 1 ≤ Pi ≤ 10 000 para 1 ≤ i ≤ N Exemplos",
    "examples": [
      [
        "3\n100\n104\n108",
        "4\n0\n-4"
      ],
      [
        "5\n30\n40\n23\n5\n32",
        "-4\n-14\n3\n21\n-6"
      ],
      [
        "3\n10000\n10000\n10000",
        "0\n0\n0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "caravana"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dona Minhoca",
    "description": "minhoca.py Dona Minhoca construiu uma bela casa, composta de N salas conectadas por N − 1 túneis. Cada túnel conecta exatamente duas salas distintas, e pode ser percorrido em qualquer direção. A casa de dona Minhoca foi construída de modo que, percorrendo os túneis, é possível partir de qualquer sala e chegar a qualquer outra sala da casa.\nPara deixar sua casa mais segura, Dona Minhoca decidiu instalar radares anti-furto em algumas das salas. Ela comprou K radares, e deve agora decidir em quais salas colocará um radar. Além disso, todos radares terão um raio de alcance, cujo valor R também deve ser decidido. Quando um radar com raio de alcance R é instalado na sala s, todas as salas com distância menor ou igual a R da sala s (incluindo a própria s) ficam sob o alcance do radar, e estarão protegidas.\nDevido à política estranha de cobrança da empresa de radares, todos os K radares devem ter o mesmo raio de alcance. Dona Minhoca então se pergunta: qual seria o menor valor possível para R, tal que, se o raio de alcance dos radares for R, é possível escolher K salas para instalar os radares de forma que todas as N salas estejam protegidas? Entrada\nA primeira linha da entrada contém dois inteiros N e K, indicando o número de salas, e de radares que Dona Minhoca possui. As N − 1 linhas seguintes contém dois inteiros ai e bi cada, indicando que existe um túnel conectando essas duas salas.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o menor valor possível para R.\nRestrições\n• 1 ≤ N ≤ 300000 • 1 ≤ K < N • ai (cid:54)= bi Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 25 pontos, K = 1 • Para outro conjunto de casos de testes valendo 17 pontos, o túnel i conecta as salas i e i + 1 (1 ≤ i ≤ N − 1). Ou seja, a casa possui o formato de uma linha reta.\n• Para outro conjunto de casos de testes valendo 17 pontos, N,K ≤ 100 • Para outro conjunto de casos de testes valendo 41 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "6 1\n1 2\n2 3\n3 4\n4 5\n4 6",
        "2"
      ],
      [
        "6 2\n1 2\n2 3\n3 4\n4 5\n4 6",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "minhoca"
    },
    "imagesQuant": 0
  },
  {
    "name": "Rodovia",
    "description": "rodovia.py O reino de Nlogonia é composto por N cidades, numeradas de 1 a N, e M rodovias direcionadas, ou seja, é possível usar a rodovia (x,y) para ir da cidade x à cidade y, porém não na outra direção.\nVamos definir o valor da conectividade do reino como o número de pares ordenados (x,y), com x (cid:54)= y, tais que é possível viajar de x a y (talvez indiretamente, passando por outras cidades intermediárias pelo caminho). Na figura acima, por exemplo, o valor da conectividade é 11, sendo que os pares em questão são: (1,3),(1,4),(1,6),(3,1),(3,4),(3,6),(5,2),(5,4),(6,1),(6,3) e (6,4).\nO governo de Nlogonia está planejando construir uma única nova rodovia (A,B), também direcionada. Muitas discussões estão sendo feitas para escolher a rodovia ideal, porém no momento, o maior receio é se há alguma possibilidade de ser feita uma escolha que seja considerada redundante pelos habitantes do reino. Em particular, foi dada a você a tarefa de descobrir se existe algum par (A,B) de cidades tal que: • A (cid:54)= B • Não existe nenhuma rodovia (x,y) originalmente no reino, com x = A e y = B.\n• Caso adicionarmos a rodovia (A,B), o valor da conectividade do reino permanecerá o mesmo.\nTambém foi pedido que, caso existam pares que cumpram todas as condições, você deve informar algum deles. Caso tenha mais de um par válido, você pode escolher qualquer um deles.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M, indicando o número de cidades e rodovias.\nSeguem M linhas contendo dois inteiros xi e yi cada, indicando que existe uma rodovia que pode ser usada para viajar da cidade xi à cidade yi.\nSaída\nCaso exista algum par que satisfaça todas as condições, seu programa deve imprimir qualquer um desses pares, em uma única linha. Caso contrário, imprima −1.\nRestrições\n• 1 ≤ N ≤ 200000 • 1 ≤ M ≤ 400000 • xi (cid:54)= yi • Nenhuma rodovia é dada mais de uma vez na entrada, ou seja, (xi,yi) (cid:54)= (xj,yj), se i (cid:54)= j.\nNote porém que é possível que ambas as rodovias (x,y) e (y,x) sejam dadas.\nInformações sobre a pontuação\n• Para um conjunto de casos de testes valendo 31 pontos, vale que a conectividade inicial do reino é igual a N ∗ (N − 1). Ou seja, existe algum caminho entre todos os pares de cidades.\n• Para outro conjunto de casos de testes valendo 33 pontos, vale que se existe uma rodovia de x para y, então também existe uma rodovia de y para x.\n• Para outro conjunto de casos de testes valendo 36 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "4 3\n1 2\n2 4\n1 4",
        "-1"
      ],
      [
        "4 4\n1 2\n2 4\n1 4\n4 3",
        "2 3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "rodovia"
    },
    "imagesQuant": 1
  },
  {
    "name": "Quadrado",
    "description": "quadrado.py Um quadrado fantástico é um conjunto de números inteiros positivos dispostos em N linhas por N colunas tal que: • Não há números repetidos no quadrado.\n• A média dos números em cada linha é um número inteiro que está presente na linha.\n• A média dos números em cada coluna é um número inteiro que está presente na coluna.\nEntrada\nA primeira e única linha da entrada contém um número inteiro N, indicando a dimensão do quadrado.\nSaída\nSeu programa deve produzir N linhas, cada uma contendo N números inteiros Xi, representando um quadrado fantástico.\nRestrições\n• 1 ≤ N ≤ 40 • 1 ≤ Xi ≤ 1000000 Informações sobre a pontuação\n• Para um conjunto de casos de testes valendo 44 pontos, 1 ≤ N é ímpar.\n• Para outro conjunto de casos de testes valendo 56 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "1",
        "1"
      ],
      [
        "2",
        "-1"
      ],
      [
        "3",
        "1 2 3\n4 5 6\n7 8 9"
      ],
      [
        "4",
        "1 2 3 6\n7 8 9 12\n13 14 15 18\n31 32 33 36"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2022,
      "phase": 3,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "quadrado"
    },
    "imagesQuant": 0
  },
  {
    "name": "Chinelos",
    "description": "Uma comunidade indígena produz chinelos de juta e criou um site para vender a produção online.\nOs chinelos são de apenas um tipo, mas são produzidos em vários tamanhos.\nVocê foi contratado(a) para desenvolver um programa de controle de estoque para o site. O estoque pode ser visto como uma tabela com uma única linha, em que cada coluna representa um tamanho, como mostrado na figura (a) abaixo. Na figura, os tamanhos são representados por números de 1 a 5. Assim, a tabela da figura (a) informa que o estoque do chinelo de tamanho 1 é 4 unidades, e o estoque do chinelo de tamanho 4 é 3 unidades.\nTAMANHO TAMANHO 1 2 3 4 5 1 2 3 4 5     (a) (b) Quando um chinelo é vendido, o estoque deve ser atualizado. Por exemplo, se um chinelo de tamanho 1 for vendido, o estoque atualizado é mostrado na figura (b). Se o estoque para um tamanho de chinelo tem valor zero, chinelos desse tamanho não podem ser vendidos (por exemplo o chinelo de tamanho 3). Ou seja, a venda não é efetivada.\nDados o estoque inicial e a lista de pedidos de clientes, escreva um programa para determinar quantos chinelos são efetivamente vendidos no total. Cada pedido se refere a um único chinelo. As vendas são processadas sequencialmente, na ordem em que os pedidos foram feitos. Se uma venda não é possível por falta de estoque, o pedido correspondente é ignorado.\nEntrada\nA primeira linha da entrada contém um inteiro N, o número de tamanhos de chinelos no estoque.\nTamanhos são identificados por inteiros de 1 a N. Cada uma das N linhas seguintes contém N inteiros Xi, indicando a quantidade de chinelos de tamanho i, para 1 ≤ i ≤ N. A seguir a entrada contém uma linha com um número inteiro P, o número de pedidos recebidos pela loja. Cada uma das P linhas seguintes contém um inteiro I representando o tamanho do chinelo de um pedido. Os pedidos são dados na ordem em que foram feitos.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número total de chinelos efetivamente vendidos.\nRestrições\n• 1 ≤ N ≤ 500 • 0 ≤ Xi ≤ 20 para 1 ≤ i ≤ N • 1 ≤ P ≤ 1 000 • 1 ≤ I ≤ N Informações sobre a pontuação\n• A tarefa vale 100 pontos.\n• Para um conjunto de casos de testes valendo 27 pontos, N ≤ 3.\n• Para um conjunto de casos de testes valendo outros 73 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5\n4\n2\n0\n3\n2\n2\n1\n3",
        "1"
      ],
      [
        "4\n1\n3\n2\n5\n4\n3\n3\n3\n4",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "chinelos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Epidemia",
    "description": "Uma nova pandemia é sempre possível (e temida), mas a experiência recente mostrou que atualmente a ciência é capaz de desenvolver vacinas eficazes em muito pouco tempo. Outra consequência da pandemia recente é que muito se estudou sobre epidemias em geral, e vários modelos matemáticos foram desenvolvidos.\nNeste problema vamos usar um modelo simples de epidemia: • Quando uma pessoa é infectada, ela infecta outras R pessoas, mas apenas no dia seguinte à sua infecção (R é chamado de fator reprodutivo da infecção).\n• Ninguém é infectado mais do que uma vez.\nPor exemplo, se no dia 0 da epidemia 3 pessoas são infectadas e o fator reprodutivo R é igual a 2, então no dia 1 outras 6 pessoas são infectadas (3 + 6 = 9 pessoas no total), no dia 2 outras 12 pessoas são infectadas (3 + 6 + 12 = 21 pessoas no total), no dia 3 outras 24 pessoas infectadas (3 + 6 + 12 + 24 = 45 pessoas no total), e assim por diante.\nDados o número inicial de pessoas infectadas no dia 0 e o fator reprodutivo R da epidemia, escreva um programa para determinar qual o número de dias necessários para a epidemia infectar P ou mais pessoas no total.\nEntrada\nA primeira linha contém um inteiro N, o número de pessoas infectadas no dia 0. A segunda linha contém o fator reprodutivo R da infecção. A terceira e última linha contém um inteiro P, o número alvo de pessoas infectadas.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de dias para P ou mais pessoas serem infectadas.\nRestrições\n• 1 ≤ N ≤ 1 000 • 1 ≤ R ≤ 10 • 1 ≤ P ≤ 1 000 000 Informações sobre a pontuação\n• A tarefa vale 100 pontos.\nExemplos",
    "examples": [
      [
        "1\n5\n156",
        "3"
      ],
      [
        "2\n1\n11",
        "5"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "epidemia"
    },
    "imagesQuant": 0
  },
  {
    "name": "Prêmio",
    "description": "Uma ONG (Organização Não Governamental) oferece cursos gratuitos de programação de computadores, dança, música e culinária. Aproveitando a cozinha montada para os cursos de culinária, também vende pães integrais, doces e bolos para ajudar nas despesas.\nO diretor da ONG anunciou um incentivo para a venda da produção da cozinha: considerando que cada pão vale 1 ponto, cada doce vale 2 pontos e cada bolo vale 3 pontos, os colaboradores ganharão um prêmio dependendo da soma total dos pontos dos produtos vendidos durante a semana.\nSe a soma dos pontos de todos os produtos vendidos na semana for igual ou maior do que 150, cada colaborador recebe um bolo como prêmio; senão, se a soma dos pontos for maior ou igual a 120, cada colaborador recebe um doce como prêmio; senão, se a soma dos pontos for maior ou igual a 100, cada colaborador recebe um pão como prêmio. Se a soma dos pontos for menor do que 100 não há prêmio para os colaboradores.\nSabendo que você fez um curso de programação na ONG, o diretor pediu que você escreva um programa que, dados os números de pães, doces e bolos vendidos na semana, determine qual o prêmio merecido.\nEntrada\nA primeira linha contém um inteiro P, o número de pães vendidos na semana. A segunda linha contém um inteiro D, o número de doces vendidos na semana. A terceira e última linha contém um inteiro B, o número de bolos vendidos na semana.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, indicando o prêmio merecido: a letra maiúscula ‘P’ para pão, a letra maiúscula ‘D’ para doce, a letra maiúscula ‘B’ para bolo e a letra maiúscula ‘N’ se os colaboradores não merecem prêmio na semana.\nRestrições\n• 0 ≤ P ≤ 100 • 0 ≤ D ≤ 100 • 0 ≤ B ≤ 100 Informações sobre a pontuação\n• A tarefa vale 100 pontos.\nExemplos",
    "examples": [
      [
        "100\n10\n4",
        "D"
      ],
      [
        "30\n45\n10",
        "B"
      ],
      [
        "30\n10\n5",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "premio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Estoque",
    "description": "Você foi contratado(a) para desenvolver um programa de controle de estoque, para uma loja de roupas que está iniciando vendas online. A loja mantém um estoque de roupas, em que cada peça de roupa é identificada por um tipo (por exemplo camisa, calça, saia, vestido, ...) e um tamanho (por exemplo bebê, infantil, pequeno, médio, ...).\nO estoque da loja pode ser visto como uma tabela em que cada linha representa um tipo de roupa e cada coluna representa um tamanho, como mostrado na figura (a) abaixo. Na figura, tipos de roupa são representados por números de 1 a 4 e tamanhos são representados por números de 1 a 3.\nTAMANHO TAMANHO 1 2 3 1 2 3 1 5 2 2 1 4 2 2 T T I 2 6 4 0 I 2 6 4 0 P P O 3 2 1 4 O 3 2 1 4 4 1 3 2 4 1 3 2 (a) (b) Assim, a tabela da figura (a) mostra que o estoque da peça de roupa de tipo 1 e tamanho 1 é 5 unidades, e o estoque da peça de roupa de tipo 4 e tamanho 2 é 3 unidades.\nQuando uma peça de roupa é vendida, o estoque deve ser atualizado. Por exemplo, se uma peça de roupa de tipo 1 e tamanho 1 for vendida, o estoque atualizado é mostrado na figura (b). Se o estoque para um tipo e tamanho de peça de roupa tem valor zero, peças de roupa desse tipo e tamanho não podem ser vendidas (por exemplo a peça de roupa de tipo 2 e tamanho 3 na figura).\nOu seja, a venda não é efetivada.\nDados o estoque inicial e a lista de pedidos de clientes, escreva um programa para determinar quantas peças de roupa são efetivamente vendidas no total. Cada pedido se refere a uma única peça de roupa. As vendas são processadas sequencialmente, na ordem em que os pedidos foram feitos.\nSe uma venda não é possível por falta de estoque, o pedido correspondente é ignorado.\nEntrada\nA primeira linha da entrada contém dois números inteiros M e N, indicando respectivamente o número de tipos e o número de tamanhos de peças de roupa no estoque. Tipos são identificados por inteiros de 1 a M e tamanhos são identificados por inteiros de 1 a N. Cada uma das M linhas seguintes contém N inteiros Xi,j, indicando a quantidade de roupas do tipo i e tamanho j, para 1 ≤ i ≤ M e 1 ≤ j ≤ N. A seguir a entrada contém uma linha com um número inteiro P, o número de pedidos recebidos pela loja. Cada uma das P linhas seguintes contém dois inteiros I e J representando respectivamente o tipo e o tamanho da peça de roupa de um pedido. Os pedidos são dados na ordem em que foram feitos.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número total de peças de roupas efetivamente vendidas.\nRestrições\n• 1 ≤ M ≤ 500 • 1 ≤ N ≤ 500 • 0 ≤ Xi,j ≤ 10 para 1 ≤ i ≤ M e 1 ≤ j ≤ N • 1 ≤ P ≤ 1 000 • 1 ≤ I ≤ M • 1 ≤ J ≤ N Informações sobre a pontuação\n• A tarefa vale 100 pontos.\n• Para um conjunto de casos de testes valendo 19 pontos, há apenas um tipo de roupa, ou seja M = 1.\n• Para um conjunto de casos de testes valendo 17 pontos, há apenas um tamanho de roupa, ou seja N = 1.\n• para um conjunto de casos de testes valendo os 64 pontos restantes, nenhuma restrição adicional.\nExemplos\nExemplo de entrada 1 Exemplo de saída 1 4 3 1   2 1 1 2 3",
    "examples": [
      [
        "4 3\n5 2 2\n6 4 0\n2 1 4\n1 3 2\n2\n1 1\n2 3",
        "1"
      ],
      [
        "1 4\n1 3 2 5\n4\n1 3\n1 3\n1 3\n1 4",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "estoque"
    },
    "imagesQuant": 0
  },
  {
    "name": "Subsequência",
    "description": "ou subsequencia.py Você foi contratado pela Agência Extra-Espacial Brasileira, que procura indícios de vida extraterrestre.\nUm dos telescópios da Agência, para o espectro ultravioleta, gera uma sequência de valores inteiros positivos que devem ser analisados continuamente. Dadas duas sequências SA e SB, sua primeira missão é determinar se SB é uma subsequência de SA.\nUma subsequência de uma dada sequência S é um conjunto de elementos de S que não são necessariamente adjacentes mas que mantêm a mesma ordem em que aparecem em S. Por exemplo, [2], [1,4], [1,2,4] e [1,2,3,4] são subsequências de [1,2,3,4], mas [4,3], [3,4,1] e [1,3,5] não são.\nEntrada\nA primeira linha contém dois inteiros A e B, o número de elementos das sequências. A segunda linha contém A inteiros Xi, os números da sequência SA. A seguir a entrada contém B inteiros Yi, os números da sequência SB.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser a letra maiúscula ‘S’ se SB é uma subsequência da SA ou a letra maiúscula ‘N’ caso contrário.\nRestrições\n• 1 ≤ A ≤ 105 • 1 ≤ B ≤ A • −109 ≤ Xi ≤ 109 para 1 ≤ i ≤ A • −109 ≤ Yi ≤ 109 para 1 ≤ i ≤ B Informações sobre a pontuação\n• A tarefa vale 100 pontos.\n• Para um conjunto de casos de testes valendo 11 pontos, A = B = 2.\n• Para um conjunto de casos de testes valendo outros 33 pontos, os números aparecem no máximo uma vez em cada sequência, A ≤ 100, 1 ≤ Xi ≤ 100 e 1 ≤ Yi ≤ 100.\n• Para um conjunto de casos de testes valendo outros 56 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5 3\n1 2 3 4 5\n2 3 5",
        "S"
      ],
      [
        "5 4\n8 17 8 21 23\n8 8 21 22",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "subsequencia"
    },
    "imagesQuant": 0
  },
  {
    "name": "VAR",
    "description": "Com a crescente popularidade dos campeonatos de “Beach Tenis”, uma empresa está desenvolvendo um aplicativo para celular para ser usado por juízes. O objetivo é que, depois de configurar o aplicativo, um “juiz de vídeo” possa usar a câmera do celular para determinar se o impacto da bola com o piso foi dentro ou fora do campo de jogo.\nO campo de jogo é um retângulo de dimensões 16m x 8m. A coordenada (0,0) é a posição do juiz, como mostrado na figura (a) abaixo. A figura (a) também mostra duas marcações de bolas dentro do campo de jogo (círculos pretos), nas coordenadas (−6,6) e (8,2). Note que uma bola em cima da linha é considerada dentro do campo de jogo.\ny y 10 10 8 8 6 6 4 4 2 2 x x -8 -6 -4 -2 0 2 4 6 8 -8 -6 -4 -2 0 2 4 6 8 -2 -2 (a) (b) A figura (b) mostra duas marcações de bolas fora do campo de jogo (estrelas pretas), nas coordenadas (−4,10) e (6,−2).\nVocê foi contratado para testar o novo aplicativo. Como é ainda um protótipo, apenas coordenadas de valores inteiros serão testadas.\nEscreva um programa que, dada a coordenada de uma marcação identificada pelo aplicativo, determine se a marcação está dentro ou fora do campo de jogo.\nEntrada\nA primeira linha da entrada contém um inteiro X, a coordenada x da marcação. A segunda linha contém um inteiro Y , a coordenada y da marcação.\nSaída\nSeu programa deve produzir uma única linha, contendo um único caractere, que deve ser a letra maiúscula ‘S’ se a marcação está dentro do campo; se a marcação está fora do campo de jogo a linha deve conter a letra maiúscula ‘N’.\nRestrições\n• −100 ≤ X ≤ 100 • −100 ≤ Y ≤ 100 Informações sobre a pontuação\n• A tarefa vale 100 pontos.\nExemplos",
    "examples": [
      [
        "6\n-2",
        "N"
      ],
      [
        "8\n2",
        "S"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "var"
    },
    "imagesQuant": 0
  },
  {
    "name": "Contas a pagar",
    "description": "Vô João está aposentado, tem boa saúde, mas a vida não está fácil. Todo mês é um sufoco para conseguir pagar as contas! Ainda bem que ele é muito amigo dos donos das lojas do bairro, e eles permitem que ele fique devendo.\nDepois de pagar aluguel, conta de luz, conta de água, conta do telefone celular e conta do mercado, Vô João ainda tem que pagar as contas do Açougue, da Farmácia e da Padaria.\nDados o valor que Vô João tem disponível e o valor das contas do Açougue, Farmácia e Padaria, escreva um programa para determinar quantas contas, entre as três que ainda não foram pagas, Vô João consegue pagar.\nEntrada\nA entrada contém quatro linhas. A primeira linha contém um inteiro V , o valor que Vô João tem disponível para pagar as contas. A segunda linha contém um inteiro A, o valor da conta do Açougue.\nA terceira linha contém um inteiro F, o valor da conta da Farmácia. A quarta linha contém um inteiro P, o valor da conta da Padaria.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o maior número de contas que Vô João consegue pagar.\nRestrições\n• 0 ≤ V ≤ 2 000 • 1 ≤ A ≤ 1 000 • 1 ≤ F ≤ 1 000 • 1 ≤ P ≤ 1 000 Informações sobre a pontuação\n• A tarefa vale 100 pontos.\nExemplos",
    "examples": [
      [
        "100\n30\n40\n30",
        "3"
      ],
      [
        "50\n82\n99\n51",
        "0"
      ],
      [
        "200\n180\n100\n120",
        "1"
      ],
      [
        "200\n100\n180\n90",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "contas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Leilão",
    "description": "Para arrecadar dinheiro para o Hospital da cidade, os alunos do Centro Acadêmico conseguiram que o maior esportista nascido e criado na cidade, hoje um jogador de fama internacional, doasse uma camiseta do seu time atual, autografada.\nOs alunos então organizaram um leilão pela internet, aceitando lances pela camiseta, com a promessa de que o lance de maior valor compraria a camiseta pelo valor oferecido. Cada lance é composto pelo nome do interessado e o valor oferecido.\nNo entanto a notícia do leilão viralizou, e o número de lances foi muito grande. Sabendo que você sabe resolver problemas usando o computador, os alunos do Centro Acadêmico pediram a sua ajuda para processar os lances.\nDada a lista de lances, na ordem em que foram feitos, escreva um programa para determinar o lance de maior valor. Se houver empate no valor, o lance que foi feito primeiro é o vencedor.\nEntrada\nA primeira linha contém um inteiro N, o número de lances recebidos. A seguir são dados os N lances, na ordem em que foram feitos. Cada lance é dado em duas linhas: a primeira linha contém uma cadeia de caracteres C, o nome da pessoa que fez o lance; a segunda linha contém um inteiro V , o valor do lance.\nSaída\nSeu programa deve produzir duas linhas. A primeira linha deve conter o nome da pessoa que fez o lance ganhador. A segunda linha deve conter o valor do lance ganhador.\nRestrições\n• 0 ≤ N ≤ 10 000 • C contém apenas letras maiúsculas e minúsculas, não acentuadas.\n• C contém no mínimo uma e no máximo 10 letras.\n• 1 ≤ V ≤ 100 000 Informações sobre a pontuação\n• A tarefa vale 100 pontos.\n• Para um conjunto de casos de testes valendo 16 pontos, C contém apenas uma letra.\n• Para um conjunto de casos de testes valendo outros 84 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "4\nLeila\n200\nPedro\n250\nClara\n230\nEduardo\n200",
        "Pedro\n250"
      ],
      [
        "5\nMateus\n2000\nJoana\n2354\nEduardo\n2354\nIara\n2354\nMichel\n2300",
        "Joana\n2354"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "leilao"
    },
    "imagesQuant": 0
  },
  {
    "name": "Toupeira",
    "description": "Senhor Toupeira é o prefeito de Morro Seco e ao longo dos anos mandou construir muitos túneis embaixo da terra, conectando salões de convivência que ele também mandou construir, para alegria de sua comunidade de toupeiras. Cada túnel conecta exatamente dois salões de convivência distintos e não há dois túneis conectando o mesmo par de salões. Túneis podem ser usados em ambas direções, ou seja, o túnel que conecta os salões A e B pode ser usado para ir da A para B ou de B para A.\nSalões de convivência possuem identificadores únicos.\nSenhor Toupeira agora quer incentivar que as toupeiras de Morro Seco façam caminhadas, para melhorar a saúde da comunidade. Para isso preparou um caderno com várias sugestões de passeio pelos túneis e salões de convivência, em que cada sugestão de passeio é descrita como uma sequência de salões de convivência, que devem ser visitados estritamente na ordem dada. No entanto, Senhor Toupeira foi alertado de que algumas das sugestões de passeio estão incorretas, pois não são possíveis.\nA figura abaixo mostra um exemplo de salões de convivência e túneis, em que salões têm identificadores 1, 2, 3, 4 e 5.\n2 1 4 3 5 Um passeio composto pela sequência de salões {5, 3, 4, 3, 2} é possível. Mas o passeio composto pela sequência de salões {2, 3, 5, 4} não é possível, pois não existe túnel entre os salões 5 e 4.\nDados o mapa de túneis e salões de convivência, e uma lista de sugestões de passeio, escreva um programa que determine quantas sugestões de passeio são possíveis.\nEntrada\nA primeira linha da entrada contém dois inteiros S, e T, indicando respectivamente o número de salões de convivência e o número de túneis. Salões são identificados por inteiros de 1 a S. Cada uma das T linhas seguintes descreve um túnel e contém um par de inteiros X e Y , que indicam que o túnel conecta os salões X e Y . A próxima linha da entrada contém um inteiro P que indica o número de sugestões de passeio. Cada uma das P linhas seguintes descreve uma sugestão de passeio e inicia com um inteiro N que indica o número de salões do passeio, seguido de N inteiros Ci, indicando a sequência de salões do passeio.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de sugestões de passeio que são possíveis.\nRestrições\n• 2 ≤ S ≤ 1 000 • 1 ≤ T ≤ S(S − 1)/2 • 1 ≤ X ≤ S • 1 ≤ Y ≤ S • 1 ≤ P ≤ 1 000 • 1 ≤ N ≤ 1 000 • 1 ≤ Ci ≤ S, para 1 ≤ i ≤ N • Ci ̸= Ci+1, para 1 ≤ i ≤ N − 1, ou seja, salões consecutivos em uma sugestão de passeio são distintos.\nInformações sobre a pontuação\n• A tarefa vale 100 pontos.\n• Para um conjunto de casos de testes valendo 49 pontos, S ≤ 100,P ≤ 100 e N ≤ 100.\n• Para um conjunto de casos de testes valendo outros 17 pontos, T = S − 1 e existe um túnel entre os salões i e i + 1, para 1 ≤ i ≤ S − 1.\n• Para um conjunto de casos de testes valendo outros 34 pontos, nenhuma restrição adicional.\nExemplos",
    "examples": [
      [
        "5 6\n2 3\n3 4\n4 2\n3 5\n1 5\n1 2\n2\n5 5 3 4 3 2\n6 1 2 3 5 4 2",
        "1"
      ],
      [
        "4 2\n1 2\n3 4\n3\n4 1 2 1 2\n5 4 3 4 3 4\n2 1 4",
        "2"
      ],
      [
        "4 3\n1 2\n2 3\n3 4\n4\n4 1 2 1 2\n5 3 4 3 2 3\n8 1 2 3 2 1 2 3 4\n2 1 3",
        "3"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "toupeira"
    },
    "imagesQuant": 0
  },
  {
    "name": "Código de Compressão",
    "description": "Em computação, compressão de arquivos é o processo de reduzir o tamanho de arquivos. Uma técnica simples mas eficiente de compressão para alguns tipos de arquivos é RLE, cujo o nome é derivado das letras iniciais do nome em inglês, que pode ser traduzido por codificação por comprimento de repetições.\nEm RLE, cada sequência de valores repetidos no arquivo é substituída pelo número de repetições seguido do valor a ser repetido. Por exemplo, a sequência ‘AAAAAA’ seria substituída por ‘6 A’. Se o arquivo tem muitas sequências de valores repetidos, a técnica RLE é bem eficiente (por exemplo, considere um arquivo de imagem branco e preto em que grande parte dos valores é branco). Por outro lado, se o arquivo não possui muitas repetições, a técnica RLE pode aumentar o tamanho do arquivo, ao invés de diminuir.\nNesta tarefa, dada uma cadeia de caracteres, você deve escrever um programa que produza a sequência de caracteres comprimida com a técnica RLE.\nEntrada\nA primeira linha contém um inteiro N, o comprimento da cadeia de caracteres. A segunda linha contém a cadeia de caracteres, com N caracteres Ci.\nSaída\nSeu programa deve produzir uma única linha, contendo a cadeia de caracteres codificada com a técnica RLE. A codificação consiste em uma sequência de pares, separados por espaços, em que cada par é um inteiro (indicando o número de repetições), seguido de um espaço, seguido do caractere a ser repetido.\nRestrições\n• 1 ≤ N ≤ 1 000 • Ci é uma letra, maiúscula ou minúscula, não acentuada.\nInformações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (21 pontos): Não há repetições na cadeia de entrada (veja exemplo 2).\n• Subtarefa 2 (23 pontos): Ci = ‘a’ ou Ci = ‘b’ para todo i (veja exemplo 3).\n• Subtarefa 3 (56 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por alguma das suas submissões.\nExemplos\nExplicação do exemplo 1: o primeiro caractere da cadeia, ‘T’, não tem repetição e portanto sua codificação é o par ‘1 T’. A seguir na cadeia de caractere aparecem quatro caracteres ‘A’ repetidos, e portanto a codificação dessa sequência é o par ‘4 A’. Finalmente na cadeia de caractere aparecem três caracteres ‘x’ repetidos, e portanto a codificação dessa sequência é o par ‘3 x’. Os pares devem ser separados por um espaço em branco, e portanto a resposta é ‘1 T 4 A 3 x’.",
    "examples": [
      [
        "8\nTAAAAxxx",
        "1 T 4 A 3 x"
      ],
      [
        "4\nXYZX",
        "1 X 1 Y 1 Z 1 X"
      ],
      [
        "21\naaaaaaaaaabbbbbbbbbbb",
        "10 a 11 b"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "codigo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Grupos de Trabalho",
    "description": "A professora Paula divide a classe em grupos de três estudantes para os trabalhos da sua disciplina.\nPara minimizar descontentamentos, ela fez uma enquete no início do ano, de forma que ela tem uma lista de pares de estudantes que gostariam de estar no mesmo grupo, e uma lista de pares de estudantes que não gostariam de estar no mesmo grupo.\nPara cada trabalho ela faz uma nova divisão de grupos, e claro que nem sempre vai ser possível satisfazer todas as restrições da classe! Dados os pares de estudantes que gostariam estar no mesmo grupo, os pares de estudantes que não gostariam estar no mesmo grupo, e uma possível distribuição dos estudantes em grupos de três, sua tarefa é determinar o número total de restrições que são violadas com essa distribuição.\nEntrada\nA primeira linha contém três inteiros E, M e D, indicando, respectivamente, o número total de estudantes, o número de pares de estudantes que gostariam de estar no mesmo grupo e o número de pares de estudantes que não gostariam de estar no mesmo grupo. Os estudantes são identificados por números inteiros de 1 a E.\nCada uma das M linhas seguintes descreve um par de estudantes que gostariam de estar no mesmo grupo e contém dois inteiros X e Y indicando os estudantes do par. Cada uma das D linhas seguintes descreve um par de estudantes que não gostariam de estar no mesmo grupo e contém dois inteiros U e V indicando os estudantes do par.\nFinalmente, cada uma das E/3 linhas seguintes descreve um grupo de estudantes e contém três inteiros I, J e K indicando os estudantes do grupo.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número total de restrições que são violadas nos grupos da entrada.\nRestrições\n• 3 ≤ E ≤ 999 999 e E é divisível por 3.\n• 0 ≤ M ≤ 100 000 • 0 ≤ D ≤ 100 000 • M + D > 0 e, entre todos os M + D pares, cada par de estudantes aparece no máximo uma vez.\n• 1 ≤ X ≤ E, 1 ≤ Y ≤ E e X ̸= Y .\n• 1 ≤ U ≤ E, 1 ≤ V ≤ E e U ̸= V .\n• 1 ≤ I ≤ E, 1 ≤ J ≤ E e 1 ≤ K ≤ E • Cada estudante aparece em exatamente um dos E/3 grupos.\nInformações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (39 pontos): E ≤ 999, M ≤ 1 000 e D ≤ 1 000.\n• Subtarefa 2 (61 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente ambas ou somente uma das subtarefas. Sua pontuação final na tarefa é a soma dos pontos das subtarefas resolvidas corretamente por alguma das suas submissões.\nExemplos\nExplicação do exemplo 1: Há 3 estudantes e apenas uma restrição (estudantes 1 e 2 gostariam de estar no mesmo grupo), que é obedecida no único grupo da distribuição, (2,1,3), portanto a resposta é 0.\n  Explicação do exemplo 2: Há 9 estudantes e portanto serão formados três grupos. Há 1 par de estudantes que gostariam de estar no mesmo grupo: (1,9) e três pares de estudantes que não gostariam estar no mesmo grupo: (1,3), (5,6) e (2,8). Nos grupos formados – (1,2,3), (4,5,6) e (7,8,9) –, das quatro restrições apenas o par (2,8) tem a restrição obedecida (pois não estão no mesmo grupo). Para os outros três pares, (1,9), (1,3) e (5,6), as restrições são violadas, portanto a resposta é 3.\n  Explicação do exemplo 3: Há 6 estudantes e portanto serão formados dois grupos. Não há nenhum par de estudantes que gostariam de estar no mesmo grupo e há três pares de estudantes que não gostariam estar no mesmo grupo: (1,5), (5,2) e (2,3). Nos grupos formados – (5,2,1) e (3,4,6) –, das três restrições, duas são violadas: (1,5) e (5,2) não gostariam de estar no mesmo grupo, e portanto a resposta é 2.",
    "examples": [
      [
        "3 1 0\n1 2\n2 1 3",
        "0"
      ],
      [
        "9 1 3\n1 9\n1 3\n5 6\n2 8\n1 2 3\n4 5 6\n7 8 9",
        "3"
      ],
      [
        "6 0 3\n1 5\n5 2\n2 3\n5 2 1\n3 4 6",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "grupos"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pizza da OBI",
    "description": "O prof. Carlos comprou pizzas para servir um lanche para os estudantes que compareceram à prova da OBI na escola. Infelizmente ele não conseguiu comprar todas as pizzas de mesmo tamanho: comprou pizzas de 8 pedaços e pizzas de 6 pedaços. Mas felizmente cada pedaço, de qualquer pizza, tem exatamente a mesma quantidade de pizza.\nO prof. Carlos vai distribuir para os participantes o maior número de pedaços possível, mas no máximo um pedaço de pizza para cada participante. Os pedaços de pizza serão distribuídos somente para participantes da prova.\nDados o número de participantes da prova da OBI e o número de pizzas de cada tamanho, escreva um programa para determinar o número de pedaços de pizza que sobram.\nNote que é possível que não sobre nenhum pedaço, e é possível também que alguns alunos não recebam um pedaço de pizza.\nEntrada\nA primeira linha contém um inteiro N, o número de participantes na prova da OBI. A segunda linha contém um inteiro G, o número de pizzas de 8 pedaços. A terceira e última linha contém um inteiro M, o número de pizzas de 6 pedaços.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de pedaços de pizza que sobram.\nRestrições\n• 1 ≤ N ≤ 500 000 • 1 ≤ G ≤ 100 • 1 ≤ M ≤ 100 Informações sobre a pontuação\nA tarefa vale 100 pontos.\nExemplos\nExplicação do exemplo 1: São 20 participantes, 1 pizza de 8 pedaços e 1 pizza de 6 pedaços, totalizando 14 pedaços de pizza. Portanto, não sobra nenhum pedaço (6 participantes ficam sem pizza) e a resposta é zero.\n  Explicação do exemplo 2: São 34 participantes, 4 pizzas de 8 pedaços e 2 pizzas de 6 pedaços, totalizando 4×8+2×6 = 44 pedaços de pizza. Portanto sobram 10 pedaços, que é a resposta.\n  Explicação do exemplo 3: há 500 000 participantes, 1 pizza de oito pedaços e 2 pizzas de seis pedaços, totalizando 1 × 8 + 2 × 6 = 20 pedaços. Portanto, não sobra nenhum pedaço (muitos ficam sem pizza!) e a resposta é zero.",
    "examples": [
      [
        "20\n1\n1",
        "0"
      ],
      [
        "34\n4\n2",
        "10"
      ],
      [
        "500000\n1\n2",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "pizza"
    },
    "imagesQuant": 0
  },
  {
    "name": "Intervalo Distinto",
    "description": "Você foi contratado pela Agência Extra-Espacial Brasileira, que procura indícios de vida extraterrestre.\nUm dos telescópios da Agência, para o espectro ultravioleta, gera uma sequência de valores inteiros positivos que devem ser analisados diariamente. Sua primeira missão é determinar, na sequência gerada, o tamanho do maior intervalo contínuo que contém apenas números distintos.\nEntrada\nA primeira linha contém um inteiro N, o número de elementos da sequência. Cada uma das linhas seguintes contém um inteiro Ii, os elementos da sequência na ordem em que foram gerados.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de elementos do maior intervalo que contém apenas números distintos.\nRestrições\n• 1 ≤ N ≤ 105 • 1 ≤ Ii ≤ 105 Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (23 pontos): N ≤ 100 • Subtarefa 2 (18 pontos): N ≤ 5000 • Subtarefa 3 (15 pontos): Ii ≤ 100 • Subtarefa 4 (44 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por alguma das suas submissões.\nExemplos\nExplicação do exemplo 1: três intervalos, com três elementos cada, contêm números distintos: [3, 2, 1], [2, 1, 3] e [1, 3, 2] – note também que os intervalos ocorrem mais de uma vez na sequência. Como não há intervalo com números distintos maior do que esses, a resposta é 3.\n  Explicação do exemplo 2: o maior intervalo que contém números distintos é [2, 3, 8, 5], com 4 elementos, portanto a resposta é 4.",
    "examples": [
      [
        "8\n3\n2\n1\n3\n2\n1\n3\n2",
        "3"
      ],
      [
        "6\n3\n2\n3\n8\n5\n5",
        "4"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "distinto"
    },
    "imagesQuant": 0
  },
  {
    "name": "Prefixo",
    "description": "Em programas de computador, palavras, como “otorrinolaringologista” ou “escolaridade”, são normalmente representadas por uma cadeia de caracteres. Um prefixo de uma palavra é qualquer sequência de caracteres consecutivos que se inicia no primeiro caractere da palavra. Por exemplo, “escola” e “esco” são prefixos de “escola”, mas “cola” não é.\nUm prefixo comum de duas palavras é uma cadeia de caracteres que é prefixo das duas palavras. Por exemplo, “a”, “aba” e “abaca” são exemplos de prefixos comuns das palavras “abacate” e “abacaxi”.\nDadas duas palavras, escreva um programa para calcular o comprimento do maior prefixo comum, em número de caracteres.\nEntrada\nA primeira linha de entrada contém um inteiro N, o número de caracteres da primeira palavra. A segunda linha contém uma cadeia com N caracteres Pi, a primeira palavra. A terceira linha contém um inteiro M, o número de caracteres da segunda palavra. A quarta linha contém uma cadeia com M caracteres Si, a segunda palavra.\nSaída\nSeu programa deve produzir uma única linha, contendo um único inteiro, o número de caracteres do maior prefixo que é comum às duas sequências.\nRestrições\n• 1 ≤ N ≤ 1 000 • 1 ≤ M ≤ 1 000 • As palavras contêm apenas letras minúsculas sem acentuação.\nInformações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (33 pontos): N = M • Subtarefa 2 (67 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente ambas ou somente uma das subtarefas. Sua pontuação final na tarefa é a soma dos pontos das subtarefas resolvidas corretamente por alguma das suas submissões.\nExemplos\nExplicação do exemplo 1: “abaca”, com 5 caracteres, é o maior prefixo comum entre “abacate” e “abacaxi”, portanto 5 é a resposta.\n  Explicação do exemplo 2: “paralelo”, com 8 caracteres, é o maior prefixo comum entre “paralelo” e “paralelogramo”, portanto 8 é a resposta.\n  Explicação do exemplo 3: “escola” e “cola”, não têm prefixo comum, portanto a resposta é 0.",
    "examples": [
      [
        "7\nabacate\n7\nabacaxi",
        "5"
      ],
      [
        "8\nparalelo\n13\nparalelogramo",
        "8"
      ],
      [
        "6\nescola\n4\ncola",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "prefixo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Barcos da Nlogônia",
    "description": "Como todos sabem, a Nlogônia é um arquipélago que mantém a tradição milenar de não permitir a construção de pontes. Assim, o transporte público entre as ilhas se dá por meio de barcos.\nPara cada par de ilhas há no máximo um barco que faz o transporte de ida e volta entre as duas ilhas; ou seja, pode não haver transporte direto entre um determinado par de ilhas. No entanto, é possível ir de qualquer ilha para qualquer outra ilha utilizando apenas os barcos de transporte público (note que pode ser preciso passar por outras ilhas no trajeto).\nOs barcos de transporte público da Nlogônia não são todos iguais: cada barco tem um limite máximo de passageiros que ele pode carregar.\nCada ilha tem um time de basquete, com um grupo de fãs. Todos os fãs de um time são moradores da mesma ilha do time para o qual torcem. Nos dias de jogo, o grupo de fãs do time visitante sempre planeja viajar usando apenas barcos de transporte público, todos juntos, para a ilha onde acontecerá o jogo (ou seja, todos os membros do grupo juntos, durante todo o trajeto). Mas os fãs sabem que isso talvez não seja possível devido ao limite de passageiros dos barcos de transporte público. Você poderia ajudá-los? Dados a lista dos barcos existentes, com os respectivos limites de passageiros, e uma série de consultas, cada uma com a ilha de início do trajeto e a ilha onde ocorrerá o jogo, sua tarefa é determinar, para cada consulta da entrada, qual o maior número de torcedores que o grupo pode ter para poder viajar junto.\nEntrada\nA primeira linha contém dois inteiros N e B, indicando, respectivamente, o número de ilhas da Nlogônia e o número de barcos de transporte público que ligam as ilhas. As ilhas nlogonianas são identificadas por números de 1 a N.\nCada uma das B linhas seguintes descreve o trajeto de um barco de transporte público e contém três inteiros I, J e P, onde I e J indicam as duas ilhas ligadas por esse barco e P indica o limite de passageiros do barco. Note que o barco pode fazer o transporte tanto de I para J quanto de J para I.\nA linha seguinte contém um inteiro C que indica o número de consultas. Finalmente, cada uma das C linhas seguintes descreve uma consulta e contém dois inteiros X e Y indicando, respectivamente, a ilha de início e a ilha do local do jogo.\nSaída\nPara cada consulta, na ordem em que elas foram descritas na entrada, seu programa deve produzir uma linha contendo um único inteiro, o maior número de passageiros que o grupo pode ter para viajar junto do início até o local do jogo.\nRestrições\n• 2 ≤ N ≤ 105 • 1 ≤ B ≤ 105 • 1 ≤ I ≤ N, 1 ≤ J ≤ N e I ̸= J, cada par I,J aparece no máximo uma vez na entrada.\n• 1 ≤ P ≤ 105 • 1 ≤ C ≤ 5 × 104 • 1 ≤ X ≤ N, 1 ≤ J ≤ N e X ̸= Y Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (11 pontos): N = 3 • Subtarefa 2 (13 pontos): – N ≤ 1000 – B = N − 1 – Para todo 1 ≤ I ≤ N − 1, há um barco de transporte público entre as ilhas I e I + 1.\n– C ≤ 1000 (Veja o exemplo 2.) • Subtarefa 3 (22 pontos): B = N − 1 • Subtarefa 4 (33 pontos): – N ≤ 1000 – C = 1 • Subtarefa 5 (21 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por alguma das suas submissões.\nExemplos\nExplicação do exemplo 1: A seguir temos uma visualização das ilhas e dos barcos que conectam essas ilhas: Perceba que é possível 75 pessoas irem da ilha 2 à ilha 1 usando os seguintes barcos: • da ilha 2 para a ilha 4, onde o barco suporta até 80 passageiros.\n• da ilha 4 para a ilha 5, onde o barco suporta até 75 passageiros.\n• da ilha 5 para a ilha 1, onde o barco suporta até 85 passageiros.\nPerceba também que é possível 60 pessoas irem da ilha 1 à ilha 3 usando os seguintes barcos: • da ilha 1 para a ilha 5, onde o barco suporta até 85 passageiros.\n• da ilha 5 para a ilha 4, onde o barco suporta até 75 passageiros.\n• da ilha 4 para a ilha 2, onde o barco suporta até 80 passageiros.\n• da ilha 2 para a ilha 3, onde o barco suporta até 60 passageiros.\n  Explicação do exemplo 2: A seguir temos uma visualização das ilhas e dos barcos que conectam essas ilhas:",
    "examples": [
      [
        "5 6\n1 4 50\n1 5 85\n2 3 60\n2 4 80\n4 5 75\n1 3 40\n2\n2 1\n1 3",
        "75\n60"
      ],
      [
        "7 6\n1 2 30\n2 3 20\n3 4 10\n4 5 50\n5 6 40\n6 7 100\n4\n2 7\n4 7\n1 3\n6 7",
        "10\n40\n20\n100"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 2,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "barcos"
    },
    "imagesQuant": 2
  },
  {
    "name": "Cabo de guerra",
    "description": "Autor: Mateus Bezrutchka Na mais nova conferência da OBI (Organização de Brincadeiras Infantis), os participantes estão explorando brincadeiras de competição em times, como o clássico jogo do Cabo de Guerra. A versão de Cabo de Guerra jogada na OBI é sempre disputada entre dois times, cada um com três integrantes. Cada time se reúne em uma das pontas de uma corda e então os times começam a puxar a corda em direções opostas. O time vencedor é aquele que consegue puxar a corda em sua direção, fazendo com que o time oponente a solte.\nNo banco de dados da OBI, cada jogador possui uma força, representada por um número inteiro entre 1 e 100, e a força total de um time é definida como a soma das forças de seus integrantes. Por exemplo, um time cujos integrantes têm forças 7, 5 e 8 tem força total 7+5+8 = 20. Os estudos da OBI concluíram que, se os dois times tiverem forças totais diferentes, a partida de Cabo de Guerra sempre acaba em menos de 5 minutos. Porém, se os dois times tiverem exatamente a mesma força total, o jogo entra em um impasse e os participantes continuam puxando a corda por 12 horas! 10 10 7 total = 20 10 total = 30 3 10 8 10 5 10 7 total = 20 20 total = 40 Impasse Sem Impasse A coordenação da OBI está organizando partidas de Cabo de Guerra, mas precisa evitar qualquer impasse. Por isso, eles pediram a sua ajuda: dadas as forças dos seis participantes de uma partida, determine se existe alguma chance de impasse – ou seja, se existe um modo de dividir os seis participantes em dois times tal que cada participante pertença a exatamente um dos dois times, cada time tenha três integrantes, e os dois times tenham a mesma força total.\nEntrada\nA única linha da entrada contém seis números inteiros positivos Xi (1 ≤ i ≤ 6), indicando as forças dos seis participantes.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único caractere: ‘S’ (sem aspas), se existe um modo de dividir os times que causa impasse, ou ‘N’ (sem aspas), se não existe modo de causar impasse.\nRestrições\n• 1 ≤ Xi ≤ 100 para 1 ≤ i ≤ 6 Informações sobre a pontuação\nA tarefa vale 100 pontos.\nExemplos\nExplicação do exemplo 1: Esse exemplo é representado pela figura (a). Podemos montar um dos times com os participantes de forças 7, 5 e 8 e o outro time com os participantes de forças 3, 10 e 7. Desse modo, ambos os times têm força total 20.\n  Explicação do exemplo 2: Esse exemplo é representado pela figura (b). Em qualquer divisão válida dos participantes em dois times, um dos times terá força total 20 + 10 + 10 = 40 e o outro terá força total 10 + 10 + 10 = 30, logo as forças totais não podem ser iguais.",
    "examples": [
      [
        "7 5 3 8 10 7",
        "S"
      ],
      [
        "10 10 10 20 10 10",
        "N"
      ],
      [
        "5 5 6 6 8 8",
        "S"
      ],
      [
        "4 8 12 24 20 16",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": "Mateus Bezrutchka",
      "codename": "cabo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Oficina Mecânica",
    "description": "Autor: André Amaral de Sousa O dono de uma oficina mecânica te contratou para criar um software de gerenciamento. Com esse software, ele espera não só conseguir controlar os estoques dos produtos utilizados na oficina, mas também auxiliar no trabalho de seus funcionários e tornar a oficina mais eficiente.\nComo um(a) excelente programador(a), você já implementou quase todo o software. Falta apenas uma funcionalidade: distribuir os carros a serem consertados entre os mecânicos de modo a garantir alta satisfação dos clientes. Após analisar os dados coletados na oficina sobre clientes passados, você descobriu que o fator mais importante para a satisfação de um cliente é seu tempo de espera para ser atendido, ou seja, o tempo em que ele fica esperando até o seu carro começar a ser consertado.\nOs clientes não se importam com o tempo de conserto de seus respectivos carros, pois eles sabem que os mecânicos fazem um excelente trabalho.\nO tempo de conserto varia de acordo com o carro e com o mecânico: cada carro possui um tempo base Ti, já determinado durante o orçamento, que mede a quantidade de trabalho necessária para consertar o carro, e cada mecânico possui um fator de trabalho Fj, indicando quanto tempo ele demora para completar uma unidade de trabalho. Assim, o tempo necessário para o mecânico j consertar o carro i é Ti · Fj. Vale ressaltar que cada mecânico só trabalha em um único carro por vez, e portanto precisa finalizar o conserto de um carro antes de começar a consertar o próximo.\nPor exemplo, suponha que tenhamos quatro carros cujos tempos base são 5, 10, 15 e 20, e dois mecânicos cujos fatores de trabalho são 1 e 2. Uma distribuição possível é: • O mecânico com fator 1 conserta os carros com tempos 20 e 5, nessa ordem.\n• O mecânico com fator 2 conserta os carros com tempos 10 e 15, nessa ordem.\nEssa distribuição possui os seguintes tempos de espera: • O carro com tempo base 20 é atendido imediatamente, portanto seu tempo de espera é 0.\n• O carro com tempo base 5 precisa esperar o carro com tempo base 20 ser consertado, portanto seu tempo de espera é 20 · 1 = 20.\n• O carro com tempo base 10 é atendido imediatamente, portanto seu tempo de espera é 0.\n• O carro com tempo base 15 precisa esperar o carro com tempo base 10 ser consertado, portanto seu tempo de espera é 10 · 2 = 20.\nA soma total dos tempos de espera na distribuição acima é 0+20+0+20 = 40. Porém, existe uma distribuição (que é ótima) onde a soma total dos tempos de espera é 20 – você consegue encontrá-la? Dados o número N de carros esperando para serem atendidos, a quantidade M de mecânicos, o tempo base Ti de cada carro, e o fator de trabalho Fj de cada mecânico, determine a menor soma total dos tempos de espera dos carros, que corresponde à melhor forma de distribuir todos os carros entre os mecânicos.\nEntrada\nA primeira linha da entrada contém dois inteiros N e M representando o número de carros e o número de mecânicos, respectivamente.\nA segunda linha contém N números inteiros. O i-ésimo desses números será Ti, representando o tempo base do i-ésimo carro.\nA terceira e última linha da entrada contém M números inteiros. O j-ésimo desses números será Fj, representando o fator de trabalho do j-ésimo mecânico.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único inteiro, a menor soma total dos tempos de espera em uma distribuição de todos os carros entre os mecânicos.\nRestrições\n• 1 ≤ N ≤ 100 000 • 1 ≤ M ≤ 100 000 • 1 ≤ Ti ≤ 10 000 para todo 1 ≤ i ≤ N • 1 ≤ Fj ≤ 10 000 para todo 1 ≤ j ≤ M Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (14 pontos): N ≤ 1000 e M = 1.\n• Subtarefa 2 (10 pontos): Ti = 1 para todo 1 ≤ i ≤ N e Fj = 1 para todo 1 ≤ j ≤ M.\n• Subtarefa 3 (16 pontos): Fj = 1 para todo 1 ≤ j ≤ M.\n• Subtarefa 4 (36 pontos): N ≤ 1000 e M ≤ 1000.\n• Subtarefa 5 (24 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Este exemplo corresponde ao exemplo mostrado no enunciado.\n  Explicação do exemplo 2: Como há apenas um mecânico, ele consertará todos os carros. E como todos os tempos base são iguais, a ordem dos carros não afeta o resultado. Logo, podemos só consertar os carros em ordem. Os tempos de espera dos quatro carros são então, respectivamente, 0, 3, 6, e 9, para um total de 0 + 3 + 6 + 9 = 18.",
    "examples": [
      [
        "4 2\n5 10 15 20\n1 2",
        "20"
      ],
      [
        "4 1\n1 1 1 1\n3",
        "18"
      ],
      [
        "4 1\n15 5 10 20\n3",
        "150"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": "André Amaral de Sousa",
      "codename": "mecanica"
    },
    "imagesQuant": 0
  },
  {
    "name": "Metrônibus",
    "description": "Autores: André Amaral de Sousa e Mateus Bezrutchka metronibus.py Ênia, a atual rainha da Nlogônia, é fascinada por meios de transporte, especialmente metrô e ônibus. Como consequência, a Nlogônia possui a melhor rede de transporte público do mundo inteiro, a Metrônibus.\nExistem N estações espalhadas por todo o reino, que são conectadas por dois sistemas de transporte: ônibus, que utiliza rodovias, e metrô, que utiliza trilhos. Assim, no Metrônibus existe transporte direto entre duas estações se elas estão ligadas por uma rodovia ou por um trilho. Toda ligação, independente de ser rodovia ou trilho, pode ser utilizada em ambas as direções. Existe no máximo uma ligação entre cada par de estações (ou seja, um par de estações não pode estar ligado por ambos um trilho e uma rodovia).\nPara utilizar o Metrônibus, o usuário precisa comprar passagens. Ênia estabeleceu as seguintes regras para estimular o transporte público: • Toda passagem tem um preço fixo P, independente da estação e do sistema (metrô ou ônibus).\n• A passagem só deve ser paga quando o usuário entrar no sistema de transporte.\n• O usuário só pode entrar em um sistema por vez (ou seja, para entrar no sistema de metrô ele precisa sair do sistema de ônibus, e vice-versa).\n• Após pagar o preço P para entrar em um sistema, o usuário pode se locomover o quanto desejar usando ligações daquele sistema, contanto que ele não saia do sistema. Caso o usuário troque de sistema, ele deverá pagar por uma nova passagem para retornar ao sistema original.\nPor exemplo, considere a seguinte rede do Metrônibus: 3 1 2 4 5 7 6 Existem 7 estações e 9 ligações no total, das quais 4 são trilhos do metrô e as outras 5 são rodovias para ônibus. Suponha que o preço da passagem seja P = 5 e que o usuário deseja fazer uma viagem da estação 1 para a estação 7. Temos várias opções de trajeto, como por exemplo (as setas indicam a ordem em que visitamos as estações): • Viagem 1: 1 → 3 → 2 → 4 → 5 → 6 → 7 – A ligação entre as estações 1 e 3 usa o metrô, então precisamos entrar no sistema de metrô pela primeira vez, pagando P = 5.\n– O trecho 1 → 3 → 2 → 4 é todo percorrido de metrô, logo não precisamos pagar de novo.\n– 4 → 5 usa ônibus, então precisamos pagar P = 5 para trocar de metrô para ônibus.\n– 5 → 6 usa o metrô, então pagamos mais P = 5 para reentrar no sistema de metrô.\n– 6 → 7 usa ônibus, então precisamos pagar mais P = 5 para entrar no sistema de ônibus novamente e chegar à estação 7.\n– No total, a viagem custa 5 + 5 + 5 + 5 = 20.\n• Viagem 2: 1 → 4 → 5 → 6 → 7 – A ligação entre as estações 1 e 4 usa ônibus, que estamos utilizando pela primeira vez, então é necessário pagar P = 5.\n– 4 → 5 também usa ônibus, ou seja, continuamos no mesmo sistema de transporte e não é necessário pagar outra passagem.\n– 5 → 6 usa o metrô, que vamos utilizar pela primeira vez, logo é necessário pagar P = 5.\n– 6 → 7 usa o sistema de ônibus, do qual saímos e precisamos pagar P = 5 para reentrar.\n– No total, a viagem custa 5 + 5 + 5 = 15.\nExistem outras viagens que começam na estação 1 e terminam na estação 7. Porém, o menor custo total entre todas essas viagens é 15 (correspondente à viagem 2).\nÊnia deseja saber o menor custo total para ir da estação A para a estação B, e para isso te contratou.\nResponda corretamente, ou ela te expulsará da Nlogônia! Entrada\nA primeira linha da entrada contém quatro inteiros N, K1, K2, e P, representando o número de estações, o número de ligações (trilhos) no sistema de metrô, o número de ligações (rodovias) no sistema de ônibus, e o preço da passagem, respectivamente.\nAs próximas K1 linhas contém a descrição das ligações do metrô. A i-ésima dessas linhas terá dois inteiros Vi e Ui, representando que há um trilho entre as estações Vi e Ui.\nAs próximas K2 linhas contém a descrição das ligações de ônibus. A j-ésima dessas linhas terá dois inteiros Xj e Yj, representando que há uma rodovia entre as estações Xj e Yj.\nA última linha da entrada contém dois números inteiros, A e B, representando a estação inicial e a estação final da viagem requisitada pela rainha.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único inteiro, o menor custo total de uma viagem que começa na estação A e termina na estação B.\nSe não for possível fazer uma viagem de A a B usando o Metrônibus, imprima −1.\nRestrições\n• 2 ≤ N ≤ 100 000 • 1 ≤ K1 + K2 ≤ 100 000 • 1 ≤ P ≤ 1 000 • 1 ≤ Vi,Ui ≤ N para todo 1 ≤ i ≤ K1 • Vi ̸= Ui para todo 1 ≤ i ≤ K1 • 1 ≤ Xj,Yj ≤ N para todo 1 ≤ j ≤ K2 • Xj ̸= Yj para todo 1 ≤ j ≤ K2 • Cada par de estações é ligado por no máximo uma ligação no total (ou seja, considerando ambos os sistemas) • 1 ≤ A,B ≤ N • A ̸= B Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (31 pontos): K2 = 0, ou seja, todas as ligações são do sistema de metrô. (Veja o exemplo 2.) • Subtarefa 2 (32 pontos): N ≤ 100.\n• Subtarefa 3 (37 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Este exemplo corresponde ao exemplo mostrado no enunciado.\n  Explicação do exemplo 2: A estação 5 não possui ligação com nenhuma outra estação, portanto é impossível chegar nela a partir da estação 3.",
    "examples": [
      [
        "7 4 5 5\n1 3\n3 2\n4 2\n6 5\n4 1\n4 3\n4 5\n2 5\n6 7\n1 7",
        "15"
      ],
      [
        "6 4 0 42\n1 4\n6 1\n3 2\n4 6\n3 5",
        "-1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": "André Amaral de Sousa e Mateus Bezrutchka",
      "codename": "metronibus"
    },
    "imagesQuant": 0
  },
  {
    "name": "Tesouro",
    "description": "Autor: Mateus Bezrutchka Eduardo é um estudante do departamento de Arqueologia da Unicamp que recentemente encontrou um mapa da Quadradônia, uma ilha histórica cujos habitantes adoravam quadrados. A ilha pode ser representada como um quadrado de lado M dividido em M2 quadrados unitários com coordenadas de (1,1) a (M,M), com a primeira coordenada indicando a linha (numerada de 1 a M de Norte a Sul) e a segunda indicando a coluna (numerada de 1 a M de Oeste a Leste). Cada um desses M2 quadrados representa uma região da ilha.\nA Quadradônia está atualmente inabitada: seus habitantes fugiram quando a areia que cobre a ilha se tornou movediça! A areia de cada uma das regiões se move em um sentido específico, que pode ser para o Norte, Sul, Leste ou Oeste. Uma pessoa que pisa em uma das regiões da ilha é imediatamente arrastada pela areia, sendo movida da sua região atual para uma das regiões vizinhas (de acordo com o sentido de movimento da areia na região atual), com a velocidade de uma região por minuto. A figura abaixo ilustra uma representação da Quadradônia para M = 4, com o sentido de movimento da areia indicado em cada região.\n1 2 3 4 N 1 2 O L 3 4 S (a) O mapa encontrado por Eduardo indica a posição de um tesouro escondido em uma das regiões da Quadradônia, que está marcada com um X. Para todas as outras regiões, o mapa indica, com um caractere, o sentido no qual a areia se move na região (N para Norte, S para Sul, L para Leste, O para Oeste). A figura (b) indica o mapa do tesouro correspondente à figura (a), assumindo que o tesouro está escondido na região (3,2).\n1 2 3 4 1 S S O S 2 S L L S 3 O X O O 4 N S S N (b) Interessado no tesouro, Eduardo escolheu uma das regiões da ilha para sobrevoar e saltar de paraquedas, pousando na região escolhida. Ele percebeu que a escolha dessa região inicial é muito importante: dependendo da região inicial, ele pode demorar mais ou menos tempo para chegar à região que contém o tesouro. Além disso, é possível que ele eventualmente seja arrastado para fora das bordas da ilha, caindo no mar, ou ainda que seja arrastado na areia movediça para sempre, sem nunca chegar ao tesouro.\nConsidere os seguintes percursos possíveis: S S O S S S O S S L L S S L L S O X O O O X O O N S S N N S S N (c) (d) A figura (c) indica o percurso de Eduardo se ele saltar na região (1,3); nesse caso, ele chega ao tesouro em 7 minutos. A figura (d) indica o percurso para região inicial (1,1); nesse caso, ele é jogado ao mar após chegar à região (3,1).\nEduardo pediu sua ajuda: dado o mapa do tesouro da Quadradônia e as coordenadas da região inicial dele (ou seja, a região na qual ele vai pousar), determine o tempo em minutos que ele levará para chegar à região que contém o tesouro. Caso Eduardo nunca chegue ao tesouro, indique se ele cairá no mar ou ficará preso na areia movediça para sempre.\nEntrada\nA primeira linha da entrada é composta por um inteiro M, indicando que a Quadradônia é composta por M × M regiões.\nAs próximas M linhas descrevem o mapa do tesouro e possuem M caracteres cada. Rij, o j-ésimo caractere da i-ésima dessas linhas, representa a região (i,j) e pode ser: • ‘X’, se a região (i,j) contém o tesouro; • ‘N’, ‘S’, ‘L’ ou ‘O’, de acordo com o sentido de movimento da areia na região.\nA última linha da entrada contém dois inteiros A e B, as coordenadas da região inicial de Eduardo (ou seja, a região na qual ele vai pousar).\nSaída\nSeu programa deverá produzir uma única linha contendo um único inteiro: • Se Eduardo eventualmente chega à região que contém o tesouro, imprima o tempo em minutos que ele leva para chegar ao tesouro.\n• Se Eduardo continua sendo arrastado na areia para sempre, sem nunca chegar ao tesouro, imprima 0.\n• Se Eduardo sai das bordas da ilha e é jogado ao mar, imprima −1.\nRestrições\n• 2 ≤ M ≤ 1 000 • Rij = ‘N’, ‘S’, ‘L’, ‘O’ ou ‘X’ para todos 1 ≤ i,j ≤ M • Existe exatamente um par (i,j) para o qual Rij = ‘X’ • 1 ≤ A,B ≤ M • MAB ̸= ‘X’ (ou seja, a região inicial e a região do tesouro são distintas) Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (30 pontos): M = 2. (Veja os exemplos 3 e 4.) • Subtarefa 2 (40 pontos): M ≤ 50 e é garantido que Eduardo consegue chegar à região que contém o tesouro.\n• Subtarefa 3 (30 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Esse é o exemplo da figura (c).\n  Explicação do exemplo 2: Esse é o exemplo da figura (d).\n    Explicação do exemplo 4: Eduardo ficará para sempre sendo arrastado entre as regiões (1,2), cuja areia se move para o Oeste, e (1,1), cuja areia se move para o Leste.",
    "examples": [
      [
        "4\nSSOS\nSLLS\nOXOO\nNSSN\n1 3",
        "7"
      ],
      [
        "4\nSSOS\nSLLS\nOXOO\nNSSN\n1 1",
        "-1"
      ],
      [
        "2\nSO\nXO\n2 2",
        "1"
      ],
      [
        "2\nLO\nXO\n1 2",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": "Mateus Bezrutchka",
      "codename": "tesouro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Dominó Nlogônico",
    "description": "Autor: André Amaral de Sousa A Nlogônia é o lugar das coisas gigantes (por exemplo, o sistema de transporte de lá possui 100 000 estações!). Recentemente, seus habitantes têm se entretido com um novo jogo: Dominó Nlogônico.\nComo era de se esperar, o dominó da Nlogônia não é nada comum, e também pode ser gigante! O jogo funciona da seguinte forma: • N peças de dominó são posicionadas de pé, em linha reta.\n• A i-ésima peça está em pé na posição Xi da reta e possui altura Hi.\n• Quando uma peça é derrubada para a direita, ela cai e ocupa o intervalo de Xi a Xi + Hi na reta, conforme mostrado na figura a seguir: y Hi x Xi Xi+Hi • Se, ao cair, a peça ocupar a posição de alguma outra peça (ou seja, se a posição da outra peça estiver no intervalo [Xi,Xi +Hi]), essa outra peça também cai, podendo derrubar mais peças, e assim sucessivamente.\n• O objetivo do jogo é computar, para cada peça, quantos dominós iriam cair caso ela fosse derrubada para a direita.\nPara entender este mecanismo, veja o exemplo abaixo: 6 2 2 1 1 1 1 1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 A figura acima mostra 10 dominós. Caso o dominó na posição 3 fosse derrubado para a direita, o resultado final seria: 1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 No total, 7 dominós iriam cair, pois: • Ao ser derrubado para a direita, o dominó na posição 3 iria derrubar o dominó na posição 4.\n• Ao ser derrubado para a direita, o dominó na posição 4 iria derrubar os dominós nas posições 5 e 9.\n• Ao ser derrubado para a direita, o dominó na posição 5 iria derrubar o dominó na posição 7.\n• Ao ser derrubado para a direita, o dominó na posição 9 iria derrubar o dominó na posição 11.\n• Ao ser derrubado para a direita, o dominó na posição 11 iria derrubar o dominó na posição 12.\nObserve que, toda vez que um dominó derrubado para a direita ocupa a posição de outro dominó, este outro dominó também cai, inclusive se a posição do outro dominó for um dos extremos do dominó derrubado (ou seja, as bordas de [Xi,Xi + Hi]).\nNote também que o jogo pede a resposta para cada dominó de maneira independente: a resposta para um dado dominó é o número de dominós derrubados assumindo que todos começam em pé em suas posições e apenas ele é derrubado inicialmente, possivelmente gerando a queda de outros dominós. Assim, no exemplo acima, a resposta para o dominó na posição 9 é 3 (ao cair, ele derruba o dominó na posição 11, que por sua vez derruba o dominó na posição 12).\nJá que você adora a Nlogônia, calcule a resposta para cada uma das peças e prove que você também consegue ganhar esse jogo! Entrada\nA primeira linha da entrada contém apenas um inteiro N, representando o número de peças de dominó.\nA segunda linha contém N números inteiros. O i-ésimo desses números é Xi, representando a posição do dominó i na reta.\nA terceira e última linha contém N números inteiros. O i-ésimo desses números é Hi, representando a altura do dominó i.\nSaída\nSeu programa deverá imprimir uma única linha contendo N números inteiros separados por espaço.\nO i-ésimo desses números deve ser a quantidade total de dominós que iriam cair caso o i-ésimo dominó (na ordem da entrada) fosse derrubado para a direita.\nRestrições\n• 1 ≤ N ≤ 300 000 • 1 ≤ Xi ≤ 1 000 000 000 para todo 1 ≤ i ≤ N • 1 ≤ Hi ≤ 1 000 000 000 para todo 1 ≤ i ≤ N • Xi < Xi+1 para todo 1 ≤ i < N, ou seja, os dominós são dados em ordem crescente de posição, e não existem dois dominós na mesma posição Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (18 pontos): N ≤ 1 000.\n• Subtarefa 2 (22 pontos): Hi ≤ Hi+1 para todo 1 ≤ i < N. (Veja o exemplo 2.) • Subtarefa 3 (33 pontos): ◦ Xi ≤ 1 000 000 para todo 1 ≤ i ≤ N ◦ Hi ≤ 100 para todo 1 ≤ i ≤ N • Subtarefa 4 (27 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Este exemplo corresponde ao exemplo mostrado no enunciado.",
    "examples": [
      [
        "10\n1 3 4 5 7 9 11 12 14 15\n1 1 6 2 1 2 1 1 1 1",
        "1 7 6 2 1 3 2 1 2 1"
      ],
      [
        "4\n2 9 15 25\n5 7 10 13",
        "1 3 2 1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": "André Amaral de Sousa",
      "codename": "domino"
    },
    "imagesQuant": 0
  },
  {
    "name": "Trio de Bonecas",
    "description": "Autor: André Amaral de Sousa Alice é a gerente de produção de uma fábrica de bonecas chinesas. Nessa fábrica, todas as bonecas possuem o mesmo formato, variando apenas de tamanho. As bonecas são vendidas sempre em trios.\nO O O Para um trio formado por bonecas de tamanhos A, B e C, com A ≤ B ≤ C, o balanceamento do trio é definido como (A − B)2. De acordo com o controle de qualidade da fábrica, idealmente cada trio deveria ter balanceamento 0, ou seja, conter duas bonecas de mesmo tamanho e uma terceira boneca de tamanho maior ou igual a essas duas; porém, isso nem sempre é possível devido a limitações de estoque.\nAlice acabou de receber um pedido urgente: o consulado Chinês fará um grande evento no qual pretende distribuir K trios de bonecas, e precisa que Alice envie imediatamente todos os trios.\nExistem na fábrica N bonecas de diversos tamanhos, ainda não separadas em trios, e Alice não sabe se conseguirá formar K trios ideais.\nDevido à urgência do evento, Alice e o consulado fizeram um acordo: o consulado aceitará trios que não sejam ideais; porém, para garantir um bom evento, Alice deve enviar uma caixa com K trios de bonecas cuja soma dos balanceamentos seja a menor possível.\nPor exemplo, suponha que Alice possua 7 bonecas com tamanhos 11, 1, 7, 5, 16, 8 e 15, e que o consulado tenha solicitado 2 trios de bonecas. Algumas configurações possíveis para envio são: • Configuração 1: trios (7, 8, 15) e (1, 5, 16).\n– O primeiro trio possui balanceamento (8 − 7)2 = 1.\n– O segundo trio possui balanceamento (5 − 1)2 = 16.\n– O balanceamento total dessa configuração é 1 + 16 = 17.\n• Configuração 2: trios (5, 7, 16) e (8, 11, 15).\n– O primeiro trio possui balanceamento (7 − 5)2 = 4.\n– O segundo trio possui balanceamento (11 − 8)2 = 9.\n– O balanceamento total dessa configuração é 4 + 9 = 13.\nExistem outras configurações possíveis, mas a menor soma de balanceamentos possível é 13 (correspondente à configuração 2).\nAjude Alice a calcular a soma de balanceamentos minima em um conjunto com K trios de bonecas.\nEntrada\nA primeira linha de entrada contém dois inteiros N e K, representando, respectivamente, o número de bonecas e a quantidade de trios solicitados pelo consulado Chinês.\nA segunda linha contém N números inteiros. O i-ésimo desses números será Ti, representando o tamanho da i-ésima boneca.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único inteiro, a menor soma de balanceamentos possível em uma caixa com K trios de bonecas.\nRestrições\n• 3 ≤ N ≤ 10 000 • 1 ≤ K ≤ 3 000 • 3K ≤ N • 1 ≤ Ti ≤ 100 000 para todo 1 ≤ i ≤ N Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (13 pontos): 1 ≤ Ti ≤ 2 para todo 1 ≤ i ≤ N.\n• Subtarefa 2 (28 pontos): N ≤ 30.\n• Subtarefa 3 (33 pontos): N ≤ 1 000 e K ≤ 100.\n• Subtarefa 4 (26 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Este exemplo corresponde ao exemplo mostrado no enunciado.",
    "examples": [
      [
        "7 2\n11 1 7 5 16 8 15",
        "13"
      ],
      [
        "8 2\n2 1 2 2 2 1 2 2",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": "André Amaral de Sousa",
      "codename": "bonecas"
    },
    "imagesQuant": 0
  },
  {
    "name": "Fast-Food",
    "description": "Autor: Mateus Bezrutchka Após a descoberta de um tesouro escondido terminar uma maldição milenar, a histórica ilha da Quadradônia está pronta para ser repovoada. A expectativa mundial é de que a ilha se torne um grande ponto turístico, recebendo visitantes de todo o planeta. Como você pode imaginar, a Quadradônia tem esse nome porque as suas ruas formam um grid quadriculado e todos os prédios comerciais estão localizados em intersecções entre duas ruas.\nVocê foi contratado como programador na Fast-Food Turbo (FFT), uma rede de franquias de restaurantes de comida rápida. De olho nas oportunidades abertas na Quadradônia, a FFT adquiriu N prédios comerciais na ilha, e deseja abrir, nesses prédios, unidades de duas das suas redes mais populares: o restaurante de hambúrgueres quadrados Quaburguer e o restaurante de pizzas quadradas Pizzatro.\nDevido à localização remota da ilha, é muito difícil levar mercadorias para a Quadradônia. Por isso, quando faltam ingredientes em um restaurante da ilha, a solução mais rápida sempre é pedir esses ingredientes a algum outro restaurante da ilha. Se outro restaurante tiver os ingredientes necessários, ele manda um funcionário de carro para fazer a entrega ao restaurante necessitado.\nPorém, como o Quaburguer e a Pizzatro usam ingredientes bem diferentes, um restaurante só pode fornecer ingredientes para outro restaurante da mesma rede.\nComo não existem engarrafamentos na Quadradônia, o tempo que um entregador leva para ir de um prédio a outro é sempre proporcional à distância quadradônica entre os prédios, definida como a distância que precisa ser percorrida em ruas da ilha para ir de um prédio a outro. Mais formalmente, se os prédios i e j têm coordenadas (Xi,Yi) e (Xj,Yj), respectivamente, a distância quadradônica entre eles é definida como dquad(i,j) = |Xi − Xj| + |Yi − Yj|.\nA FFT precisa decidir, para cada prédio, de qual rede o restaurante desse prédio fará parte. Como a empresa não consegue prever quais prédios precisarão de ingredientes, os membros do conselho decidiram que eles querem minimizar o pior caso possível, ou seja, a distância dquad máxima entre todos os pares de restaurantes de uma mesma rede.\nA figura abaixo ilustra um exemplo para N = 7. Observe que, se os prédios 1 e 4 pertencerem à mesma rede, a resposta será no mínimo a distância entre eles, dquad(1,4) = |2 − 13| + |4 − 5| = 12.\nPorém, podemos conseguir uma distância máxima igual a 8 se tivermos uma rede com os prédios (1,3,5) e a outra com os prédios (2,4,6,8): (5,7) (10,6) (13,5) (2,4) (15,5) (13,3) (7,1) Existem outras configurações possíveis, mas 8 é a distância mínima para esse conjunto de prédios.\nSua tarefa é: dadas as coordenadas dos N prédios que a FFT adquiriu, distribua os N prédios entre as duas redes de modo a minimizar a distância quadradônica máxima entre dois restaurantes de uma mesma rede.\nEntrada\nA primeira linha da entrada contém um único inteiro N, o número de prédios da Quadradônia adquiridos pela FFT.\nA segunda linha da entrada contém N inteiros. O i-ésimo desses inteiros, Xi, representa a primeira coordenada do i-ésimo prédio.\nA terceira e última linha da entrada contém N inteiros. O i-ésimo desses inteiros, Yi, representa a segunda coordenada do i-ésimo prédio.\nSaída\nSeu programa deverá produzir uma única linha contendo um único inteiro, a menor distância quadradônica máxima possível entre dois restaurantes de uma mesma rede.\nRestrições\n• 1 ≤ N ≤ 300 000 • 1 ≤ Xi ≤ 500 000 000 para todo 1 ≤ i ≤ N • 1 ≤ Yi ≤ 500 000 000 para todo 1 ≤ i ≤ N • Observe que é possível que dois prédios tenham as mesmas coordenadas.\nInformações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (23 pontos): N ≤ 16.\n• Subtarefa 2 (35 pontos): N ≤ 2 000.\n• Subtarefa 3 (42 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Esse exemplo corresponde ao exemplo do enunciado.",
    "examples": [
      [
        "7\n2 10 7 13 5 13 15\n4 6 1 5 7 3 5",
        "8"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": "Mateus Bezrutchka",
      "codename": "fastfood"
    },
    "imagesQuant": 0
  },
  {
    "name": "Pirâmide",
    "description": "Autor: Mateus Bezrutchka O mais novo lançamento da OBI (Organização de Brincadeiras Infantis) é o jogo Balanceamento de Pirâmide, que visa explorar as habilidades matemáticas das crianças. O jogo contém seis cubos, todos de mesmo tamanho mas com pesos possivelmente diferentes (os cubos são preenchidos com diferentes volumes de areia). O peso de cada cubo em gramas está escrito em uma de suas faces.\n6 5 4 14 5 8 (a) Em Balanceamento de Pirâmide, o objetivo é empilhar os seis cubos de modo a formar uma pirâmide de três andares (com três cubos no primeiro andar, dois no segundo e um no terceiro) tal que os pesos totais de cada andar (ou seja, a soma dos pesos dos cubos no andar) possuam o mesmo valor; nesse caso, dizemos que a pirâmide é balanceada. Por exemplo, se os cubos tem pesos (em gramas) 6, 5, 4, 14, 5 e 8, podemos obter uma pirâmide balanceada (com peso total 14 em cada andar) colocando os dois cubos de peso 5 e o cubo de peso 4 no primeiro andar, os cubos de pesos 6 e 8 no segundo andar, e o cubo de peso 14 no terceiro andar (veja a figura b).\nEm toda unidade de Balanceamento de Pirâmide, deveria ser possível formar uma pirâmide balanceada com os seis cubos dados. Porém, devido a problemas na linha de produção, isso nem sempre é verdade. Recentemente, foi encontrado um exemplar contendo um cubo de peso 10 e cinco cubos de peso 1! Observe que não podemos obter uma pirâmide balanceada com esses cubos (só o cubo de peso 10 é mais pesado do que todos os outros juntos).\n14 14 10 10 14 6 8 1 1 2 14 4 5 5 1 1 1 3 Balanceada (b) (c) Não balanceada Você foi contratado como parte do controle de qualidade da OBI, e sua primeira missão é avaliar se uma unidade do jogo foi produzida corretamente: dados os pesos dos seis cubos, determine se é possível formar uma pirâmide balanceada com os cubos.\nEntrada\nA única linha da entrada contém seis números inteiros positivos Xi (1 ≤ i ≤ 6), indicando os pesos em gramas de cada um dos seis cubos, separados por espaços.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único caractere: ‘S’ (sem aspas), se é possível formar uma pirâmide balanceada com os seis cubos, ou ‘N’ (sem aspas), se é impossível.\nRestrições\n• 1 ≤ Xi ≤ 1 000 para 1 ≤ i ≤ 6 Informações sobre a pontuação\nA tarefa vale 100 pontos.\nExemplos\nExplicação do exemplo 1: Esse exemplo é representado pela figura (b).\n  Explicação do exemplo 2: Esse exemplo é representado pela figura (c).\n  Explicação do exemplo 3: Podemos colocar os cubos de pesos 10, 30 e 80 no primeiro andar, os cubos de pesos 50 e 70 no segundo andar, e o cubo de peso 120 no terceiro andar, obtendo peso total de 120 por andar.",
    "examples": [
      [
        "6 5 4 14 5 8",
        "S"
      ],
      [
        "10 1 1 1 1 1",
        "N"
      ],
      [
        "10 30 50 70 80 120",
        "S"
      ],
      [
        "4 8 12 24 20 16",
        "N"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": "Mateus Bezrutchka",
      "codename": "piramide"
    },
    "imagesQuant": 0
  },
  {
    "name": "Transportes",
    "description": "Autores: André Amaral de Sousa e Rafael Nascimento Soares transportes.py Ênia, a atual rainha da Nlogônia, é fascinada por meios de transporte de todos os tipos. Como consequência, a Nlogônia possui a melhor rede de transporte público do mundo inteiro.\nExistem N estações espalhadas por todo o reino, K sistemas de transporte (metrô, ônibus, avião, barco, etc) e M ligações diretas entre pares de estações. Cada ligação pertence a um único sistema de transporte entre os K existentes, e pode ser percorrida nas duas direções. Para cada par de estações, existe no máximo uma ligação no total (ou seja, entre todos os sistemas).\nPara usar os sistemas de transporte, o usuário precisa comprar passagens. Ênia estabeleceu as seguintes regras para estimular o transporte público: • Cada um dos K sistemas de transporte tem um preço fixo de passagem. Assim, o preço de uma passagem do sistema i é Pi, independente da estação.\n• A passagem só deve ser paga quando o usuário entrar no sistema de transporte.\n• O usuário só pode entrar em um sistema por vez (por exemplo, para entrar no sistema de avião ele precisa sair do sistema de metrô).\n• Após pagar o preço Pi para entrar no sistema i, o usuário pode se locomover o quanto desejar usando ligações do sistema i, contanto que ele não saia desse sistema. Caso o usuário troque de sistema, ele deverá pagar por uma nova passagem de preço Pi para retornar ao sistema i.\nPor exemplo, considere a seguinte rede de transportes: 1 5 3 1 1 6 2 2 3 2 3 3 1 7 2 4 Perceba que há 7 estações e 9 ligações, das quais 3 são do sistema 1, 3 são do sistema 2 e 3 são do sistema 3. Suponha que os preços das passagens sejam P1 = 5, P2 = 1 e P3 = 7 e que o usuário deseja fazer uma viagem da estação 1 para a estação 7. Temos várias opções de trajeto, como por exemplo (as setas indicam a ordem em que visitamos as estações): • Viagem 1: 1 → 5 → 6 → 3 → 7 – A ligação entre as estações 1 e 5 é do tipo 1, logo precisamos pagar P1 = 5 para entrar no sistema 1 pela primeira vez.\n– 5 → 6 usa o sistema 3, então precisamos pagar P3 = 7 para entrar no sistema 3 (saindo do sistema 1).\n– 6 → 3 usa o sistema 2, então pagamos P2 = 1.\n– 3 → 7 usa o sistema 1, então pagamos P1 = 5. Note que precisamos pagar novamente pela passagem do sistema 1 pois estamos reentrando nele.\n– No total, a viagem custa 5 + 7 + 1 + 5 = 18.\n• Viagem 2: 1 → 5 → 2 → 4 → 7 – 1 → 5 usa o sistema 1, então pagamos P1 = 5.\n– 5 → 2 também usa o sistema 1. Como já entramos nesse sistema, não precisamos pagar novamente.\n– 2 → 4 usa o sistema 3, então trocamos de sistema e pagamos P3 = 7.\n– 4 → 7 usa o sistema 2, então pagamos mais P2 = 1.\n– No total, essa viagem custará 5 + 7 + 1 = 13.\n• Viagem 3: 1 → 5 → 2 → 3 → 7 – 1 → 5 usa o sistema 1, então pagamos P1 = 5.\n– 5 → 2 também usa o sistema 1, então não pagamos nada.\n– 2 → 3 usa o sistema 2, então pagamos P2 = 1 para trocar de sistema.\n– 3 → 7 usa o sistema 1, então pagamos P1 = 5 para voltar ao sistema 1.\n– No total, essa viagem custará 5 + 1 + 5 = 11.\nExistem outras viagens que começam na estação 1 e terminam na estação 7. Porém, o menor custo total entre todas essas viagens é 11 (correspondente à viagem 3).\nÊnia deseja saber o menor custo total para ir da estação A para a estação B, e para isso te contratou.\nResponda corretamente, ou ela te expulsará da Nlogônia! Entrada\nA primeira linha da entrada contém três inteiros N, M e K, representando o número de estações, o número de ligações entre as estações, e a quantidade de sistemas de transporte, respectivamente.\nA segunda linha contém K números inteiros. O i-ésimo desses números é Pi, representando o preço da passagem do sistema de transporte i.\nAs próximas M linhas contém a descrição das ligações. A j-ésima dessas linhas tem três números Vj, Uj e Tj, representando que há uma ligação entre as estações Vj e Uj usando o sistema Tj.\nA última linha da entrada contém dois números inteiros, A e B, representando a estação inicial e a estação final da viagem requisitada pela rainha.\nSaída\nSeu programa deverá imprimir uma única linha contendo um único inteiro, o menor custo total de uma viagem que começa na estação A e termina na estação B.\nSe não for possível fazer uma viagem de A a B usando a rede de transportes, imprima −1.\nRestrições\n• 2 ≤ N ≤ 100 000 • 1 ≤ M ≤ 100 000 • 1 ≤ K ≤ 100 000 • 1 ≤ Pi ≤ 1 000 para todo 1 ≤ i ≤ K • 1 ≤ Vj,Uj ≤ N para todo 1 ≤ j ≤ M • Vj ̸= Uj para todo 1 ≤ j ≤ M • 1 ≤ Tj ≤ K para todo 1 ≤ j ≤ M • Cada par de estações é ligado por no máximo uma ligação no total (ou seja, os pares de estações Vj, Uj são todos distintos) • 1 ≤ A,B ≤ N • A ̸= B Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima: • Subtarefa 1 (11 pontos): K = 1. (Veja o exemplo 2.) • Subtarefa 2 (16 pontos): K = 2, N ≤ 100 e P1 = P2 = 1. (Veja o exemplo 3.) • Subtarefa 3 (34 pontos): K ≤ 10, N ≤ 10 000.\n• Subtarefa 4 (18 pontos): K ≤ 100.\n• Subtarefa 5 (21 pontos): Nenhuma restrição adicional.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos\nExplicação do exemplo 1: Este exemplo corresponde ao exemplo mostrado no enunciado.",
    "examples": [
      [
        "7 9 3\n5 1 7\n1 5 1\n5 2 1\n7 3 1\n3 6 2\n2 3 2\n7 4 2\n2 4 3\n5 6 3\n5 4 3\n1 7",
        "11"
      ],
      [
        "6 4 1\n50\n1 4 1\n6 1 1\n3 2 1\n4 6 1\n3 5",
        "-1"
      ],
      [
        "5 5 2\n1 1\n1 2 1\n5 2 1\n1 3 2\n4 3 1\n4 5 2\n2 3",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2023,
      "phase": 3,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": "André Amaral de Sousa e Rafael Nascimento Soares",
      "codename": "transportes"
    },
    "imagesQuant": 0
  },
  {
    "name": "Bactérias",
    "description": "bacterias.py Tadeu foi contratado recentemente para trabalhar no mais novo laboratório de biologia de sua universidade. Sua primeira tarefa consiste em estudar a taxa de reprodução de um determinado tipo de bactérias.\nTadeu iniciou seu experimento com uma única bactéria e descobriu que as bactérias se reproduzem a cada dia que passa. Mais especificamente, a cada dia, cada bactéria no recipiente de Tadeu se transforma em P bactérias, onde P é um inteiro positivo que Tadeu denominou como fator de multiplicação das bactérias.\nTadeu gostaria de obter a maior quantidade de bactérias possível, mas ele não pode deixar que essa quantidade ultrapasse a capacidade de N bactérias do recipiente, pois isso invalidaria todo o seu experimento. Observe que a quantidade de bactérias pode ser exatamente igual a N e isso não invalida o estudo de Tadeu.\nPor exemplo, em um experimento cuja bactéria tem fator de multiplicação P = 2 e a capacidade do recipiente é N = 32: • no início do experimento há apenas 1 bactéria; • após 1 dia haverá 1 · P = 2 bactérias; • após 2 dias haverá 2 · P = 4 bactérias; • após 3 dias haverá 4 · P = 8 bactérias; • após 4 dias haverá 8 · P = 16 bactérias; • após 5 dias haverá 16 · P = 32 bactérias, o que excede a capacidade N = 30 do recipiente.\nNesse caso, Tadeu pode deixar as bactérias se reproduzindo por no máximo 4 dias.\nDados o fator de multiplicação P e a capacidade N do recipiente, ajude Tadeu a determinar durante quantos dias ele pode deixar as bactérias se reproduzindo sem que a quantidade de bactérias exceda a capacidade do recipiente.\nEntrada\nA entrada é composta de duas linhas, cada uma contendo um único inteiro. A primeira linha contém N, a capacidade do recipiente. A segunda linha contém P, o fator de multiplicação das bactérias.\nSaída\nSeu programa deverá imprimir uma única linha, contendo apenas um inteiro, a quantidade máxima de dias que Tadeu pode deixar as bactérias se reproduzindo sem invalidar seu experimento.\nRestrições\n• 2 ≤ P ≤ N ≤ 30 000 Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (50 pontos): P = 2 e N ≤ 100.\n• Subtarefa 3 (50 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "30\n2",
        "4"
      ],
      [
        "20000\n5",
        "6"
      ],
      [
        "49\n7",
        "2"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "bacterias"
    },
    "imagesQuant": 0
  },
  {
    "name": "Concurso",
    "description": "Cláudia trabalha na OBI (Organização dos Bons Informáticos), que recentemente realizou um concurso para contratar novos funcionários. Agora, Cláudia tem a tarefa de determinar a nota de corte para o concurso. Chamamos de nota de corte a nota mínima necessária para ser aprovado no concurso. Ou seja, se a nota de corte do concurso for C, então todos os participantes com uma nota maior ou igual a C serão aprovados no concurso e todos com nota menor que C serão reprovados.\nSeu chefe pediu para que Cláudia aprove no mínimo K candidatos do concurso para a próxima fase, mas ela também não quer que a nota de corte seja muito baixa. Por isso, Cláudia decidiu que a nota de corte deverá ser a maior nota C que faz com que no mínimo K candidatos sejam aprovados.\nSua tarefa é: dados o número N de candidatos, as notas A1,A2,...,AN dos candidatos e a quantidade mínima de aprovados K, diga qual deve ser a maior nota de corte C para que pelo menos K candidatos sejam aprovados.\nEntrada\nA primeira linha da entrada contém dois inteiros, N e K, representando, respectivamente, o número de participantes e o número mínimo de candidatos que devem ser aprovados.\nA segunda linha da entrada contém N inteiros Ai, representando as notas dos participantes.\nSaída\nSeu programa deve imprimir uma linha contendo um único inteiro C, a nota de corte que deve ser escolhida por Cláudia.\nRestrições\n• 1 ≤ K ≤ N ≤ 500 • 1 ≤ Ai ≤ 100 para todo 1 ≤ i ≤ N Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (20 pontos): K = 1.\n• Subtarefa 3 (20 pontos): K = 3.\n• Subtarefa 4 (20 pontos): Ai ≤ 2.\n• Subtarefa 5 (40 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "3 1\n92 83 98",
        "98"
      ],
      [
        "4 2\n1 2 3 4",
        "3"
      ],
      [
        "5 3\n20 20 10 20 30",
        "20"
      ],
      [
        "10 5\n1 2 2 1 2 2 1 1 1 1",
        "1"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "consurso"
    },
    "imagesQuant": 0
  },
  {
    "name": "Ogro",
    "description": "Ogro e Bicho-Papão têm fama de malvados, mas na verdade são amáveis, honestos e trabalhadores, além de vizinhos e amigos. O Bicho-Papão tem dificuldades em aprender aritmética e por isso o Ogro inventou uma brincadeira simples para auxiliar seu amigo: o Ogro inicia mostrando um certo número de dedos na sua mão esquerda (vamos chamar esse valor de E) e um número de dedos diferente na mão direita (vamos chamar esse valor de D). Então, Bicho-Papão deve falar o resultado da brincadeira, definido assim: • se o número de dedos na mão esquerda é maior do que o número de dedos na mão direita (ou seja E > D) então o resultado é a soma dos dois números (ou seja E + D); • caso contrário, o resultado é o dobro da diferença entre o número de dedos na mão direita e o número de dedos na mão esquerda (ou seja, 2 × (D − E)).\nO problema é que o Ogro também não é lá muito bom em aritmética, e pediu sua ajuda para conferir se o Bicho-Papão falou a resposta correta.\nDados o número de dedos mostrados na mão esquerda (E) e o número de dedos mostrados na mão direita (D), escreva um programa para determinar a resposta da brincadeira.\nEntrada\nA entrada é composta por duas linhas. A primeira linha contém um inteiro E, o número de dedos mostrados na mão esquerda. A segunda linha contém um inteiro D, o número de dedos mostrados na mão direita.\nSaída\nSeu programa deve produzir uma única linha na saída, contendo um único número inteiro, o resultado da brincadeira.\nRestrições\n• 0 ≤ E ≤ 5 • 0 ≤ D ≤ 5 • E ̸= D Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (30 pontos): E > D.\n• Subtarefa 3 (70 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "1\n0",
        "1"
      ],
      [
        "2\n5",
        "6"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 0,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "ogro"
    },
    "imagesQuant": 0
  },
  {
    "name": "Relógio",
    "description": "A Seleção de Basquete Campinense (SBC) está ansiosa para disputar a final do campeonato nacional universitário contra o Clube de Basquete Sergipano (CBS), o arquirrival da SBC. Entretanto, a comissão organizadora esteve sobrecarregada e acabou cometendo alguns erros logísticos, o que levou o jogo a ser adiado em exatamente T segundos. A comissão já está trabalhando dobrado e precisa da sua ajuda para reajustar o horário do jogo.\nA sua tarefa é: dado o horário original de início do jogo e o tempo T, em segundos, em que o jogo foi adiado, determine o novo horário de início do jogo.\nEntrada\nA entrada contém quatro linhas. As três primeiras linhas indicam o horário original de início do jogo: a primeira linha contém um inteiro H, que indica as horas. A segunda linha contém um inteiro M, que indica os minutos. A terceira linha contém um inteiro e S, que indica os segundos.\nA quarta linha contém um único inteiro T, indicando em quantos segundos o jogo foi adiado.\nNote que o horário é dado no formato de 24 horas, ou seja, H é um inteiro entre 0 e 23.\nSaída\nSeu programa deve imprimir o novo horário de início do jogo, seguindo o mesmo formato de horário da entrada. Ou seja, seu programa deve imprimir três linhas, cada uma contendo um único inteiro: • A primeira linha deve conter as horas do novo horário de início do jogo.\n• A segunda linha deve conter os minutos do novo horário de início do jogo.\n• A terceira linha deve conter os segundos do novo horário de início do jogo.\nObserve que você não deve imprimir zeros à esquerda (veja o exemplo de saída 2).\nRestrições\n• 0 ≤ H ≤ 23 • 0 ≤ M ≤ 59 • 0 ≤ S ≤ 59 • 0 ≤ T ≤ 109 Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (60 pontos): T = 1.\n• Subtarefa 3 (20 pontos): T ≤ 105.\n• Subtarefa 4 (20 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "3\n14\n15\n1",
        "3\n14\n16"
      ],
      [
        "11\n59\n59\n1",
        "12\n0\n0"
      ],
      [
        "20\n24\n0\n2024",
        "20\n57\n44"
      ],
      [
        "1\n0\n1\n99101",
        "4\n31\n42"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 1,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "relogio"
    },
    "imagesQuant": 0
  },
  {
    "name": "Jogo da Vida",
    "description": "O Jogo da Vida de Conway é um processo de simulação (conhecido como autômato celular) criado pelo matemático britânico John Conway para reproduzir, por meio de uma matriz, processos de mudança em grupos de seres vivos. As regras do jogo indicam como a matriz é modificada a cada passo. Os valores da matriz em um determinado passo são coletivamente chamados de estado do jogo.\nMais especificamente, o jogo acontece em uma matriz quadrada N ×N (ou seja, com N linhas e N colunas) no qual cada célula está viva (representada pelo número 1) ou morta (representada pelo número 0). Para simular o próximo estado do autômato, para cada célula calculamos o seu número de vizinhos vivos (duas células são consideradas vizinhas se elas são adjacentes diagonalmente, horizontalmente ou verticalmente – ou seja, uma célula pode ter até 8 vizinhas), e decidimos se a célula estará viva ou morta no próximo estado de acordo com as seguintes regras: • se uma célula morta possui exatamente três vizinhas vivas, ela vira uma célula viva; • se uma célula morta possui uma quantidade de vizinhas vivas diferente de três, ela continua morta; • se uma célula viva possui duas ou três vizinhas vivas, ela continua viva; • se uma célula viva possui menos que duas vizinhas vivas, ela morre; • se uma célula viva possui mais que três vizinhas vivas, ela morre.\nToda célula fora da matriz é considerada morta, ou seja, células fora da matriz nunca afetam a quantidade de vizinhos vivos de alguma célula. Observe que as regras são aplicadas em todas as células simultaneamente, uma vez a cada passo.\nDada uma matriz que representa o estado inicial do jogo e um inteiro positivo Q, sua tarefa é determinar o Q-ésimo estado do jogo de acordo com as regras descritas acima, ou seja, o valor de cada célula da matriz após Q passos do jogo.\nA figura abaixo mostra um exemplo de jogo em uma matriz 5 × 5 e seus estados para diferentes valores de Q. Células vivas são representadas com a cor preta e células mortas são representadas com a cor branca.\nEstado Inicial Q = 1 Q = 2 Q = 3 Entrada\nA primeira linha contém dois números inteiros, N e Q, representando, respectivamente, o número de linhas/colunas da matriz e o número de passos a serem simulados.\nAs próximas N linhas contém N caracteres cada. O j-ésimo caractere da i-ésima linha representa o estado inicial da célula na linha i e coluna j. Caso o caractere seja ‘0’, a célula naquela posição inicia o jogo morta; caso o caractere seja ‘1’, a célula inicia o jogo viva.\nSaída\nO seu programa deverá imprimir N linhas, cada uma contendo N caracteres. Na i-ésima linha, o j-ésimo caractere deve representar o Q-ésimo estado da célula na linha i e coluna j. Caso a célula esteja morta, o caractere deve ser ‘0’; se ela estiver viva, o caractere deve ser ‘1’.\nRestrições\n• 1 ≤ N ≤ 50 • 1 ≤ Q ≤ 100 Informações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (30 pontos): Q = 1.\n• Subtarefa 3 (70 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "5 3\n00000\n01110\n01000\n00100\n00000",
        "01100\n11000\n00100\n00000\n00000"
      ],
      [
        "15 1\n000010000010000\n000010000010000\n000011000110000\n000000000000000\n111001101100111\n001010101010100\n000011000110000\n000000000000000\n000011000110000\n001010101010100\n111001101100111\n000000000000000\n000011000110000\n000010000010000\n000010000010000",
        "000000000000000\n000110000011000\n000011000110000\n010010101010010\n011101101101110\n001010101010100\n000111000111000\n000000000000000\n000111000111000\n001010101010100\n011101101101110\n010010101010010\n000011000110000\n000110000011000\n000000000000000"
      ],
      [
        "15 3\n000010000010000\n000010000010000\n000011000110000\n000000000000000\n111001101100111\n001010101010100\n000011000110000\n000000000000000\n000011000110000\n001010101010100\n111001101100111\n000000000000000\n000011000110000\n000010000010000\n000010000010000",
        "000010000010000\n000010000010000\n000011000110000\n000000000000000\n111001101100111\n001010101010100\n000011000110000\n000000000000000\n000011000110000\n001010101010100\n111001101100111\n000000000000000\n000011000110000\n000010000010000\n000010000010000"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 2,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "jogo"
    },
    "imagesQuant": 0
  },
  {
    "name": "Placas de Carro",
    "description": "As placas usadas nos carros em circulação no Brasil possuem dois padrões com formatos diferentes: algumas placas estão no antigo padrão Brasileiro, enquanto outras estão no novo padrão Mercosul.\nO antigo padrão Brasileiro é sempre formado por 8 caracteres: • os três primeiros caracteres são letras maiúsculas (de A a Z); • o quarto caractere é um hífen (-); • os últimos quatro caracteres são dígitos (de 0 a 9).\nPor exemplo, OBI-2024 é uma placa válida no antigo padrão Brasileiro.\nO novo padrão Mercosul, por sua vez, é sempre formado por 7 caracteres: • os três primeiros caracteres são letras maiúsculas; • o quarto caractere é um dígito; • o quinto caractere é uma letra maiúscula; • os últimos dois caracteres são dígitos.\nAssim, OBI2P24 é uma placa válida no novo padrão Mercosul.\nHá também um grande contigente de carros em situação irregular – carros com placas falsificadas que não estão nem no antigo padrão Brasileiro, nem no novo padrão Mercosul. Por exemplo, um carro com a placa OBI-24 está em situação irregular, pois a placa não é válida em nenhum dos dois padrões.\nO Departamento Nacional de Trânsito identificou que seus funcionários gastam muito tempo verificando manualmente quais placas estão em qual padrão e quais são falsificadas. Por isso, eles pediram sua ajuda para automatizar o processo: dada uma placa formada por uma sequência de letras maiúsculas, dígitos e hífens, determine se a placa está no antigo padrão Brasileiro, está no novo padrão Mercosul, ou é uma placa falsificada.\nEntrada\nA entrada é composta de uma única linha, contendo uma sequência de caracteres representando a placa a ser analisada.\nSaída\nSeu programa deverá imprimir uma linha contendo um único número inteiro: • 1, se a placa está no antigo padrão Brasileiro; • 2, se a placa está no novo padrão Mercosul; • 0, se a placa é falsificada.\nRestrições\n• A placa possui entre 6 e 10 caracteres.\n• Cada caractere da placa é uma letra maiúscula (de A a Z), um dígito (de 0 a 9) ou um hífen (o caractere -).\nInformações sobre a pontuação\nA tarefa vale 100 pontos. Estes pontos estão distribuídos em subtarefas, cada uma com suas restrições adicionais às definidas acima.\n• Subtarefa 1 (0 pontos): Esta subtarefa é composta apenas pelos exemplos mostrados abaixo. Ela não vale pontos, serve apenas para que você verifique se o seu programa imprime o resultado correto para os exemplos.\n• Subtarefa 2 (40 pontos): É garantido que a placa está ou no antigo padrão Brasileiro, ou no novo padrão Mercosul (ou seja, ela não é falsificada).\n• Subtarefa 3 (60 pontos): Sem restrições adicionais.\nSeu programa pode resolver corretamente todas ou algumas das subtarefas acima (elas não precisam ser resolvidas em ordem). Sua pontuação final na tarefa é a soma dos pontos de todas as subtarefas resolvidas corretamente por qualquer uma das suas submissões.\nExemplos",
    "examples": [
      [
        "OBI-2024",
        "1"
      ],
      [
        "OBI2P24",
        "2"
      ],
      [
        "OBI-24",
        "0"
      ],
      [
        "XYZ-1234",
        "1"
      ],
      [
        "A1B2C3D4E5",
        "0"
      ]
    ],
    "source": {
      "competition": "OBI",
      "year": 2024,
      "phase": 1,
      "level": 3,
      "warmup": null,
      "letter": null,
      "author": null,
      "codename": "placas"
    },
    "imagesQuant": 0
  }
]